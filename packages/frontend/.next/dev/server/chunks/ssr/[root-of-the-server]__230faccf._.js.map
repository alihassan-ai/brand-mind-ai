{
  "version": 3,
  "sources": [],
  "sections": [
    {"offset": {"line": 4, "column": 0}, "map": {"version":3,"sources":["file:///Users/mac/Desktop/NEW/packages/brain/src/intelligence/store-dna.ts"],"sourcesContent":["/**\n * Store DNA Extractor\n * Analyzes store data to extract patterns, preferences, and intelligence\n */\n\nimport { prisma } from '@brandmind/shared';\nimport { Decimal } from '@prisma/client/runtime/library';\nimport { Prisma } from '@prisma/client';\n\n// ============================================\n// TYPES\n// ============================================\n\ninterface PriceBand {\n    band: string;\n    min: number;\n    max: number;\n    revenue: number;\n    orders: number;\n    products: number;\n    avgPrice: number;\n    refundRate: number;\n}\n\ninterface ProductVelocity {\n    productId: string;\n    title: string;\n    velocity: number;        // units per day\n    acceleration: number;    // change in velocity\n    lifecycleStage: 'rising' | 'peak' | 'declining' | 'dead';\n    daysSinceCreated: number;\n    totalUnitsSold: number;\n}\n\ninterface ProductTypePerformance {\n    type: string;\n    revenue: number;\n    revenueShare: number;\n    orderCount: number;\n    growthRate: number;      // vs previous period\n    avgOrderValue: number;\n}\n\ninterface VendorPerformance {\n    vendor: string;\n    revenue: number;\n    revenueShare: number;\n    refundRate: number;\n    productCount: number;\n}\n\ninterface BasketAffinity {\n    product1: string;\n    product2: string;\n    cooccurrence: number;\n    lift: number;\n}\n\ninterface SeasonalityData {\n    month: number;\n    monthName: string;\n    revenue: number;\n    revenueIndex: number;  // 1.0 = average, >1.2 = peak\n    orderCount: number;\n}\n\n// ============================================\n// HELPER FUNCTIONS\n// ============================================\n\nfunction toNumber(val: Decimal | number | null | undefined): number {\n    if (val === null || val === undefined) return 0;\n    if (typeof val === 'number') return val;\n    return Number(val);\n}\n\nfunction getPriceBandLabel(price: number): string {\n    if (price < 25) return '0-25 (Budget)';\n    if (price < 50) return '25-50 (Mid)';\n    if (price < 100) return '50-100 (Premium)';\n    if (price < 200) return '100-200 (Luxury)';\n    return '200+ (Ultra)';\n}\n\nfunction getPriceBandBounds(band: string): { min: number; max: number } {\n    const bounds: Record<string, { min: number; max: number }> = {\n        '0-25 (Budget)': { min: 0, max: 25 },\n        '25-50 (Mid)': { min: 25, max: 50 },\n        '50-100 (Premium)': { min: 50, max: 100 },\n        '100-200 (Luxury)': { min: 100, max: 200 },\n        '200+ (Ultra)': { min: 200, max: Infinity },\n    };\n    return bounds[band] || { min: 0, max: 0 };\n}\n\n// ============================================\n// CALCULATORS\n// ============================================\n\n/**\n * 2.1 Product Velocity Calculator\n * velocity = total_units_sold / days_since_created\n * acceleration = Δvelocity_30d - Δvelocity_60d\n */\nexport async function calculateProductVelocities(shopId: string): Promise<ProductVelocity[]> {\n    const now = new Date();\n    const thirtyDaysAgo = new Date(now.getTime() - 30 * 24 * 60 * 60 * 1000);\n    const sixtyDaysAgo = new Date(now.getTime() - 60 * 24 * 60 * 60 * 1000);\n\n    // Get all products with their sales data\n    const products = await prisma.product.findMany({\n        where: { shopId },\n        select: {\n            id: true,\n            shopifyId: true,\n            title: true,\n            createdAt: true,\n        },\n    });\n\n    const velocities: ProductVelocity[] = [];\n\n    for (const product of products) {\n        // Total units sold (all time)\n        const totalSales = await prisma.orderLineItem.aggregate({\n            where: {\n                productId: product.shopifyId,\n                order: { shopId },\n            },\n            _sum: { quantity: true },\n        });\n\n        // Sales in last 30 days\n        const sales30d = await prisma.orderLineItem.aggregate({\n            where: {\n                productId: product.shopifyId,\n                order: { shopId, createdAt: { gte: thirtyDaysAgo } },\n            },\n            _sum: { quantity: true },\n        });\n\n        // Sales 30-60 days ago\n        const sales60d = await prisma.orderLineItem.aggregate({\n            where: {\n                productId: product.shopifyId,\n                order: {\n                    shopId,\n                    createdAt: { gte: sixtyDaysAgo, lt: thirtyDaysAgo }\n                },\n            },\n            _sum: { quantity: true },\n        });\n\n        const totalUnitsSold = totalSales._sum.quantity || 0;\n        const daysSinceCreated = Math.max(1, Math.floor((now.getTime() - product.createdAt.getTime()) / (24 * 60 * 60 * 1000)));\n\n        const velocity = totalUnitsSold / daysSinceCreated;\n        const velocity30d = (sales30d._sum.quantity || 0) / 30;\n        const velocity60d = (sales60d._sum.quantity || 0) / 30;\n        const acceleration = velocity30d - velocity60d;\n\n        // Determine lifecycle stage\n        let lifecycleStage: 'rising' | 'peak' | 'declining' | 'dead';\n        if (velocity < 0.01) {\n            lifecycleStage = 'dead';\n        } else if (acceleration > 0.05) {\n            lifecycleStage = 'rising';\n        } else if (acceleration < -0.05) {\n            lifecycleStage = 'declining';\n        } else {\n            lifecycleStage = 'peak';\n        }\n\n        velocities.push({\n            productId: product.id,\n            title: product.title,\n            velocity: Math.round(velocity * 100) / 100,\n            acceleration: Math.round(acceleration * 100) / 100,\n            lifecycleStage,\n            daysSinceCreated,\n            totalUnitsSold,\n        });\n    }\n\n    return velocities.sort((a, b) => b.velocity - a.velocity);\n}\n\n/**\n * 2.2 Price Band Analyzer\n * Group products into bands and calculate metrics per band\n */\nexport async function analyzePriceBands(shopId: string): Promise<{\n    priceBands: PriceBand[];\n    sweetSpot: string;\n}> {\n    // Get all line items with their prices\n    const lineItems = await prisma.orderLineItem.findMany({\n        where: { order: { shopId } },\n        select: {\n            price: true,\n            quantity: true,\n            orderId: true,\n        },\n    });\n\n    // Get refunds by order\n    const refunds = await prisma.refund.findMany({\n        where: { order: { shopId } },\n        select: { orderId: true, amount: true },\n    });\n    const refundedOrders = new Set(refunds.map(r => r.orderId));\n\n    // Group by price band\n    const bandData: Record<string, { revenue: number; orders: Set<string>; refunds: number; prices: number[] }> = {};\n    const bandLabels = ['0-25 (Budget)', '25-50 (Mid)', '50-100 (Premium)', '100-200 (Luxury)', '200+ (Ultra)'];\n    bandLabels.forEach(b => bandData[b] = { revenue: 0, orders: new Set(), refunds: 0, prices: [] });\n\n    for (const item of lineItems) {\n        const price = toNumber(item.price);\n        const band = getPriceBandLabel(price);\n        bandData[band].revenue += price * item.quantity;\n        bandData[band].orders.add(item.orderId);\n        bandData[band].prices.push(price);\n        if (refundedOrders.has(item.orderId)) {\n            bandData[band].refunds++;\n        }\n    }\n\n    // Get product counts per band\n    const variants = await prisma.variant.findMany({\n        where: { product: { shopId } },\n        select: { price: true },\n    });\n    const productCountByBand: Record<string, number> = {};\n    bandLabels.forEach(b => productCountByBand[b] = 0);\n    for (const v of variants) {\n        const band = getPriceBandLabel(toNumber(v.price));\n        productCountByBand[band]++;\n    }\n\n    // Build price bands array\n    const priceBands: PriceBand[] = bandLabels.map(band => {\n        const data = bandData[band];\n        const bounds = getPriceBandBounds(band);\n        const orderCount = data.orders.size;\n        return {\n            band,\n            min: bounds.min,\n            max: bounds.max === Infinity ? 1000 : bounds.max,\n            revenue: Math.round(data.revenue * 100) / 100,\n            orders: orderCount,\n            products: productCountByBand[band],\n            avgPrice: data.prices.length > 0\n                ? Math.round((data.prices.reduce((a, b) => a + b, 0) / data.prices.length) * 100) / 100\n                : 0,\n            refundRate: orderCount > 0\n                ? Math.round((data.refunds / orderCount) * 10000) / 100\n                : 0,\n        };\n    });\n\n    // Find sweet spot: highest (revenue × velocity) / (1 + refundRate)\n    const sweetSpot = priceBands.reduce((best, current) => {\n        const currentScore = (current.revenue * current.orders) / (1 + current.refundRate / 100);\n        const bestScore = (best.revenue * best.orders) / (1 + best.refundRate / 100);\n        return currentScore > bestScore ? current : best;\n    }, priceBands[0]).band;\n\n    return { priceBands, sweetSpot };\n}\n\n/**\n * 2.3 Product Type Performance\n */\nexport async function analyzeProductTypePerformance(shopId: string): Promise<ProductTypePerformance[]> {\n    const now = new Date();\n    const thirtyDaysAgo = new Date(now.getTime() - 30 * 24 * 60 * 60 * 1000);\n    const sixtyDaysAgo = new Date(now.getTime() - 60 * 24 * 60 * 60 * 1000);\n\n    // Get products with their types\n    const products = await prisma.product.findMany({\n        where: { shopId },\n        select: { shopifyId: true, productType: true },\n    });\n    const productTypeMap = new Map(products.map(p => [p.shopifyId, p.productType || 'Uncategorized']));\n\n    // Get sales data by product\n    const lineItems = await prisma.orderLineItem.findMany({\n        where: { order: { shopId } },\n        include: { order: { select: { createdAt: true } } },\n    });\n\n    // Aggregate by product type\n    const typeData: Record<string, {\n        revenue: number;\n        revenue30d: number;\n        revenue60d: number;\n        orders: Set<string>;\n    }> = {};\n\n    for (const item of lineItems) {\n        const productType = productTypeMap.get(item.productId || '') || 'Uncategorized';\n        if (!typeData[productType]) {\n            typeData[productType] = { revenue: 0, revenue30d: 0, revenue60d: 0, orders: new Set() };\n        }\n\n        const revenue = toNumber(item.price) * item.quantity;\n        typeData[productType].revenue += revenue;\n        typeData[productType].orders.add(item.orderId);\n\n        const orderDate = item.order.createdAt;\n        if (orderDate >= thirtyDaysAgo) {\n            typeData[productType].revenue30d += revenue;\n        } else if (orderDate >= sixtyDaysAgo) {\n            typeData[productType].revenue60d += revenue;\n        }\n    }\n\n    const totalRevenue = Object.values(typeData).reduce((sum, d) => sum + d.revenue, 0);\n\n    const performances: ProductTypePerformance[] = Object.entries(typeData).map(([type, data]) => {\n        const growthRate = data.revenue60d > 0\n            ? ((data.revenue30d - data.revenue60d) / data.revenue60d) * 100\n            : 0;\n\n        return {\n            type,\n            revenue: Math.round(data.revenue * 100) / 100,\n            revenueShare: totalRevenue > 0 ? Math.round((data.revenue / totalRevenue) * 10000) / 100 : 0,\n            orderCount: data.orders.size,\n            growthRate: Math.round(growthRate * 100) / 100,\n            avgOrderValue: data.orders.size > 0\n                ? Math.round((data.revenue / data.orders.size) * 100) / 100\n                : 0,\n        };\n    });\n\n    return performances.sort((a, b) => b.revenue - a.revenue);\n}\n\n/**\n * 2.5 Vendor Performance & Concentration (HHI)\n */\nexport async function analyzeVendorPerformance(shopId: string): Promise<{\n    vendors: VendorPerformance[];\n    concentrationHHI: number;\n}> {\n    // Get products with vendors\n    const products = await prisma.product.findMany({\n        where: { shopId },\n        select: { shopifyId: true, vendor: true },\n    });\n    const vendorMap = new Map(products.map(p => [p.shopifyId, p.vendor || 'Unknown']));\n\n    // Get sales data\n    const lineItems = await prisma.orderLineItem.findMany({\n        where: { order: { shopId } },\n        select: { productId: true, price: true, quantity: true, orderId: true },\n    });\n\n    // Get refunds\n    const refunds = await prisma.refund.findMany({\n        where: { order: { shopId } },\n        select: { orderId: true },\n    });\n    const refundedOrders = new Set(refunds.map(r => r.orderId));\n\n    // Aggregate by vendor\n    const vendorData: Record<string, { revenue: number; orders: Set<string>; refunds: number }> = {};\n\n    for (const item of lineItems) {\n        const vendor = vendorMap.get(item.productId || '') || 'Unknown';\n        if (!vendorData[vendor]) {\n            vendorData[vendor] = { revenue: 0, orders: new Set(), refunds: 0 };\n        }\n        vendorData[vendor].revenue += toNumber(item.price) * item.quantity;\n        vendorData[vendor].orders.add(item.orderId);\n        if (refundedOrders.has(item.orderId)) {\n            vendorData[vendor].refunds++;\n        }\n    }\n\n    const totalRevenue = Object.values(vendorData).reduce((sum, d) => sum + d.revenue, 0);\n\n    // Count products per vendor\n    const vendorProductCount: Record<string, number> = {};\n    for (const p of products) {\n        const v = p.vendor || 'Unknown';\n        vendorProductCount[v] = (vendorProductCount[v] || 0) + 1;\n    }\n\n    const vendors: VendorPerformance[] = Object.entries(vendorData).map(([vendor, data]) => ({\n        vendor,\n        revenue: Math.round(data.revenue * 100) / 100,\n        revenueShare: totalRevenue > 0 ? Math.round((data.revenue / totalRevenue) * 10000) / 100 : 0,\n        refundRate: data.orders.size > 0\n            ? Math.round((data.refunds / data.orders.size) * 10000) / 100\n            : 0,\n        productCount: vendorProductCount[vendor] || 0,\n    }));\n\n    // Calculate HHI (Herfindahl-Hirschman Index)\n    // HHI = Σ(market_share²), ranges from 0 (perfect competition) to 1 (monopoly)\n    const hhi = vendors.reduce((sum, v) => {\n        const share = v.revenueShare / 100;\n        return sum + (share * share);\n    }, 0);\n\n    return {\n        vendors: vendors.sort((a, b) => b.revenue - a.revenue),\n        concentrationHHI: Math.round(hhi * 10000) / 10000,\n    };\n}\n\n/**\n * 2.6 Seasonality Curve\n */\nexport async function analyzeSeasonality(shopId: string): Promise<SeasonalityData[]> {\n    const monthNames = ['Jan', 'Feb', 'Mar', 'Apr', 'May', 'Jun', 'Jul', 'Aug', 'Sep', 'Oct', 'Nov', 'Dec'];\n\n    // Get orders with dates\n    const orders = await prisma.order.findMany({\n        where: { shopId },\n        select: { createdAt: true, totalPrice: true },\n    });\n\n    // Aggregate by month\n    const monthlyData: Record<number, { revenue: number; count: number }> = {};\n    for (let i = 0; i < 12; i++) {\n        monthlyData[i] = { revenue: 0, count: 0 };\n    }\n\n    for (const order of orders) {\n        const month = order.createdAt.getMonth();\n        monthlyData[month].revenue += toNumber(order.totalPrice);\n        monthlyData[month].count++;\n    }\n\n    const avgMonthlyRevenue = Object.values(monthlyData).reduce((sum, d) => sum + d.revenue, 0) / 12;\n\n    const seasonality: SeasonalityData[] = Object.entries(monthlyData).map(([month, data]) => ({\n        month: parseInt(month),\n        monthName: monthNames[parseInt(month)],\n        revenue: Math.round(data.revenue * 100) / 100,\n        revenueIndex: avgMonthlyRevenue > 0\n            ? Math.round((data.revenue / avgMonthlyRevenue) * 100) / 100\n            : 0,\n        orderCount: data.count,\n    }));\n\n    return seasonality;\n}\n\n/**\n * 2.4 Customer Purchase Patterns - Entry Products\n * Returns top products that appear in orders (simplified)\n */\nexport async function findEntryProducts(shopId: string): Promise<Array<{ title: string; count: number; share: number }>> {\n    // Get all line items to analyze popular products\n    const lineItems = await prisma.orderLineItem.findMany({\n        where: { order: { shopId } },\n        select: { title: true },\n    });\n\n    // Count occurrences\n    const productCounts: Record<string, number> = {};\n    for (const item of lineItems) {\n        productCounts[item.title] = (productCounts[item.title] || 0) + 1;\n    }\n\n    const total = lineItems.length;\n\n    return Object.entries(productCounts)\n        .map(([title, count]) => ({\n            title,\n            count,\n            share: total > 0 ? Math.round((count / total) * 10000) / 100 : 0,\n        }))\n        .sort((a, b) => b.count - a.count)\n        .slice(0, 10);\n}\n\n/**\n * 2.7 Compute Store DNA - Main function\n */\nexport async function computeStoreDNA(shopId: string) {\n    console.log(`[StoreDNA] Computing DNA for shop: ${shopId}`);\n\n    // Run all calculators\n    const [velocities, priceAnalysis, typePerformance, vendorAnalysis, seasonality, entryProducts] = await Promise.all([\n        calculateProductVelocities(shopId),\n        analyzePriceBands(shopId),\n        analyzeProductTypePerformance(shopId),\n        analyzeVendorPerformance(shopId),\n        analyzeSeasonality(shopId),\n        findEntryProducts(shopId),\n    ]);\n\n    // Load basket affinities from PatternMemory (cross_purchase pattern)\n    const crossPurchasePattern = await prisma.patternMemory.findUnique({\n        where: { shopId_patternType: { shopId, patternType: 'cross_purchase' } },\n    });\n\n    const basketAffinities: BasketAffinity[] = [];\n    if (crossPurchasePattern) {\n        const patternData = crossPurchasePattern.patternData as any;\n        const topPairs = patternData?.topPairs || [];\n        for (const pair of topPairs) {\n            basketAffinities.push({\n                product1: pair.products[0],\n                product2: pair.products[1],\n                cooccurrence: pair.count,\n                lift: Math.min(3, pair.count / 5), // Normalize lift score\n            });\n        }\n    }\n\n    // Categorize products by lifecycle\n    const rising = velocities.filter(v => v.lifecycleStage === 'rising');\n    const peak = velocities.filter(v => v.lifecycleStage === 'peak');\n    const declining = velocities.filter(v => v.lifecycleStage === 'declining');\n    const dead = velocities.filter(v => v.lifecycleStage === 'dead');\n\n    // Calculate health scores\n    const catalogHealthScore = Math.min(100, Math.round(\n        (rising.length * 2 + peak.length * 1.5 - declining.length * 0.5 - dead.length) /\n        Math.max(1, velocities.length) * 50 + 50\n    ));\n\n    const customerHealthScore = Math.min(100, Math.round(\n        (entryProducts.length > 3 ? 30 : entryProducts.length * 10) +\n        (vendorAnalysis.concentrationHHI < 0.25 ? 30 : 15) +\n        40 // Base score\n    ));\n\n    // Upsert to database\n    const storeDNA = await prisma.storeDNA.upsert({\n        where: { shopId },\n        update: {\n            priceSweetSpot: { sweetSpot: priceAnalysis.sweetSpot } as Prisma.InputJsonValue,\n            priceBands: priceAnalysis.priceBands as unknown as Prisma.InputJsonValue,\n            topPerformingTypes: typePerformance.slice(0, 5) as unknown as Prisma.InputJsonValue,\n            growingTypes: typePerformance.filter(t => t.growthRate > 10) as unknown as Prisma.InputJsonValue,\n            decliningTypes: typePerformance.filter(t => t.growthRate < -10) as unknown as Prisma.InputJsonValue,\n            productLifecycles: velocities.slice(0, 50).map(v => ({\n                productId: v.productId,\n                stage: v.lifecycleStage,\n                velocity: v.velocity,\n                acceleration: v.acceleration,\n            })) as unknown as Prisma.InputJsonValue,\n            customerSegments: [] as Prisma.InputJsonValue,\n            basketAffinities: basketAffinities as unknown as Prisma.InputJsonValue,\n            entryProducts: entryProducts as unknown as Prisma.InputJsonValue,\n            upgradePaths: [] as Prisma.InputJsonValue,\n            vendorPerformance: vendorAnalysis.vendors.slice(0, 10) as unknown as Prisma.InputJsonValue,\n            vendorConcentration: vendorAnalysis.concentrationHHI,\n            seasonalityCurve: seasonality as unknown as Prisma.InputJsonValue,\n            catalogHealthScore,\n            customerHealthScore,\n            computedAt: new Date(),\n        },\n        create: {\n            shopId,\n            priceSweetSpot: { sweetSpot: priceAnalysis.sweetSpot } as Prisma.InputJsonValue,\n            priceBands: priceAnalysis.priceBands as unknown as Prisma.InputJsonValue,\n            topPerformingTypes: typePerformance.slice(0, 5) as unknown as Prisma.InputJsonValue,\n            growingTypes: typePerformance.filter(t => t.growthRate > 10) as unknown as Prisma.InputJsonValue,\n            decliningTypes: typePerformance.filter(t => t.growthRate < -10) as unknown as Prisma.InputJsonValue,\n            productLifecycles: velocities.slice(0, 50).map(v => ({\n                productId: v.productId,\n                stage: v.lifecycleStage,\n                velocity: v.velocity,\n                acceleration: v.acceleration,\n            })) as unknown as Prisma.InputJsonValue,\n            customerSegments: [] as Prisma.InputJsonValue,\n            basketAffinities: basketAffinities as unknown as Prisma.InputJsonValue,\n            entryProducts: entryProducts as unknown as Prisma.InputJsonValue,\n            upgradePaths: [] as Prisma.InputJsonValue,\n            vendorPerformance: vendorAnalysis.vendors.slice(0, 10) as unknown as Prisma.InputJsonValue,\n            vendorConcentration: vendorAnalysis.concentrationHHI,\n            seasonalityCurve: seasonality as unknown as Prisma.InputJsonValue,\n            catalogHealthScore,\n            customerHealthScore,\n        },\n    });\n\n    console.log(`[StoreDNA] Computation complete. Catalog Health: ${catalogHealthScore}, Customer Health: ${customerHealthScore}, Basket Affinities: ${basketAffinities.length}`);\n\n    return storeDNA;\n}\n"],"names":[],"mappings":"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"}},
    {"offset": {"line": 584, "column": 0}, "map": {"version":3,"sources":["file:///Users/mac/Desktop/NEW/packages/brain/src/intelligence/gap-detector.ts"],"sourcesContent":["/**\n * Gap Detection Engine\n * Identifies opportunities in the store's catalog\n */\n\nimport { prisma } from '@brandmind/shared';\nimport { Decimal } from '@prisma/client/runtime/library';\n\n// ============================================\n// TYPES\n// ============================================\n\ninterface GapResult {\n    gapType: string;\n    gapScore: number;\n    gapData: Record<string, any>;\n    description: string;\n    suggestedAction: string;\n    potentialRevenue: number | null;\n    confidence: number;\n}\n\n// ============================================\n// HELPERS\n// ============================================\n\nfunction toNumber(val: Decimal | number | null | undefined): number {\n    if (val === null || val === undefined) return 0;\n    if (typeof val === 'number') return val;\n    return Number(val);\n}\n\n// ============================================\n// GAP DETECTORS\n// ============================================\n\n/**\n * 3.1 Price Gap Detector\n * Finds price bands with adjacent demand but low product count\n */\nexport async function detectPriceGaps(shopId: string): Promise<GapResult[]> {\n    const gaps: GapResult[] = [];\n\n    // Get variants with prices\n    const variants = await prisma.variant.findMany({\n        where: { product: { shopId } },\n        select: { price: true },\n    });\n\n    // Get sales by price bands\n    const lineItems = await prisma.orderLineItem.findMany({\n        where: { order: { shopId } },\n        select: { price: true, quantity: true },\n    });\n\n    // Define price bands (clean, unformatted)\n    const bands = [\n        { name: '0-25', min: 0, max: 25, label: 'Budget' },\n        { name: '25-50', min: 25, max: 50, label: 'Mid' },\n        { name: '50-75', min: 50, max: 75, label: 'Standard' },\n        { name: '75-100', min: 75, max: 100, label: 'Premium' },\n        { name: '100-150', min: 100, max: 150, label: 'Elite' },\n        { name: '150-200', min: 150, max: 200, label: 'Luxury' },\n        { name: '200+', min: 200, max: Infinity, label: 'Ultra' },\n    ];\n\n    // Count products and sales per band\n    const bandData = bands.map(band => {\n        const productCount = variants.filter(v => {\n            const price = toNumber(v.price);\n            return price >= band.min && price < band.max;\n        }).length;\n\n        const sales = lineItems\n            .filter(li => {\n                const price = toNumber(li.price);\n                return price >= band.min && price < band.max;\n            })\n            .reduce((sum, li) => sum + li.quantity, 0);\n\n        return { ...band, productCount, sales };\n    });\n\n    // Detect gaps (low product count but adjacent bands have high sales)\n    for (let i = 0; i < bandData.length; i++) {\n        const current = bandData[i];\n        const prev = bandData[i - 1];\n        const next = bandData[i + 1];\n\n        const adjacentSales = (prev?.sales || 0) + (next?.sales || 0);\n\n        if (current.productCount < 5 && adjacentSales > 50) {\n            const gapScore = Math.min(1, (adjacentSales / 100) * (1 - current.productCount / 10));\n\n            if (gapScore > 0.3) {\n                const avgAdjacentRevenue = adjacentSales * ((current.min + (current.max === Infinity ? current.min * 1.5 : current.max)) / 2);\n\n                gaps.push({\n                    gapType: 'price_gap',\n                    gapScore: Math.round(gapScore * 100) / 100,\n                    gapData: {\n                        band: current.name,\n                        priceRange: { min: current.min, max: current.max === Infinity ? 500 : current.max },\n                        currentProducts: current.productCount,\n                        adjacentDemand: adjacentSales,\n                    },\n                    description: `Price Void Detected: ${current.name} range`,\n                    suggestedAction: `Expand catalog into the ${current.name} band. Regional demand is high with ${adjacentSales} units sold in adjacent price points.`,\n                    potentialRevenue: Math.round(avgAdjacentRevenue * 0.3),\n                    confidence: Math.min(0.9, gapScore + 0.2),\n                });\n            }\n        }\n    }\n\n    return gaps;\n}\n\n/**\n * 3.2 Category Adjacency Gaps\n * Identifies missing complementary product categories\n */\nexport async function detectCategoryGaps(shopId: string): Promise<GapResult[]> {\n    const gaps: GapResult[] = [];\n\n    // Define category adjacencies (what should exist together)\n    const categoryAdjacencies: Record<string, string[]> = {\n        'Shoes': ['Socks', 'Shoe Care', 'Insoles', 'Laces'],\n        'Dresses': ['Accessories', 'Jewelry', 'Bags', 'Belts'],\n        'Coffee': ['Mugs', 'Coffee Accessories', 'Filters'],\n        'Electronics': ['Cables', 'Cases', 'Accessories'],\n        'Clothing': ['Accessories', 'Bags', 'Jewelry'],\n        'Skincare': ['Tools', 'Accessories', 'Travel Size'],\n        'Furniture': ['Accessories', 'Decor', 'Lighting'],\n    };\n\n    // Get existing product types\n    const products = await prisma.product.findMany({\n        where: { shopId },\n        select: { productType: true },\n    });\n    const existingTypes = new Set(products.map(p => p.productType?.toLowerCase() || ''));\n\n    // Get revenue by type\n    const lineItems = await prisma.orderLineItem.findMany({\n        where: { order: { shopId } },\n        include: { order: { select: { createdAt: true } } },\n    });\n\n    const productTypeMap = new Map(products.map(p => [p.productType, p.productType]));\n\n    // Check for missing adjacencies\n    for (const [mainCategory, adjacentCategories] of Object.entries(categoryAdjacencies)) {\n        // Check if main category exists\n        const hasMainCategory = Array.from(existingTypes).some(t =>\n            t.includes(mainCategory.toLowerCase())\n        );\n\n        if (hasMainCategory) {\n            // Check for missing adjacent categories\n            for (const adjacent of adjacentCategories) {\n                const hasAdjacent = Array.from(existingTypes).some(t =>\n                    t.includes(adjacent.toLowerCase())\n                );\n\n                if (!hasAdjacent) {\n                    gaps.push({\n                        gapType: 'category_gap',\n                        gapScore: 0.6,\n                        gapData: {\n                            mainCategory,\n                            missingCategory: adjacent,\n                            reason: `Customers buying ${mainCategory} often want ${adjacent}`,\n                        },\n                        description: `Category Inconsistency: Missing ${adjacent}`,\n                        suggestedAction: `Consider adding ${adjacent} products to complement your existing ${mainCategory} collection. High catalog affinity detected.`,\n                        potentialRevenue: null,\n                        confidence: 0.7,\n                    });\n                }\n            }\n        }\n    }\n\n    return gaps;\n}\n\n/**\n * 3.3 Variant Coverage Gaps\n * Detects underrepresented winning attributes (colors, sizes)\n */\nexport async function detectVariantGaps(shopId: string): Promise<GapResult[]> {\n    const gaps: GapResult[] = [];\n\n    // Get all variants with sales\n    const variants = await prisma.variant.findMany({\n        where: { product: { shopId } },\n        select: {\n            id: true,\n            shopifyId: true,\n            title: true,\n            product: { select: { title: true, productType: true } }\n        },\n    });\n\n    // Get sales by variant\n    const lineItems = await prisma.orderLineItem.findMany({\n        where: { order: { shopId } },\n        select: { variantId: true, quantity: true },\n    });\n\n    const salesByVariant = new Map<string, number>();\n    for (const li of lineItems) {\n        if (li.variantId) {\n            salesByVariant.set(li.variantId, (salesByVariant.get(li.variantId) || 0) + li.quantity);\n        }\n    }\n\n    // Extract common attributes from variant titles\n    const colorKeywords = ['black', 'white', 'red', 'blue', 'green', 'pink', 'grey', 'brown', 'navy', 'beige'];\n    const sizeKeywords = ['xs', 's', 'm', 'l', 'xl', 'xxl', 'small', 'medium', 'large'];\n\n    // Count sales by color\n    const salesByColor: Record<string, number> = {};\n    const productsByColor: Record<string, number> = {};\n\n    for (const variant of variants) {\n        const titleLower = variant.title.toLowerCase();\n        for (const color of colorKeywords) {\n            if (titleLower.includes(color)) {\n                const sales = salesByVariant.get(variant.shopifyId) || 0;\n                salesByColor[color] = (salesByColor[color] || 0) + sales;\n                productsByColor[color] = (productsByColor[color] || 0) + 1;\n            }\n        }\n    }\n\n    // Find high-selling colors with low product representation\n    const totalProducts = variants.length;\n    for (const [color, sales] of Object.entries(salesByColor)) {\n        const productCount = productsByColor[color] || 0;\n        const productShare = productCount / totalProducts;\n        const salesShare = sales / lineItems.reduce((sum, li) => sum + li.quantity, 0);\n\n        // High demand (sales share) but low supply (product share)\n        if (salesShare > productShare * 1.5 && productCount < 10) {\n            gaps.push({\n                gapType: 'variant_gap',\n                gapScore: Math.round((salesShare - productShare) * 100) / 100,\n                gapData: {\n                    attribute: 'color',\n                    value: color.charAt(0).toUpperCase() + color.slice(1),\n                    currentProducts: productCount,\n                    salesShare: Math.round(salesShare * 10000) / 100,\n                    productShare: Math.round(productShare * 10000) / 100,\n                },\n                description: `Variant Depletion: ${color.charAt(0).toUpperCase() + color.slice(1)} shortage`,\n                suggestedAction: `Increase depth in ${color} variants. This attribute accounts for ${Math.round(salesShare * 100)}% of volume but only ${Math.round(productShare * 100)}% of your assortment.`,\n                potentialRevenue: null,\n                confidence: 0.75,\n            });\n        }\n    }\n\n    return gaps;\n}\n\n/**\n * 3.4 Seasonal Gaps\n * Identifies months with low revenue that could use seasonal products\n */\nexport async function detectSeasonalGaps(shopId: string): Promise<GapResult[]> {\n    const gaps: GapResult[] = [];\n    const monthNames = ['January', 'February', 'March', 'April', 'May', 'June',\n        'July', 'August', 'September', 'October', 'November', 'December'];\n\n    // Get orders by month\n    const orders = await prisma.order.findMany({\n        where: { shopId },\n        select: { createdAt: true, totalPrice: true },\n    });\n\n    // Group by month\n    const revenueByMonth: Record<number, number> = {};\n    for (let i = 0; i < 12; i++) revenueByMonth[i] = 0;\n\n    for (const order of orders) {\n        const month = order.createdAt.getMonth();\n        revenueByMonth[month] += toNumber(order.totalPrice);\n    }\n\n    const avgMonthlyRevenue = Object.values(revenueByMonth).reduce((a, b) => a + b, 0) / 12;\n\n    // Find low-revenue months\n    for (const [month, revenue] of Object.entries(revenueByMonth)) {\n        const monthIndex = parseInt(month);\n        const revenueIndex = avgMonthlyRevenue > 0 ? revenue / avgMonthlyRevenue : 0;\n\n        if (revenueIndex < 0.7 && avgMonthlyRevenue > 0) {\n            const seasonalSuggestions: Record<number, string> = {\n                0: 'New Year, Winter Sales',\n                1: \"Valentine's Day\",\n                2: 'Spring Collection, Easter prep',\n                3: 'Easter, Spring cleaning',\n                4: \"Mother's Day, Spring items\",\n                5: \"Father's Day, Summer prep\",\n                6: 'Summer Sale, Beach items',\n                7: 'Back to School prep',\n                8: 'Back to School, Fall collection',\n                9: 'Halloween, Fall items',\n                10: 'Black Friday, Holiday prep',\n                11: 'Christmas, Holiday gifts',\n            };\n\n            gaps.push({\n                gapType: 'seasonal_gap',\n                gapScore: Math.round((1 - revenueIndex) * 100) / 100,\n                gapData: {\n                    month: monthNames[monthIndex],\n                    monthIndex,\n                    currentRevenue: Math.round(revenue),\n                    averageRevenue: Math.round(avgMonthlyRevenue),\n                    revenueIndex: Math.round(revenueIndex * 100) / 100,\n                },\n                description: `Seasonal Exposure: ${monthNames[monthIndex]} dip`,\n                suggestedAction: `${monthNames[monthIndex]} performance is ${Math.round((1 - revenueIndex) * 100)}% below your annual baseline. Deploy ${seasonalSuggestions[monthIndex]} collections to bridge the gap.`,\n                potentialRevenue: Math.round((avgMonthlyRevenue - revenue) * 0.5),\n                confidence: 0.65,\n            });\n        }\n    }\n\n    return gaps;\n}\n\n/**\n * 3.5 Detect All Gaps - Main function\n */\nexport async function detectAllGaps(shopId: string): Promise<{\n    gaps: GapResult[];\n    summary: {\n        totalGaps: number;\n        byType: Record<string, number>;\n        topOpportunity: GapResult | null;\n    };\n}> {\n    console.log(`[GapDetector] Detecting gaps for shop: ${shopId}`);\n\n    // Run all detectors\n    const [priceGaps, categoryGaps, variantGaps, seasonalGaps] = await Promise.all([\n        detectPriceGaps(shopId),\n        detectCategoryGaps(shopId),\n        detectVariantGaps(shopId),\n        detectSeasonalGaps(shopId),\n    ]);\n\n    const allGaps = [...priceGaps, ...categoryGaps, ...variantGaps, ...seasonalGaps];\n\n    // Sort by score\n    allGaps.sort((a, b) => b.gapScore - a.gapScore);\n\n    // Save to database\n    for (const gap of allGaps) {\n        await prisma.catalogGap.upsert({\n            where: {\n                id: `${shopId}-${gap.gapType}-${JSON.stringify(gap.gapData).slice(0, 50)}`,\n            },\n            update: {\n                gapScore: gap.gapScore,\n                gapData: gap.gapData,\n                description: gap.description,\n                suggestedAction: gap.suggestedAction,\n                potentialRevenue: gap.potentialRevenue,\n                confidence: gap.confidence,\n                detectedAt: new Date(),\n            },\n            create: {\n                shopId,\n                gapType: gap.gapType,\n                gapScore: gap.gapScore,\n                gapData: gap.gapData,\n                description: gap.description,\n                suggestedAction: gap.suggestedAction,\n                potentialRevenue: gap.potentialRevenue,\n                confidence: gap.confidence,\n            },\n        });\n    }\n\n    // Build summary\n    const byType: Record<string, number> = {};\n    for (const gap of allGaps) {\n        byType[gap.gapType] = (byType[gap.gapType] || 0) + 1;\n    }\n\n    console.log(`[GapDetector] Found ${allGaps.length} gaps`);\n\n    return {\n        gaps: allGaps,\n        summary: {\n            totalGaps: allGaps.length,\n            byType,\n            topOpportunity: allGaps[0] || null,\n        },\n    };\n}\n"],"names":[],"mappings":"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"}},
    {"offset": {"line": 1065, "column": 0}, "map": {"version":3,"sources":["file:///Users/mac/Desktop/NEW/packages/brain/src/intelligence/trends.ts"],"sourcesContent":["/**\n * Trend Integration Service\n * Provides trend data for product categories\n *\n * Note: External Google Trends scraping is disabled (unreliable).\n * Instead, we use intelligent estimates and let AI provide market knowledge.\n */\n\nimport { prisma } from '@brandmind/shared';\n\n// ============================================\n// TYPES\n// ============================================\n\nexport interface TrendResult {\n    keyword: string;\n    trendScore: number;      // 0-100 interest level\n    velocity: number;        // week-over-week change %\n    acceleration: number;    // change in velocity\n    seasonalIndex: number;\n    source: string;\n}\n\n// ============================================\n// TREND ESTIMATION\n// ============================================\n\n/**\n * Generate trend estimates for a keyword\n * Uses keyword characteristics and category knowledge for reasonable estimates\n *\n * Note: For real-time trends, integrate SerpAPI or similar paid service\n */\nfunction generateTrendEstimate(keyword: string): TrendResult {\n    const lowerKeyword = keyword.toLowerCase();\n\n    // Fashion/apparel category knowledge\n    const trendingCategories: Record<string, { score: number; velocity: number }> = {\n        'harem': { score: 65, velocity: 8 },       // Steady interest\n        'palazzo': { score: 70, velocity: 12 },    // Growing trend\n        'yoga': { score: 75, velocity: 15 },       // Strong growth\n        'loungewear': { score: 80, velocity: 20 }, // Very popular post-pandemic\n        'sustainable': { score: 72, velocity: 18 },// Growing eco-consciousness\n        'bamboo': { score: 68, velocity: 14 },     // Eco-friendly materials trending\n        'linen': { score: 60, velocity: 5 },       // Seasonal (summer)\n        'warm': { score: 55, velocity: -5 },       // Seasonal decline (if not winter)\n        'kids': { score: 58, velocity: 6 },        // Stable\n        'rock': { score: 45, velocity: 3 },        // Niche but stable\n    };\n\n    // Check for matching categories\n    for (const [cat, data] of Object.entries(trendingCategories)) {\n        if (lowerKeyword.includes(cat)) {\n            return {\n                keyword,\n                trendScore: data.score,\n                velocity: data.velocity,\n                acceleration: 0,\n                seasonalIndex: getSeasonalIndex(lowerKeyword),\n                source: 'category_estimate',\n            };\n        }\n    }\n\n    // Default: generate consistent estimate based on keyword hash\n    const hash = keyword.split('').reduce((acc, char) => acc + char.charCodeAt(0), 0);\n    const baseScore = 40 + (hash % 30); // 40-70 range\n    const velocity = ((hash * 7) % 20) - 5; // -5 to +15 range\n\n    return {\n        keyword,\n        trendScore: baseScore,\n        velocity,\n        acceleration: 0,\n        seasonalIndex: 1.0,\n        source: 'keyword_estimate',\n    };\n}\n\n/**\n * Get seasonal index based on current month and product type\n */\nfunction getSeasonalIndex(keyword: string): number {\n    const month = new Date().getMonth(); // 0-11\n\n    // Summer items (May-August)\n    if (keyword.includes('linen') || keyword.includes('summer') || keyword.includes('light')) {\n        return month >= 4 && month <= 7 ? 1.3 : 0.7;\n    }\n\n    // Winter items (November-February)\n    if (keyword.includes('warm') || keyword.includes('winter') || keyword.includes('fleece')) {\n        return month >= 10 || month <= 1 ? 1.3 : 0.7;\n    }\n\n    // Loungewear - slight boost in fall/winter\n    if (keyword.includes('lounge')) {\n        return month >= 9 || month <= 2 ? 1.15 : 1.0;\n    }\n\n    return 1.0; // Default: no seasonal adjustment\n}\n\n// ============================================\n// CACHE LAYER\n// ============================================\n\n/**\n * Get trend data for a keyword (with caching)\n */\nexport async function getTrendData(keyword: string, region: string = 'US'): Promise<TrendResult> {\n    // Check cache first\n    const cached = await prisma.trendData.findUnique({\n        where: {\n            keyword_region_source: {\n                keyword,\n                region,\n                source: 'category_estimate',\n            },\n        },\n    });\n\n    // Return cached if not expired (cache for 7 days)\n    if (cached && cached.expiresAt > new Date()) {\n        return {\n            keyword: cached.keyword,\n            trendScore: cached.trendScore,\n            velocity: cached.velocity,\n            acceleration: cached.acceleration,\n            seasonalIndex: cached.seasonalIndex || 1.0,\n            source: cached.source,\n        };\n    }\n\n    // Generate fresh estimate\n    const fresh = generateTrendEstimate(keyword);\n\n    // Cache it (expires in 7 days)\n    const expiresAt = new Date();\n    expiresAt.setDate(expiresAt.getDate() + 7);\n\n    try {\n        await prisma.trendData.upsert({\n            where: {\n                keyword_region_source: {\n                    keyword,\n                    region,\n                    source: fresh.source,\n                },\n            },\n            update: {\n                trendScore: fresh.trendScore,\n                velocity: fresh.velocity,\n                acceleration: fresh.acceleration,\n                seasonalIndex: fresh.seasonalIndex,\n                fetchedAt: new Date(),\n                expiresAt,\n            },\n            create: {\n                keyword,\n                region,\n                source: fresh.source,\n                trendScore: fresh.trendScore,\n                velocity: fresh.velocity,\n                acceleration: fresh.acceleration,\n                seasonalIndex: fresh.seasonalIndex,\n                expiresAt,\n            },\n        });\n    } catch (e) {\n        // Cache failure shouldn't break the flow\n        console.warn(`[Trends] Failed to cache trend for ${keyword}`);\n    }\n\n    return fresh;\n}\n\n/**\n * Fetch trends for store's product categories\n */\nexport async function fetchTrendsForStore(shopId: string): Promise<TrendResult[]> {\n    // Get unique product types from store\n    const products = await prisma.product.findMany({\n        where: { shopId },\n        select: { productType: true },\n        distinct: ['productType'],\n    });\n\n    const keywords = products\n        .map(p => p.productType)\n        .filter((t): t is string => !!t && t.length > 2);\n\n    // Fetch trends for each keyword\n    const trends: TrendResult[] = [];\n    for (const keyword of keywords.slice(0, 20)) { // Limit to 20\n        try {\n            const trend = await getTrendData(keyword);\n            trends.push(trend);\n        } catch (err) {\n            console.error(`[Trends] Failed to fetch for ${keyword}:`, err);\n        }\n    }\n\n    return trends.sort((a, b) => b.trendScore - a.trendScore);\n}\n\n/**\n * Get top trending keywords for store\n */\nexport async function getTopTrends(shopId: string, limit: number = 10): Promise<TrendResult[]> {\n    const trends = await fetchTrendsForStore(shopId);\n    return trends\n        .filter(t => t.velocity > 0) // Only positive momentum\n        .slice(0, limit);\n}\n"],"names":[],"mappings":"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"}},
    {"offset": {"line": 1275, "column": 0}, "map": {"version":3,"sources":["file:///Users/mac/Desktop/NEW/packages/brain/src/intelligence/evidence.ts"],"sourcesContent":["/**\n * Evidence & Grounding System\n * Tracks data sources, builds reasoning chains, and guards against hallucination\n */\n\nimport { prisma } from '@brandmind/shared';\n\n// ============================================\n// TYPES\n// ============================================\n\nexport interface EvidenceItem {\n    claim: string;\n    source: string;\n    dataPoint: string | number;\n    timestamp: Date;\n    strength: 'strong' | 'moderate' | 'weak';\n}\n\nexport interface ReasoningChain {\n    conclusion: string;\n    evidence: EvidenceItem[];\n    confidence: number;\n    reasoning: string;\n}\n\nexport interface DataQuality {\n    shopId: string;\n    freshness: number;        // 0-1, days since last sync normalized\n    completeness: number;     // 0-1, % of required fields present\n    volume: number;           // 0-1, normalized data volume\n    overallScore: number;     // 0-100\n    issues: string[];\n}\n\n// ============================================\n// EVIDENCE COLLECTOR\n// ============================================\n\nexport class EvidenceCollector {\n    private evidence: EvidenceItem[] = [];\n    private shopId: string;\n\n    constructor(shopId: string) {\n        this.shopId = shopId;\n    }\n\n    addEvidence(claim: string, source: string, dataPoint: string | number, strength: 'strong' | 'moderate' | 'weak' = 'moderate') {\n        this.evidence.push({\n            claim,\n            source,\n            dataPoint,\n            timestamp: new Date(),\n            strength,\n        });\n    }\n\n    getEvidence(): EvidenceItem[] {\n        return this.evidence;\n    }\n\n    buildReasoningChain(conclusion: string, reasoning: string): ReasoningChain {\n        // Calculate confidence based on evidence strength\n        const strengthWeights = { strong: 1, moderate: 0.7, weak: 0.4 };\n        const totalWeight = this.evidence.reduce((sum, e) => sum + strengthWeights[e.strength], 0);\n        const maxWeight = this.evidence.length;\n        const confidence = maxWeight > 0 ? Math.min(1, totalWeight / maxWeight) : 0;\n\n        return {\n            conclusion,\n            evidence: this.evidence,\n            confidence: Math.round(confidence * 100) / 100,\n            reasoning,\n        };\n    }\n}\n\n// ============================================\n// DATA QUALITY SCORER\n// ============================================\n\nexport async function calculateDataQuality(shopId: string): Promise<DataQuality> {\n    const issues: string[] = [];\n\n    // Check sync freshness\n    const syncStates = await prisma.syncState.findMany({\n        where: { shopId },\n        orderBy: { lastSyncedAt: 'desc' },\n    });\n\n    let freshness = 0;\n    if (syncStates.length > 0) {\n        const lastSync = syncStates[0].lastSyncedAt;\n        const daysSinceSync = (Date.now() - lastSync.getTime()) / (1000 * 60 * 60 * 24);\n        freshness = Math.max(0, 1 - daysSinceSync / 30); // Decays over 30 days\n\n        if (daysSinceSync > 7) {\n            issues.push(`Data is ${Math.round(daysSinceSync)} days old`);\n        }\n    } else {\n        issues.push('No sync history found');\n    }\n\n    // Check data completeness\n    const [products, orders, customers] = await Promise.all([\n        prisma.product.count({ where: { shopId } }),\n        prisma.order.count({ where: { shopId } }),\n        prisma.customer.count({ where: { shopId } }),\n    ]);\n\n    // Check orders with customer links\n    const ordersWithCustomers = await prisma.order.count({\n        where: { shopId, customerId: { not: null } },\n    });\n    const customerLinkRate = orders > 0 ? ordersWithCustomers / orders : 0;\n\n    // Check products with types\n    const productsWithTypes = await prisma.product.count({\n        where: { shopId, productType: { not: null } },\n    });\n    const productTypeRate = products > 0 ? productsWithTypes / products : 0;\n\n    const completeness = (customerLinkRate * 0.5 + productTypeRate * 0.5);\n\n    if (customerLinkRate < 0.5) {\n        issues.push(`Only ${Math.round(customerLinkRate * 100)}% of orders have customer data`);\n    }\n    if (productTypeRate < 0.8) {\n        issues.push(`Only ${Math.round(productTypeRate * 100)}% of products have types`);\n    }\n\n    // Check volume (normalized against minimums)\n    const volumeScore = Math.min(1, (\n        Math.min(1, products / 50) * 0.3 +\n        Math.min(1, orders / 100) * 0.5 +\n        Math.min(1, customers / 50) * 0.2\n    ));\n\n    if (orders < 50) {\n        issues.push(`Limited order history (${orders} orders)`);\n    }\n\n    // Overall score\n    const overallScore = Math.round((freshness * 30 + completeness * 40 + volumeScore * 30));\n\n    return {\n        shopId,\n        freshness: Math.round(freshness * 100) / 100,\n        completeness: Math.round(completeness * 100) / 100,\n        volume: Math.round(volumeScore * 100) / 100,\n        overallScore,\n        issues,\n    };\n}\n\n// ============================================\n// HALLUCINATION GUARD\n// ============================================\n\nexport async function validateClaim(\n    shopId: string,\n    claim: string,\n    type: 'product' | 'order' | 'customer' | 'metric'\n): Promise<{ valid: boolean; reason: string; suggestion?: string }> {\n    switch (type) {\n        case 'product':\n            // Check if referenced product exists\n            const productMatch = claim.match(/product[:\\s]*[\"']?([^\"']+)[\"']?/i);\n            if (productMatch) {\n                const product = await prisma.product.findFirst({\n                    where: { shopId, title: { contains: productMatch[1] } },\n                });\n                if (!product) {\n                    return {\n                        valid: false,\n                        reason: `Product \"${productMatch[1]}\" not found in database`,\n                        suggestion: 'Refer only to products that exist in the catalog',\n                    };\n                }\n            }\n            return { valid: true, reason: 'Product reference validated' };\n\n        case 'metric':\n            // Check if the metric makes sense\n            const numberMatch = claim.match(/(\\d+(?:\\.\\d+)?)\\s*%/);\n            if (numberMatch) {\n                const value = parseFloat(numberMatch[1]);\n                if (value > 100 || value < 0) {\n                    return {\n                        valid: false,\n                        reason: `Percentage value ${value}% is out of valid range`,\n                        suggestion: 'Percentages should be between 0-100%',\n                    };\n                }\n            }\n            return { valid: true, reason: 'Metric appears valid' };\n\n        default:\n            return { valid: true, reason: 'Claim type not specifically validated' };\n    }\n}\n\n// ============================================\n// CONFIDENCE CALCULATOR\n// ============================================\n\nexport async function calculateConfidence(\n    shopId: string,\n    sampleSize: number,\n    patternStrength: number // 0-1\n): Promise<{ confidence: number; explanation: string }> {\n    // Get data quality\n    const dataQuality = await calculateDataQuality(shopId);\n\n    // Base confidence from sample size (diminishing returns after 100)\n    const sampleConfidence = Math.min(1, Math.log10(sampleSize + 1) / 2);\n\n    // Combine all factors\n    const confidence = (\n        sampleConfidence * 0.3 +\n        patternStrength * 0.4 +\n        (dataQuality.overallScore / 100) * 0.3\n    );\n\n    let explanation = '';\n    if (confidence >= 0.8) {\n        explanation = 'High confidence based on strong patterns and sufficient data';\n    } else if (confidence >= 0.6) {\n        explanation = 'Moderate confidence - consider validating with additional data';\n    } else if (confidence >= 0.4) {\n        explanation = 'Low confidence - treat as hypothesis requiring validation';\n    } else {\n        explanation = 'Insufficient data for reliable conclusions';\n    }\n\n    return {\n        confidence: Math.round(confidence * 100) / 100,\n        explanation,\n    };\n}\n\n// ============================================\n// FALLBACK RESPONSE\n// ============================================\n\nexport function getInsufficientDataResponse(reason: string): {\n    type: 'insufficient_data';\n    message: string;\n    suggestions: string[];\n} {\n    const suggestions = [\n        'Sync more historical data from Shopify',\n        'Wait for more orders to accumulate',\n        'Ensure products have accurate types and categories',\n    ];\n\n    return {\n        type: 'insufficient_data',\n        message: `Unable to provide reliable analysis: ${reason}`,\n        suggestions,\n    };\n}\n"],"names":[],"mappings":"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"}},
    {"offset": {"line": 1651, "column": 0}, "map": {"version":3,"sources":["file:///Users/mac/Desktop/NEW/packages/brain/src/intelligence/public-analyzer.ts"],"sourcesContent":["import OpenAI from 'openai';\nimport * as cheerio from 'cheerio';\n\nexport interface PublicBrandAnalysis {\n    brandName: string;\n    description: string;\n    healthScore: number;\n    estimatedRevenue: string;\n    topOpportunities: string[];\n    riskSignals: string[];\n    modernityScore: number;\n}\n\nexport async function analyzePublicDomain(domain: string): Promise<PublicBrandAnalysis> {\n    const openai = new OpenAI({\n        apiKey: process.env.OPENAI_API_KEY,\n    });\n\n    console.log(`[PublicAnalyzer] Starting analysis for: ${domain}`);\n\n    // Ensure domain has protocol\n    const url = domain.startsWith('http') ? domain : `https://${domain}`;\n\n    try {\n        // 1. Scraping Layer\n        const response = await fetch(url, {\n            headers: {\n                'User-Agent': 'Mozilla/5.0 (Windows NT 10.0; Win64; x64) AppleWebKit/537.36 (KHTML, like Gecko) Chrome/120.0.0.0 Safari/537.36',\n            }\n        });\n\n        if (!response.ok) {\n            throw new Error(`Failed to access site: ${response.statusText}`);\n        }\n\n        const html = await response.text();\n        const $ = cheerio.load(html);\n\n        // Extract metadata and basic cues\n        const title = $('title').text() || domain;\n        const metaDesc = $('meta[name=\"description\"]').attr('content') || '';\n        const headings = $('h1, h2').map((_, el) => $(el).text()).get().slice(0, 5).join(', ');\n\n        // 2. Intelligence Layer\n        const prompt = `\n            You are BrandMindAI, an AI Executive Business Partner.\n            Analyze this public storefront data and provide a strategic executive preview.\n\n            Site Title: ${title}\n            Meta Description: ${metaDesc}\n            Key Content: ${headings}\n\n            The goal is to wow the merchant with your perception. \n            Identify their likely industry, current market positioning, and a \"Next Hit\" opportunity.\n\n            Output JSON format:\n            {\n                \"brandName\": \"string\",\n                \"description\": \"Short strategic summary (max 20 words)\",\n                \"healthScore\": number (1-100),\n                \"estimatedRevenue\": \"Estimate string like '$1M - $5M'\",\n                \"topOpportunities\": [\"Strategic growth lever 1\", \"Lever 2\"],\n                \"riskSignals\": [\"Signal 1\"],\n                \"modernityScore\": number (1-100)\n            }\n        `;\n\n        const aiResponse = await openai.chat.completions.create({\n            model: 'gpt-4o',\n            messages: [{ role: 'system', content: prompt }],\n            response_format: { type: 'json_object' },\n            temperature: 0.7,\n        });\n\n        const result = JSON.parse(aiResponse.choices[0].message.content || '{}');\n\n        return {\n            brandName: result.brandName || title,\n            description: result.description || 'Strategic profile identified.',\n            healthScore: result.healthScore || 75,\n            estimatedRevenue: result.estimatedRevenue || 'High Velocity',\n            topOpportunities: result.topOpportunities || ['Optimize catalog architecture'],\n            riskSignals: result.riskSignals || ['Market saturation trends'],\n            modernityScore: result.modernityScore || 80\n        };\n\n    } catch (error: any) {\n        console.error(`[PublicAnalyzer] Error: ${error.message}`);\n        throw new Error(`Could not analyze ${domain}. Ensure it is a public storefront.`);\n    }\n}\n"],"names":[],"mappings":";;;;AAAA;AAAA;AACA;AAAA;;;AAYO,eAAe,oBAAoB,MAAc;IACpD,MAAM,SAAS,IAAI,iLAAM,CAAC;QACtB,QAAQ,QAAQ,GAAG,CAAC,cAAc;IACtC;IAEA,QAAQ,GAAG,CAAC,CAAC,wCAAwC,EAAE,QAAQ;IAE/D,6BAA6B;IAC7B,MAAM,MAAM,OAAO,UAAU,CAAC,UAAU,SAAS,CAAC,QAAQ,EAAE,QAAQ;IAEpE,IAAI;QACA,oBAAoB;QACpB,MAAM,WAAW,MAAM,MAAM,KAAK;YAC9B,SAAS;gBACL,cAAc;YAClB;QACJ;QAEA,IAAI,CAAC,SAAS,EAAE,EAAE;YACd,MAAM,IAAI,MAAM,CAAC,uBAAuB,EAAE,SAAS,UAAU,EAAE;QACnE;QAEA,MAAM,OAAO,MAAM,SAAS,IAAI;QAChC,MAAM,IAAI,+JAAY,CAAC;QAEvB,kCAAkC;QAClC,MAAM,QAAQ,EAAE,SAAS,IAAI,MAAM;QACnC,MAAM,WAAW,EAAE,4BAA4B,IAAI,CAAC,cAAc;QAClE,MAAM,WAAW,EAAE,UAAU,GAAG,CAAC,CAAC,GAAG,KAAO,EAAE,IAAI,IAAI,IAAI,GAAG,GAAG,KAAK,CAAC,GAAG,GAAG,IAAI,CAAC;QAEjF,wBAAwB;QACxB,MAAM,SAAS,CAAC;;;;wBAIA,EAAE,MAAM;8BACF,EAAE,SAAS;yBAChB,EAAE,SAAS;;;;;;;;;;;;;;;QAe5B,CAAC;QAED,MAAM,aAAa,MAAM,OAAO,IAAI,CAAC,WAAW,CAAC,MAAM,CAAC;YACpD,OAAO;YACP,UAAU;gBAAC;oBAAE,MAAM;oBAAU,SAAS;gBAAO;aAAE;YAC/C,iBAAiB;gBAAE,MAAM;YAAc;YACvC,aAAa;QACjB;QAEA,MAAM,SAAS,KAAK,KAAK,CAAC,WAAW,OAAO,CAAC,EAAE,CAAC,OAAO,CAAC,OAAO,IAAI;QAEnE,OAAO;YACH,WAAW,OAAO,SAAS,IAAI;YAC/B,aAAa,OAAO,WAAW,IAAI;YACnC,aAAa,OAAO,WAAW,IAAI;YACnC,kBAAkB,OAAO,gBAAgB,IAAI;YAC7C,kBAAkB,OAAO,gBAAgB,IAAI;gBAAC;aAAgC;YAC9E,aAAa,OAAO,WAAW,IAAI;gBAAC;aAA2B;YAC/D,gBAAgB,OAAO,cAAc,IAAI;QAC7C;IAEJ,EAAE,OAAO,OAAY;QACjB,QAAQ,KAAK,CAAC,CAAC,wBAAwB,EAAE,MAAM,OAAO,EAAE;QACxD,MAAM,IAAI,MAAM,CAAC,kBAAkB,EAAE,OAAO,mCAAmC,CAAC;IACpF;AACJ"}},
    {"offset": {"line": 1743, "column": 0}, "map": {"version":3,"sources":["file:///Users/mac/Desktop/NEW/packages/brain/src/intelligence/product-research.ts"],"sourcesContent":["/**\n * AI Product Research Module\n *\n * Uses AI to research external market trends and suggest NEW product opportunities\n * that don't exist in the store's catalog yet.\n */\n\nimport { prisma } from '@brandmind/shared';\nimport OpenAI from 'openai';\nimport { getTrendData } from './trends';\n\n// ============================================\n// TYPES\n// ============================================\n\nexport interface StoreContext {\n    shopId: string;\n    shopDomain: string;\n    primaryCategories: string[];\n    topColors: string[];\n    priceSweetSpot: { min: number; max: number };\n    brandStyle: string;\n    existingProductTitles: string[];\n}\n\nexport interface ProductResearchResult {\n    productIdea: string;\n    productType: string;\n    targetPrice: number;\n    marketEvidence: {\n        trendScore: number;\n        searchVolume: string;\n        competitorGap: string;\n        seasonalRelevance: string;\n    };\n    reasoning: string;\n    differentiators: string[];\n    riskLevel: 'low' | 'medium' | 'high';\n    confidence: number;\n    source: 'ai_research';\n}\n\nexport interface ResearchPromptContext {\n    categories: string[];\n    topColors: string[];\n    priceRange: string;\n    existingProducts: string[];\n    brandDescription: string;\n}\n\n// ============================================\n// MAIN RESEARCH FUNCTION\n// ============================================\n\nexport async function researchNewProducts(shopId: string): Promise<ProductResearchResult[]> {\n    console.log(`[ProductResearch] Starting AI research for shop ${shopId}`);\n\n    // 1. Build store context\n    const context = await buildStoreContext(shopId);\n    if (!context) {\n        console.log('[ProductResearch] Could not build store context');\n        return [];\n    }\n\n    // 2. Get trend data for primary categories\n    const trendInsights = await gatherTrendInsights(context.primaryCategories);\n\n    // 3. Call AI to research and suggest products\n    const aiSuggestions = await callAIForProductResearch(context, trendInsights);\n\n    // 4. Validate and score suggestions\n    const validatedResults = await validateAndScoreSuggestions(aiSuggestions, context);\n\n    console.log(`[ProductResearch] Generated ${validatedResults.length} AI-researched product ideas`);\n\n    return validatedResults;\n}\n\n// ============================================\n// CONTEXT BUILDING\n// ============================================\n\nasync function buildStoreContext(shopId: string): Promise<StoreContext | null> {\n    const shop = await prisma.shop.findUnique({\n        where: { id: shopId },\n        include: {\n            products: {\n                select: { title: true, productType: true },\n                take: 100,\n            },\n        },\n    });\n\n    if (!shop) return null;\n\n    const storeDNA = await prisma.storeDNA.findUnique({ where: { shopId } });\n    const dnaData = storeDNA as any;\n\n    const patterns = await prisma.patternMemory.findMany({ where: { shopId } });\n    const colorPattern = patterns.find(p => p.patternType === 'color_preference');\n    const pricePattern = patterns.find(p => p.patternType === 'price_band');\n\n    // Extract top categories\n    const primaryCategories = (dnaData?.topPerformingTypes || [])\n        .slice(0, 5)\n        .map((t: any) => t.type);\n\n    // Extract top colors\n    const topColors = ((colorPattern?.patternData as any)?.winners || [])\n        .slice(0, 5)\n        .map((c: any) => c.value);\n\n    // Extract price sweet spot\n    const optimalBand = (pricePattern?.patternData as any)?.optimalBand || 'value';\n    const priceRanges: Record<string, { min: number; max: number }> = {\n        'budget': { min: 15, max: 30 },\n        'value': { min: 30, max: 60 },\n        'mid': { min: 60, max: 100 },\n        'premium': { min: 100, max: 200 },\n        'luxury': { min: 200, max: 400 },\n    };\n    const priceSweetSpot = priceRanges[optimalBand] || priceRanges['value'];\n\n    // Get brand voice for style context\n    const brandVoice = await prisma.brandVoice.findUnique({ where: { shopId } });\n    const brandStyle = brandVoice?.toneAttributes?.join(', ') || 'comfortable, stylish, unique';\n\n    // Get existing product titles to avoid suggesting duplicates\n    const existingProductTitles = shop.products.map(p => p.title);\n\n    return {\n        shopId,\n        shopDomain: shop.shopDomain,\n        primaryCategories,\n        topColors,\n        priceSweetSpot,\n        brandStyle,\n        existingProductTitles,\n    };\n}\n\n// ============================================\n// TREND GATHERING\n// ============================================\n\nasync function gatherTrendInsights(categories: string[]): Promise<Record<string, any>> {\n    const insights: Record<string, any> = {};\n\n    for (const category of categories.slice(0, 3)) {\n        try {\n            const trendData = await getTrendData(category, 'DE'); // German market\n            if (trendData && trendData.trendScore > 0) {\n                // Determine direction based on velocity\n                const direction = trendData.velocity > 5 ? 'rising' :\n                    trendData.velocity < -5 ? 'declining' : 'stable';\n\n                insights[category] = {\n                    trendScore: trendData.trendScore,\n                    velocity: trendData.velocity,\n                    direction,\n                    seasonalIndex: trendData.seasonalIndex,\n                    source: trendData.source,\n                };\n            }\n        } catch (e) {\n            // Trends are supplementary - don't fail the whole research\n            console.log(`[ProductResearch] Could not get trends for ${category}, continuing without`);\n        }\n    }\n\n    // If no trend data available, provide context to AI\n    if (Object.keys(insights).length === 0) {\n        console.log('[ProductResearch] No trend data available, AI will use general market knowledge');\n    }\n\n    return insights;\n}\n\n// ============================================\n// AI RESEARCH CALL\n// ============================================\n\nasync function callAIForProductResearch(\n    context: StoreContext,\n    trendInsights: Record<string, any>\n): Promise<any[]> {\n    const openai = new OpenAI();\n\n    const prompt = buildResearchPrompt(context, trendInsights);\n\n    try {\n        const response = await openai.chat.completions.create({\n            model: 'gpt-4o',\n            messages: [\n                {\n                    role: 'system',\n                    content: `You are a product research specialist for e-commerce fashion brands. Your job is to identify NEW product opportunities based on market trends, competitor analysis, and the store's existing strengths.\n\nYou must suggest SPECIFIC, ACTIONABLE product ideas - not vague categories. Each suggestion should be a product that could realistically be manufactured and sold.\n\nFocus on:\n1. Products that leverage the store's existing strengths (colors, price points, style)\n2. Gap opportunities - products competitors have but this store doesn't\n3. Emerging trends in the fashion/apparel space\n4. Seasonal opportunities\n5. Cross-category expansion that makes sense for the brand\n\nBe specific: Instead of \"comfortable pants\", say \"Bamboo Fabric Yoga Harem Pants with Elastic Waistband\".`\n                },\n                {\n                    role: 'user',\n                    content: prompt\n                }\n            ],\n            response_format: { type: 'json_object' },\n            temperature: 0.8,\n            max_tokens: 2000,\n        });\n\n        const content = response.choices[0].message.content || '{}';\n        const parsed = JSON.parse(content);\n\n        return parsed.suggestions || [];\n    } catch (error) {\n        console.error('[ProductResearch] AI call failed:', error);\n        return [];\n    }\n}\n\nfunction buildResearchPrompt(\n    context: StoreContext,\n    trendInsights: Record<string, any>\n): string {\n    const existingProductsSample = context.existingProductTitles.slice(0, 20).join('\\n- ');\n    const trendSummary = Object.keys(trendInsights).length > 0\n        ? Object.entries(trendInsights)\n            .map(([cat, data]) => `${cat}: trend score ${data.trendScore}/100, velocity ${data.velocity > 0 ? '+' : ''}${data.velocity}%, direction: ${data.direction}`)\n            .join('\\n')\n        : 'External trend data unavailable - use your knowledge of current fashion/apparel market trends';\n\n    return `Research NEW product opportunities for this e-commerce store:\n\n## STORE PROFILE\n- Domain: ${context.shopDomain}\n- Primary Categories: ${context.primaryCategories.join(', ')}\n- Best-Selling Colors: ${context.topColors.join(', ')}\n- Price Sweet Spot: €${context.priceSweetSpot.min}-${context.priceSweetSpot.max}\n- Brand Style: ${context.brandStyle}\n\n## EXISTING PRODUCTS (sample - DO NOT suggest these)\n- ${existingProductsSample}\n\n## CURRENT MARKET TRENDS\n${trendSummary || 'No trend data available'}\n\n## YOUR TASK\nSuggest 5 SPECIFIC new product ideas that:\n1. Don't exist in the store yet\n2. Fit the brand's style and price range\n3. Leverage winning colors (${context.topColors.slice(0, 3).join(', ')})\n4. Address market gaps or trends\n5. Are realistic to manufacture and sell\n\nReturn JSON with this structure:\n{\n  \"suggestions\": [\n    {\n      \"productIdea\": \"Specific product name (e.g., 'Bamboo Yoga Harem Pants with Mandala Print')\",\n      \"productType\": \"Category (e.g., 'Haremshosen')\",\n      \"suggestedPrice\": 45,\n      \"marketEvidence\": {\n        \"trendIndicator\": \"Description of why this is trending\",\n        \"competitorInsight\": \"What competitors are doing in this space\",\n        \"searchDemand\": \"Estimated demand level (high/medium/low)\",\n        \"seasonalFit\": \"When this would sell best\"\n      },\n      \"reasoning\": \"2-3 sentences explaining why this is a good opportunity\",\n      \"differentiators\": [\"Feature 1\", \"Feature 2\", \"Feature 3\"],\n      \"riskLevel\": \"low|medium|high\"\n    }\n  ]\n}`;\n}\n\n// ============================================\n// VALIDATION & SCORING\n// ============================================\n\nasync function validateAndScoreSuggestions(\n    aiSuggestions: any[],\n    context: StoreContext\n): Promise<ProductResearchResult[]> {\n    const results: ProductResearchResult[] = [];\n\n    for (const suggestion of aiSuggestions) {\n        // Skip if too similar to existing product\n        const isDuplicate = context.existingProductTitles.some(existing =>\n            calculateSimilarity(existing.toLowerCase(), suggestion.productIdea?.toLowerCase() || '') > 0.7\n        );\n\n        if (isDuplicate) {\n            console.log(`[ProductResearch] Skipping duplicate: ${suggestion.productIdea}`);\n            continue;\n        }\n\n        // Calculate confidence score\n        let confidence = 0.6; // Base confidence\n\n        // Boost if uses winning color\n        const usesWinningColor = context.topColors.some(color =>\n            suggestion.productIdea?.toLowerCase().includes(color.toLowerCase())\n        );\n        if (usesWinningColor) confidence += 0.1;\n\n        // Boost if in primary category\n        const inPrimaryCategory = context.primaryCategories.some(cat =>\n            suggestion.productType?.toLowerCase().includes(cat.toLowerCase()) ||\n            cat.toLowerCase().includes(suggestion.productType?.toLowerCase() || '')\n        );\n        if (inPrimaryCategory) confidence += 0.1;\n\n        // Boost based on market evidence quality\n        if (suggestion.marketEvidence?.searchDemand === 'high') confidence += 0.1;\n        if (suggestion.riskLevel === 'low') confidence += 0.05;\n\n        // Map to result structure\n        results.push({\n            productIdea: suggestion.productIdea || 'Unknown Product',\n            productType: suggestion.productType || 'General',\n            targetPrice: suggestion.suggestedPrice || context.priceSweetSpot.min,\n            marketEvidence: {\n                trendScore: suggestion.marketEvidence?.searchDemand === 'high' ? 0.8 :\n                    suggestion.marketEvidence?.searchDemand === 'medium' ? 0.5 : 0.3,\n                searchVolume: suggestion.marketEvidence?.searchDemand || 'unknown',\n                competitorGap: suggestion.marketEvidence?.competitorInsight || 'No data',\n                seasonalRelevance: suggestion.marketEvidence?.seasonalFit || 'Year-round',\n            },\n            reasoning: suggestion.reasoning || 'AI-generated product suggestion',\n            differentiators: suggestion.differentiators || [],\n            riskLevel: suggestion.riskLevel || 'medium',\n            confidence: Math.min(0.95, confidence),\n            source: 'ai_research',\n        });\n    }\n\n    // Sort by confidence\n    results.sort((a, b) => b.confidence - a.confidence);\n\n    return results.slice(0, 5); // Return top 5\n}\n\n/**\n * Simple similarity check using word overlap\n */\nfunction calculateSimilarity(str1: string, str2: string): number {\n    const words1 = new Set(str1.split(/\\s+/).filter(w => w.length > 3));\n    const words2 = new Set(str2.split(/\\s+/).filter(w => w.length > 3));\n\n    if (words1.size === 0 || words2.size === 0) return 0;\n\n    const intersection = [...words1].filter(w => words2.has(w)).length;\n    const union = new Set([...words1, ...words2]).size;\n\n    return intersection / union;\n}\n\n// ============================================\n// EXPORT FOR INDEX\n// ============================================\n\nexport { researchNewProducts as runProductResearch };\n"],"names":[],"mappings":"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"}},
    {"offset": {"line": 2044, "column": 0}, "map": {"version":3,"sources":["file:///Users/mac/Desktop/NEW/packages/brain/src/intelligence/data-sufficiency.ts"],"sourcesContent":["/**\n * Data Sufficiency Checker\n * Validates whether a store has enough data for various features\n */\n\nimport { prisma } from '@brandmind/shared';\nimport { Prisma } from '@prisma/client';\n\n// ============================================\n// TYPES\n// ============================================\n\nexport interface DataBlocker {\n    feature: string;\n    requirement: string;\n    current: string;\n    needed: string;\n    message: string;\n    estimatedReadyDate?: Date;\n}\n\nexport interface DataWarning {\n    feature: string;\n    message: string;\n    impact: string;\n}\n\nexport interface DataEstimate {\n    feature: string;\n    currentProgress: number;\n    estimatedDaysUntilReady: number;\n    message: string;\n}\n\nexport interface SufficiencyResult {\n    sufficient: boolean;\n    score: number;\n    blockers: DataBlocker[];\n    warnings: DataWarning[];\n    estimates: DataEstimate[];\n    stats: {\n        orderCount: number;\n        productCount: number;\n        customerCount: number;\n        storeAgeDays: number;\n        dataSpanDays: number;\n        multiItemOrderCount: number;\n        categoryCount: number;\n        repeatCustomerCount: number;\n    };\n}\n\n// ============================================\n// THRESHOLDS\n// ============================================\n\nconst THRESHOLDS = {\n    storeAge: {\n        minimum: 7,\n        recommended: 30,\n    },\n    orders: {\n        minimum: 1,\n        forPredictions: 20,\n        forCategoryExpansion: 50,\n        forSeasonality: 100,\n    },\n    products: {\n        minimum: 5,\n        recommended: 20,\n    },\n    customers: {\n        minimum: 15,\n        forSegmentation: 50,\n        forRepeatAnalysis: 100,\n    },\n    multiItemOrders: {\n        forBasketAffinity: 30,\n    },\n    monthsOfData: {\n        forSeasonality: 6,\n    },\n    repeatCustomers: {\n        minimum: 10,\n    },\n};\n\n// ============================================\n// MAIN FUNCTION\n// ============================================\n\nexport async function checkDataSufficiency(shopId: string): Promise<SufficiencyResult> {\n    const blockers: DataBlocker[] = [];\n    const warnings: DataWarning[] = [];\n    const estimates: DataEstimate[] = [];\n\n    // ═══════════════════════════════════════════════════════════════\n    // GATHER CURRENT DATA STATS\n    // ═══════════════════════════════════════════════════════════════\n    const [orderStats, productStats, customerStats] = await Promise.all([\n        prisma.order.aggregate({\n            where: { shopId },\n            _count: true,\n            _min: { createdAt: true },\n            _max: { createdAt: true },\n        }),\n        prisma.product.aggregate({\n            where: { shopId },\n            _count: true,\n        }),\n        prisma.customer.aggregate({\n            where: { shopId },\n            _count: true,\n        }),\n    ]);\n\n    const orderCount = orderStats._count;\n    const productCount = productStats._count;\n    const customerCount = customerStats._count;\n\n    const firstOrderDate = orderStats._min.createdAt;\n    const lastOrderDate = orderStats._max.createdAt;\n\n    const storeAgeDays = firstOrderDate\n        ? Math.floor((Date.now() - firstOrderDate.getTime()) / (1000 * 60 * 60 * 24))\n        : 0;\n\n    const dataSpanDays = firstOrderDate && lastOrderDate\n        ? Math.floor((lastOrderDate.getTime() - firstOrderDate.getTime()) / (1000 * 60 * 60 * 24))\n        : 0;\n\n    // Get multi-item orders count\n    const ordersWithMultipleItems = await prisma.order.findMany({\n        where: { shopId },\n        select: { id: true, _count: { select: { lineItems: true } } },\n    });\n    const multiItemOrderCount = ordersWithMultipleItems.filter(o => o._count.lineItems > 1).length;\n\n    // Get distinct categories\n    const categories = await prisma.product.groupBy({\n        by: ['productType'],\n        where: { shopId, productType: { not: null } },\n    });\n    const categoryCount = categories.length;\n\n    // Get repeat customers count\n    let repeatCustomerCount = 0;\n    try {\n        const repeatCustomers = await prisma.$queryRaw`\n            SELECT COUNT(DISTINCT \"customerId\") as count\n            FROM \"Order\"\n            WHERE \"shopId\" = ${shopId}\n              AND \"customerId\" IS NOT NULL\n            GROUP BY \"customerId\"\n            HAVING COUNT(*) > 1\n        ` as any[];\n        repeatCustomerCount = repeatCustomers.length;\n    } catch (e) {\n        // Query might fail if no orders exist\n        repeatCustomerCount = 0;\n    }\n\n    const stats = {\n        orderCount,\n        productCount,\n        customerCount,\n        storeAgeDays,\n        dataSpanDays,\n        multiItemOrderCount,\n        categoryCount,\n        repeatCustomerCount,\n    };\n\n    // ═══════════════════════════════════════════════════════════════\n    // CHECK GLOBAL MINIMUMS\n    // ═══════════════════════════════════════════════════════════════\n\n    // No orders at all\n    if (orderCount === 0) {\n        blockers.push({\n            feature: 'all',\n            requirement: 'At least 1 order required',\n            current: '0 orders',\n            needed: '1+ orders',\n            message: 'No orders found. Make your first sale to start building your Brand DNA.',\n        });\n    }\n\n    // Store too new\n    if (orderCount > 0 && storeAgeDays < THRESHOLDS.storeAge.minimum) {\n        blockers.push({\n            feature: 'all',\n            requirement: `Store must be at least ${THRESHOLDS.storeAge.minimum} days old`,\n            current: `${storeAgeDays} days`,\n            needed: `${THRESHOLDS.storeAge.minimum} days`,\n            message: `Your store data is only ${storeAgeDays} days old. We need at least ${THRESHOLDS.storeAge.minimum} days of sales data to begin analysis.`,\n            estimatedReadyDate: new Date(Date.now() + (THRESHOLDS.storeAge.minimum - storeAgeDays) * 24 * 60 * 60 * 1000),\n        });\n    }\n\n    // Too few products\n    if (productCount < THRESHOLDS.products.minimum) {\n        blockers.push({\n            feature: 'catalogAnalysis',\n            requirement: `Minimum ${THRESHOLDS.products.minimum} products`,\n            current: `${productCount} products`,\n            needed: `${THRESHOLDS.products.minimum} products`,\n            message: `Only ${productCount} products found. Add more products for meaningful catalog analysis.`,\n        });\n    }\n\n    // ═══════════════════════════════════════════════════════════════\n    // CHECK FEATURE-SPECIFIC THRESHOLDS\n    // ═══════════════════════════════════════════════════════════════\n\n    // NEXT HIT PREDICTIONS\n    if (orderCount > 0 && orderCount < THRESHOLDS.orders.forPredictions) {\n        blockers.push({\n            feature: 'nextHitPredictions',\n            requirement: `Minimum ${THRESHOLDS.orders.forPredictions} orders for predictions`,\n            current: `${orderCount} orders`,\n            needed: `${THRESHOLDS.orders.forPredictions} orders`,\n            message: `You have ${orderCount} orders. We need at least ${THRESHOLDS.orders.forPredictions} to identify reliable patterns for product predictions.`,\n            estimatedReadyDate: estimateWhenReady(orderCount, THRESHOLDS.orders.forPredictions, storeAgeDays),\n        });\n\n        estimates.push({\n            feature: 'nextHitPredictions',\n            currentProgress: Math.round((orderCount / THRESHOLDS.orders.forPredictions) * 100),\n            estimatedDaysUntilReady: estimateDaysUntilOrders(orderCount, THRESHOLDS.orders.forPredictions, storeAgeDays),\n            message: `${THRESHOLDS.orders.forPredictions - orderCount} more orders needed`,\n        });\n    }\n\n    if (orderCount >= THRESHOLDS.orders.forPredictions && storeAgeDays < THRESHOLDS.storeAge.recommended) {\n        warnings.push({\n            feature: 'nextHitPredictions',\n            message: `Only ${storeAgeDays} days of data (${THRESHOLDS.storeAge.recommended} recommended)`,\n            impact: 'Predictions may be less accurate with limited historical data',\n        });\n    }\n\n    // SEASONALITY ANALYSIS\n    const monthsOfData = Math.floor(dataSpanDays / 30);\n    if (monthsOfData < THRESHOLDS.monthsOfData.forSeasonality) {\n        blockers.push({\n            feature: 'seasonalityAnalysis',\n            requirement: `${THRESHOLDS.monthsOfData.forSeasonality} months of order data`,\n            current: `${monthsOfData} months`,\n            needed: `${THRESHOLDS.monthsOfData.forSeasonality} months`,\n            message: `Seasonality analysis requires ${THRESHOLDS.monthsOfData.forSeasonality}+ months of data. You have ${monthsOfData} months.`,\n            estimatedReadyDate: new Date(Date.now() + (THRESHOLDS.monthsOfData.forSeasonality - monthsOfData) * 30 * 24 * 60 * 60 * 1000),\n        });\n\n        estimates.push({\n            feature: 'seasonalityAnalysis',\n            currentProgress: Math.round((monthsOfData / THRESHOLDS.monthsOfData.forSeasonality) * 100),\n            estimatedDaysUntilReady: (THRESHOLDS.monthsOfData.forSeasonality - monthsOfData) * 30,\n            message: `${THRESHOLDS.monthsOfData.forSeasonality - monthsOfData} more months of data needed`,\n        });\n    }\n\n    // CUSTOMER SEGMENTATION (RFM)\n    if (customerCount < THRESHOLDS.customers.forSegmentation) {\n        blockers.push({\n            feature: 'customerSegmentation',\n            requirement: `${THRESHOLDS.customers.forSegmentation} customers minimum`,\n            current: `${customerCount} customers`,\n            needed: `${THRESHOLDS.customers.forSegmentation} customers`,\n            message: `Customer segmentation requires at least ${THRESHOLDS.customers.forSegmentation} unique customers.`,\n        });\n    } else if (repeatCustomerCount < THRESHOLDS.repeatCustomers.minimum) {\n        warnings.push({\n            feature: 'customerSegmentation',\n            message: `Only ${repeatCustomerCount} repeat customers (${THRESHOLDS.repeatCustomers.minimum} recommended)`,\n            impact: 'Repeat purchase patterns may not be statistically reliable',\n        });\n    }\n\n    // BASKET AFFINITY / CROSS-PURCHASE\n    if (multiItemOrderCount < THRESHOLDS.multiItemOrders.forBasketAffinity) {\n        blockers.push({\n            feature: 'basketAffinity',\n            requirement: `${THRESHOLDS.multiItemOrders.forBasketAffinity} multi-item orders`,\n            current: `${multiItemOrderCount} multi-item orders`,\n            needed: `${THRESHOLDS.multiItemOrders.forBasketAffinity} multi-item orders`,\n            message: 'Cross-purchase analysis needs orders with multiple products to identify buying patterns.',\n        });\n\n        estimates.push({\n            feature: 'basketAffinity',\n            currentProgress: Math.round((multiItemOrderCount / THRESHOLDS.multiItemOrders.forBasketAffinity) * 100),\n            estimatedDaysUntilReady: estimateDaysUntilOrders(multiItemOrderCount, THRESHOLDS.multiItemOrders.forBasketAffinity, storeAgeDays),\n            message: `${THRESHOLDS.multiItemOrders.forBasketAffinity - multiItemOrderCount} more multi-item orders needed`,\n        });\n    }\n\n    // CATEGORY EXPANSION\n    if (orderCount < THRESHOLDS.orders.forCategoryExpansion) {\n        blockers.push({\n            feature: 'categoryExpansion',\n            requirement: `${THRESHOLDS.orders.forCategoryExpansion} orders for category expansion`,\n            current: `${orderCount} orders`,\n            needed: `${THRESHOLDS.orders.forCategoryExpansion} orders`,\n            message: 'Category expansion recommendations require established sales patterns.',\n        });\n    }\n\n    if (categoryCount < 2) {\n        warnings.push({\n            feature: 'categoryExpansion',\n            message: `Only ${categoryCount} product category detected`,\n            impact: 'Category expansion suggestions will be based on market research only',\n        });\n    }\n\n    // ═══════════════════════════════════════════════════════════════\n    // CALCULATE OVERALL SCORE\n    // ═══════════════════════════════════════════════════════════════\n    const criticalBlockers = blockers.filter(b => b.feature === 'all' || b.feature === 'nextHitPredictions');\n    const sufficient = criticalBlockers.length === 0;\n\n    // Score based on how much data we have vs ideal\n    const orderScore = Math.min(100, (orderCount / 100) * 100);\n    const ageScore = Math.min(100, (storeAgeDays / 90) * 100);\n    const productScore = Math.min(100, (productCount / 20) * 100);\n    const customerScore = Math.min(100, (customerCount / 50) * 100);\n\n    const score = Math.round((orderScore + ageScore + productScore + customerScore) / 4);\n\n    // ═══════════════════════════════════════════════════════════════\n    // SAVE TO DATABASE\n    // ═══════════════════════════════════════════════════════════════\n    await prisma.dataSufficiency.upsert({\n        where: { shopId },\n        update: {\n            orderCount,\n            productCount,\n            customerCount,\n            storeAgeDays,\n            dataSpanDays,\n            multiItemOrderCount,\n            categoryCount,\n            repeatCustomerCount,\n            overallScore: score,\n            isSufficient: sufficient,\n            nextHitReady: !blockers.some(b => b.feature === 'nextHitPredictions' || b.feature === 'all'),\n            seasonalityReady: !blockers.some(b => b.feature === 'seasonalityAnalysis'),\n            customerSegmentReady: !blockers.some(b => b.feature === 'customerSegmentation'),\n            basketAffinityReady: !blockers.some(b => b.feature === 'basketAffinity'),\n            categoryExpansionReady: !blockers.some(b => b.feature === 'categoryExpansion'),\n            blockers: blockers as unknown as Prisma.InputJsonValue,\n            warnings: warnings as unknown as Prisma.InputJsonValue,\n            estimates: estimates as unknown as Prisma.InputJsonValue,\n            checkedAt: new Date(),\n        },\n        create: {\n            shopId,\n            orderCount,\n            productCount,\n            customerCount,\n            storeAgeDays,\n            dataSpanDays,\n            multiItemOrderCount,\n            categoryCount,\n            repeatCustomerCount,\n            overallScore: score,\n            isSufficient: sufficient,\n            nextHitReady: !blockers.some(b => b.feature === 'nextHitPredictions' || b.feature === 'all'),\n            seasonalityReady: !blockers.some(b => b.feature === 'seasonalityAnalysis'),\n            customerSegmentReady: !blockers.some(b => b.feature === 'customerSegmentation'),\n            basketAffinityReady: !blockers.some(b => b.feature === 'basketAffinity'),\n            categoryExpansionReady: !blockers.some(b => b.feature === 'categoryExpansion'),\n            blockers: blockers as unknown as Prisma.InputJsonValue,\n            warnings: warnings as unknown as Prisma.InputJsonValue,\n            estimates: estimates as unknown as Prisma.InputJsonValue,\n        },\n    });\n\n    console.log(`[DataSufficiency] Shop ${shopId}: Score ${score}%, Sufficient: ${sufficient}, Blockers: ${blockers.length}`);\n\n    return {\n        sufficient,\n        score,\n        blockers,\n        warnings,\n        estimates,\n        stats,\n    };\n}\n\n// ============================================\n// HELPER FUNCTIONS\n// ============================================\n\nfunction estimateDaysUntilOrders(current: number, needed: number, storeAgeDays: number): number {\n    if (storeAgeDays === 0 || current === 0) return 30; // Default estimate\n    const ordersPerDay = current / Math.max(1, storeAgeDays);\n    if (ordersPerDay === 0) return 30;\n    return Math.ceil((needed - current) / ordersPerDay);\n}\n\nfunction estimateWhenReady(current: number, needed: number, storeAgeDays: number): Date {\n    const daysUntil = estimateDaysUntilOrders(current, needed, storeAgeDays);\n    return new Date(Date.now() + daysUntil * 24 * 60 * 60 * 1000);\n}\n\n// ============================================\n// QUICK CHECK (For UI without full recompute)\n// ============================================\n\nexport async function getDataSufficiency(shopId: string): Promise<SufficiencyResult | null> {\n    const cached = await prisma.dataSufficiency.findUnique({\n        where: { shopId },\n    });\n\n    if (!cached) {\n        return checkDataSufficiency(shopId);\n    }\n\n    // If cached data is older than 1 hour, recompute\n    const oneHourAgo = new Date(Date.now() - 60 * 60 * 1000);\n    if (cached.checkedAt < oneHourAgo) {\n        return checkDataSufficiency(shopId);\n    }\n\n    return {\n        sufficient: cached.isSufficient,\n        score: cached.overallScore,\n        blockers: (cached.blockers as unknown as DataBlocker[]) || [],\n        warnings: (cached.warnings as unknown as DataWarning[]) || [],\n        estimates: (cached.estimates as unknown as DataEstimate[]) || [],\n        stats: {\n            orderCount: cached.orderCount,\n            productCount: cached.productCount,\n            customerCount: cached.customerCount,\n            storeAgeDays: cached.storeAgeDays,\n            dataSpanDays: cached.dataSpanDays,\n            multiItemOrderCount: cached.multiItemOrderCount,\n            categoryCount: cached.categoryCount,\n            repeatCustomerCount: cached.repeatCustomerCount,\n        },\n    };\n}\n\n// ============================================\n// FEATURE-SPECIFIC CHECK\n// ============================================\n\nexport async function canUseFeature(shopId: string, feature: string): Promise<{ allowed: boolean; blocker?: DataBlocker }> {\n    const sufficiency = await getDataSufficiency(shopId);\n    if (!sufficiency) {\n        return { allowed: false, blocker: { feature: 'all', requirement: 'Data check failed', current: 'Unknown', needed: 'Unknown', message: 'Unable to check data sufficiency' } };\n    }\n\n    const blocker = sufficiency.blockers.find(b => b.feature === feature || b.feature === 'all');\n    return {\n        allowed: !blocker,\n        blocker,\n    };\n}\n"],"names":[],"mappings":"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"}},
    {"offset": {"line": 2453, "column": 0}, "map": {"version":3,"sources":["file:///Users/mac/Desktop/NEW/packages/brain/src/intelligence/dna-completeness.ts"],"sourcesContent":["/**\n * DNA Completeness Checker\n * Identifies missing fields in Brand DNA and prompts users to fill them\n */\n\nimport { prisma } from '@brandmind/shared';\nimport { Prisma } from '@prisma/client';\n\n// ============================================\n// TYPES\n// ============================================\n\nexport interface MissingField {\n    field: string;\n    section: 'identity' | 'marketPosition' | 'operationalDNA' | 'customerDNA';\n    importance: 'critical' | 'important' | 'nice_to_have';\n    question: string;\n    inputType: 'text' | 'select' | 'multiselect' | 'number' | 'textarea';\n    options?: Array<{ label: string; value: string } | string>;\n    placeholder?: string;\n    helpText?: string;\n}\n\nexport interface SectionCompleteness {\n    score: number;\n    filledFields: number;\n    totalFields: number;\n    missingCritical: string[];\n    missingImportant: string[];\n    missingOptional: string[];\n}\n\nexport interface CompletenessResult {\n    overallScore: number;\n    isActionable: boolean;\n    sections: {\n        identity: SectionCompleteness;\n        marketPosition: SectionCompleteness;\n        operationalDNA: SectionCompleteness;\n        customerDNA: SectionCompleteness;\n    };\n    userActionRequired: MissingField[];\n    dataRequired: Array<{\n        field: string;\n        section: string;\n        source: string;\n        message: string;\n        action: string;\n    }>;\n}\n\n// ============================================\n// FIELD DEFINITIONS\n// ============================================\n\nconst IDENTITY_FIELDS: Array<{\n    field: string;\n    importance: MissingField['importance'];\n    question: string;\n    inputType: MissingField['inputType'];\n    options?: MissingField['options'];\n    placeholder?: string;\n    helpText?: string;\n}> = [\n    {\n        field: 'brandName',\n        importance: 'critical',\n        question: 'What is your brand name?',\n        inputType: 'text',\n        placeholder: 'e.g., Nike, Glossier, Allbirds',\n    },\n    {\n        field: 'mission',\n        importance: 'important',\n        question: 'What is your brand mission?',\n        inputType: 'textarea',\n        placeholder: 'e.g., To bring sustainable fashion to everyone',\n        helpText: 'This helps us suggest products aligned with your values',\n    },\n    {\n        field: 'coreValues',\n        importance: 'important',\n        question: \"What are your brand's core values?\",\n        inputType: 'multiselect',\n        options: [\n            'Quality', 'Sustainability', 'Innovation', 'Affordability',\n            'Luxury', 'Authenticity', 'Community', 'Simplicity', 'Craftsmanship',\n            'Transparency', 'Inclusivity', 'Wellness', 'Creativity',\n        ],\n        helpText: 'Select 3-5 values that define your brand',\n    },\n    {\n        field: 'targetAudience',\n        importance: 'critical',\n        question: 'Who is your primary customer?',\n        inputType: 'select',\n        options: [\n            { label: 'Women 18-24', value: 'women_18_24' },\n            { label: 'Women 25-34', value: 'women_25_34' },\n            { label: 'Women 35-44', value: 'women_35_44' },\n            { label: 'Women 45+', value: 'women_45_plus' },\n            { label: 'Men 18-24', value: 'men_18_24' },\n            { label: 'Men 25-34', value: 'men_25_34' },\n            { label: 'Men 35-44', value: 'men_35_44' },\n            { label: 'Men 45+', value: 'men_45_plus' },\n            { label: 'All genders 18-34', value: 'all_18_34' },\n            { label: 'All genders 35+', value: 'all_35_plus' },\n            { label: 'Families', value: 'families' },\n            { label: 'Businesses (B2B)', value: 'b2b' },\n        ],\n        helpText: 'This shapes what products we recommend',\n    },\n    {\n        field: 'brandPersonality',\n        importance: 'nice_to_have',\n        question: 'How would you describe your brand personality?',\n        inputType: 'multiselect',\n        options: [\n            'Bold', 'Minimalist', 'Playful', 'Sophisticated', 'Edgy',\n            'Classic', 'Modern', 'Warm', 'Professional', 'Adventurous',\n        ],\n        helpText: 'Select 2-4 traits that describe your brand',\n    },\n];\n\nconst MARKET_POSITION_FIELDS: typeof IDENTITY_FIELDS = [\n    {\n        field: 'industry',\n        importance: 'critical',\n        question: 'What industry are you in?',\n        inputType: 'select',\n        options: [\n            { label: 'Fashion & Apparel', value: 'fashion' },\n            { label: 'Beauty & Cosmetics', value: 'beauty' },\n            { label: 'Home & Living', value: 'home' },\n            { label: 'Food & Beverage', value: 'food' },\n            { label: 'Health & Wellness', value: 'health' },\n            { label: 'Electronics & Tech', value: 'electronics' },\n            { label: 'Sports & Outdoors', value: 'sports' },\n            { label: 'Kids & Baby', value: 'kids' },\n            { label: 'Pets', value: 'pets' },\n            { label: 'Jewelry & Accessories', value: 'jewelry' },\n            { label: 'Art & Crafts', value: 'art' },\n            { label: 'Other', value: 'other' },\n        ],\n    },\n    {\n        field: 'niche',\n        importance: 'important',\n        question: 'What is your specific niche?',\n        inputType: 'text',\n        placeholder: 'e.g., Sustainable yoga wear, Minimalist home decor',\n        helpText: 'Be specific - this helps us find your unique opportunities',\n    },\n    {\n        field: 'pricePositioning',\n        importance: 'critical',\n        question: 'How would you describe your price positioning?',\n        inputType: 'select',\n        options: [\n            { label: 'Budget - Lowest prices in market', value: 'budget' },\n            { label: 'Mid-Market - Competitive pricing', value: 'mid-market' },\n            { label: 'Premium - Higher quality, higher price', value: 'premium' },\n            { label: 'Luxury - Highest tier', value: 'luxury' },\n        ],\n    },\n    {\n        field: 'competitiveDifferentiator',\n        importance: 'important',\n        question: 'What makes you different from competitors?',\n        inputType: 'textarea',\n        placeholder: 'e.g., We use 100% recycled materials and donate 5% to ocean cleanup',\n        helpText: 'Your unique selling proposition',\n    },\n    {\n        field: 'directCompetitors',\n        importance: 'nice_to_have',\n        question: 'Who are your top 3 competitors?',\n        inputType: 'text',\n        placeholder: 'e.g., Lululemon, Athleta, Outdoor Voices',\n        helpText: 'Helps us understand your competitive landscape',\n    },\n];\n\n// ============================================\n// MAIN FUNCTION\n// ============================================\n\nexport async function checkDNACompleteness(shopId: string): Promise<CompletenessResult> {\n    const dna = await prisma.storeDNA.findUnique({\n        where: { shopId },\n    });\n\n    const userActionRequired: MissingField[] = [];\n    const dataRequired: CompletenessResult['dataRequired'] = [];\n\n    // ═══════════════════════════════════════════════════════════════\n    // CHECK IDENTITY FIELDS\n    // ═══════════════════════════════════════════════════════════════\n    const identityMissingCritical: string[] = [];\n    const identityMissingImportant: string[] = [];\n    const identityMissingOptional: string[] = [];\n    let identityFilled = 0;\n\n    for (const fieldDef of IDENTITY_FIELDS) {\n        const value = dna?.[fieldDef.field as keyof typeof dna];\n        const isEmpty = !value || (Array.isArray(value) && value.length === 0) ||\n            (typeof value === 'string' && value.trim() === '');\n\n        if (isEmpty) {\n            userActionRequired.push({\n                field: fieldDef.field,\n                section: 'identity',\n                importance: fieldDef.importance,\n                question: fieldDef.question,\n                inputType: fieldDef.inputType,\n                options: fieldDef.options,\n                placeholder: fieldDef.placeholder,\n                helpText: fieldDef.helpText,\n            });\n\n            if (fieldDef.importance === 'critical') identityMissingCritical.push(fieldDef.field);\n            else if (fieldDef.importance === 'important') identityMissingImportant.push(fieldDef.field);\n            else identityMissingOptional.push(fieldDef.field);\n        } else {\n            identityFilled++;\n        }\n    }\n\n    // ═══════════════════════════════════════════════════════════════\n    // CHECK MARKET POSITION FIELDS\n    // ═══════════════════════════════════════════════════════════════\n    const marketMissingCritical: string[] = [];\n    const marketMissingImportant: string[] = [];\n    const marketMissingOptional: string[] = [];\n    let marketFilled = 0;\n\n    for (const fieldDef of MARKET_POSITION_FIELDS) {\n        const value = dna?.[fieldDef.field as keyof typeof dna];\n        const isEmpty = !value || (Array.isArray(value) && value.length === 0) ||\n            (typeof value === 'string' && value.trim() === '');\n\n        if (isEmpty) {\n            userActionRequired.push({\n                field: fieldDef.field,\n                section: 'marketPosition',\n                importance: fieldDef.importance,\n                question: fieldDef.question,\n                inputType: fieldDef.inputType,\n                options: fieldDef.options,\n                placeholder: fieldDef.placeholder,\n                helpText: fieldDef.helpText,\n            });\n\n            if (fieldDef.importance === 'critical') marketMissingCritical.push(fieldDef.field);\n            else if (fieldDef.importance === 'important') marketMissingImportant.push(fieldDef.field);\n            else marketMissingOptional.push(fieldDef.field);\n        } else {\n            marketFilled++;\n        }\n    }\n\n    // ═══════════════════════════════════════════════════════════════\n    // CHECK OPERATIONAL DNA (From Shopify - can't be manually filled)\n    // ═══════════════════════════════════════════════════════════════\n    const operationalMissingCritical: string[] = [];\n    let operationalFilled = 0;\n    const operationalTotal = 5; // Key operational metrics\n\n    if (!dna?.avgOrderValue) {\n        operationalMissingCritical.push('avgOrderValue');\n        dataRequired.push({\n            field: 'avgOrderValue',\n            section: 'operationalDNA',\n            source: 'shopify_orders',\n            message: 'Average order value requires order data',\n            action: 'Ensure your store has at least 10 orders for accurate analysis',\n        });\n    } else {\n        operationalFilled++;\n    }\n\n    if (!dna?.priceBands) {\n        operationalMissingCritical.push('priceBands');\n        dataRequired.push({\n            field: 'priceBands',\n            section: 'operationalDNA',\n            source: 'shopify_orders',\n            message: 'Price band analysis requires order history',\n            action: 'More orders will improve price intelligence',\n        });\n    } else {\n        operationalFilled++;\n    }\n\n    if (!dna?.totalProducts || dna.totalProducts < 5) {\n        operationalMissingCritical.push('catalogStructure');\n        dataRequired.push({\n            field: 'catalogStructure',\n            section: 'operationalDNA',\n            source: 'shopify_products',\n            message: 'Catalog analysis requires more products',\n            action: 'Add at least 5 products for meaningful catalog insights',\n        });\n    } else {\n        operationalFilled++;\n    }\n\n    if (!dna?.seasonalityCurve) {\n        dataRequired.push({\n            field: 'seasonality',\n            section: 'operationalDNA',\n            source: 'shopify_orders',\n            message: 'Seasonality requires 6+ months of data',\n            action: 'Seasonality patterns will emerge over time',\n        });\n    } else {\n        operationalFilled++;\n    }\n\n    if (!dna?.heroProductShare) {\n        dataRequired.push({\n            field: 'revenueConcentration',\n            section: 'operationalDNA',\n            source: 'shopify_orders',\n            message: 'Revenue concentration requires sales data',\n            action: 'More orders will reveal product performance patterns',\n        });\n    } else {\n        operationalFilled++;\n    }\n\n    // ═══════════════════════════════════════════════════════════════\n    // CHECK CUSTOMER DNA (From Shopify - can't be manually filled)\n    // ═══════════════════════════════════════════════════════════════\n    const customerMissingCritical: string[] = [];\n    let customerFilled = 0;\n    const customerTotal = 4;\n\n    if (!dna?.repeatPurchaseRate) {\n        customerMissingCritical.push('repeatPurchaseRate');\n        dataRequired.push({\n            field: 'repeatPurchaseRate',\n            section: 'customerDNA',\n            source: 'shopify_orders',\n            message: 'Repeat purchase analysis requires order history',\n            action: 'Need at least 50 orders to calculate repeat patterns',\n        });\n    } else {\n        customerFilled++;\n    }\n\n    if (!dna?.basketAffinities) {\n        dataRequired.push({\n            field: 'basketAffinities',\n            section: 'customerDNA',\n            source: 'shopify_orders',\n            message: 'Basket affinity requires multi-item orders',\n            action: 'Need orders with multiple products to identify buying patterns',\n        });\n    } else {\n        customerFilled++;\n    }\n\n    if (!dna?.segmentDistribution) {\n        dataRequired.push({\n            field: 'customerSegments',\n            section: 'customerDNA',\n            source: 'shopify_customers',\n            message: 'Customer segmentation requires customer data',\n            action: 'Need at least 50 customers for meaningful segments',\n        });\n    } else {\n        customerFilled++;\n    }\n\n    if (!dna?.entryProducts) {\n        dataRequired.push({\n            field: 'entryProducts',\n            section: 'customerDNA',\n            source: 'shopify_orders',\n            message: 'Entry product analysis requires first-purchase data',\n            action: 'More customer purchase data will reveal entry points',\n        });\n    } else {\n        customerFilled++;\n    }\n\n    // ═══════════════════════════════════════════════════════════════\n    // CALCULATE SCORES\n    // ═══════════════════════════════════════════════════════════════\n    const identityTotal = IDENTITY_FIELDS.length;\n    const marketTotal = MARKET_POSITION_FIELDS.length;\n\n    const identityScore = Math.round((identityFilled / identityTotal) * 100);\n    const marketScore = Math.round((marketFilled / marketTotal) * 100);\n    const operationalScore = Math.round((operationalFilled / operationalTotal) * 100);\n    const customerScore = Math.round((customerFilled / customerTotal) * 100);\n\n    // Overall score weighted: Identity & Market more important for user input\n    const overallScore = Math.round(\n        (identityScore * 0.30) +\n        (marketScore * 0.25) +\n        (operationalScore * 0.30) +\n        (customerScore * 0.15)\n    );\n\n    // Can make predictions if critical identity + market + some operational data\n    const hasCriticalIdentity = identityMissingCritical.length === 0;\n    const hasCriticalMarket = marketMissingCritical.length === 0;\n    const hasMinimalOperational = operationalFilled >= 2;\n    const isActionable = hasCriticalIdentity && hasCriticalMarket && hasMinimalOperational;\n\n    // Sort user actions by importance\n    userActionRequired.sort((a, b) => {\n        const order = { critical: 0, important: 1, nice_to_have: 2 };\n        return order[a.importance] - order[b.importance];\n    });\n\n    const result: CompletenessResult = {\n        overallScore,\n        isActionable,\n        sections: {\n            identity: {\n                score: identityScore,\n                filledFields: identityFilled,\n                totalFields: identityTotal,\n                missingCritical: identityMissingCritical,\n                missingImportant: identityMissingImportant,\n                missingOptional: identityMissingOptional,\n            },\n            marketPosition: {\n                score: marketScore,\n                filledFields: marketFilled,\n                totalFields: marketTotal,\n                missingCritical: marketMissingCritical,\n                missingImportant: marketMissingImportant,\n                missingOptional: marketMissingOptional,\n            },\n            operationalDNA: {\n                score: operationalScore,\n                filledFields: operationalFilled,\n                totalFields: operationalTotal,\n                missingCritical: operationalMissingCritical,\n                missingImportant: [],\n                missingOptional: [],\n            },\n            customerDNA: {\n                score: customerScore,\n                filledFields: customerFilled,\n                totalFields: customerTotal,\n                missingCritical: customerMissingCritical,\n                missingImportant: [],\n                missingOptional: [],\n            },\n        },\n        userActionRequired,\n        dataRequired,\n    };\n\n    // ═══════════════════════════════════════════════════════════════\n    // SAVE TO DNA\n    // ═══════════════════════════════════════════════════════════════\n    if (dna) {\n        await prisma.storeDNA.update({\n            where: { shopId },\n            data: {\n                completenessScore: overallScore,\n                isActionable,\n                missingFields: userActionRequired as unknown as Prisma.InputJsonValue,\n                dataBlockers: dataRequired as unknown as Prisma.InputJsonValue,\n            },\n        });\n    }\n\n    console.log(`[DNACompleteness] Shop ${shopId}: ${overallScore}% complete, Actionable: ${isActionable}, Missing fields: ${userActionRequired.length}`);\n\n    return result;\n}\n\n// ============================================\n// UPDATE DNA FIELD\n// ============================================\n\nexport async function updateDNAField(shopId: string, field: string, value: any): Promise<void> {\n    const updateData: Record<string, any> = {};\n\n    // Handle special cases for JSON fields\n    if (field === 'targetAudience' && typeof value === 'string') {\n        updateData[field] = { primaryDemographic: value };\n    } else if (field === 'coreValues' || field === 'brandPersonality' || field === 'directCompetitors') {\n        // Convert comma-separated string to array if needed\n        updateData[field] = Array.isArray(value) ? value : value.split(',').map((s: string) => s.trim()).filter(Boolean);\n    } else {\n        updateData[field] = value;\n    }\n\n    await prisma.storeDNA.upsert({\n        where: { shopId },\n        update: updateData,\n        create: {\n            shopId,\n            ...updateData,\n        },\n    });\n\n    console.log(`[DNACompleteness] Updated ${field} for shop ${shopId}`);\n\n    // Recheck completeness\n    await checkDNACompleteness(shopId);\n}\n"],"names":[],"mappings":"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"}},
    {"offset": {"line": 2983, "column": 0}, "map": {"version":3,"sources":["file:///Users/mac/Desktop/NEW/packages/brain/src/intelligence/strategy-router.ts"],"sourcesContent":["/**\n * Strategy Router\n * Determines which product expansion strategy to recommend based on Brand DNA signals\n */\n\nimport { prisma } from '@brandmind/shared';\nimport { Prisma } from '@prisma/client';\n\n// ============================================\n// TYPES\n// ============================================\n\nexport type ExpansionStrategy =\n    | 'VARIANT_EXTENSION'      // Add sizes/colors to winners\n    | 'HORIZONTAL_EXTENSION'   // New product in same category\n    | 'VERTICAL_EXTENSION'     // Premium/budget version\n    | 'CATEGORY_EXPANSION'     // Adjacent category\n    | 'NEW_DOMAIN_ENTRY'       // Completely new category\n    | 'OPTIMIZE_EXISTING';     // No new products, fix what you have\n\nexport interface StrategyRecommendation {\n    primaryStrategy: ExpansionStrategy;\n    reasoning: string[];\n    confidence: number;\n    alternativeStrategies: Array<{\n        strategy: ExpansionStrategy;\n        reasoning: string;\n    }>;\n    launchTiming: {\n        recommended: string;\n        reasoning: string;\n    };\n}\n\ninterface DNASignals {\n    // Revenue Concentration\n    heroProductShare: number;\n    top5ProductShare: number;\n    concentrationRisk: 'low' | 'medium' | 'high';\n\n    // Growth Momentum\n    orderVelocityTrend: 'accelerating' | 'stable' | 'declining';\n    revenueGrowth30d: number;\n\n    // Margin Health\n    marginHealthStatus: 'healthy' | 'moderate' | 'stressed';\n\n    // Cash Position\n    inferredCashPosition: 'cash_rich' | 'balanced' | 'tight';\n    cashCowProductCount: number;\n    starProductCount: number;\n\n    // Catalog Structure\n    categoryDepth: 'shallow' | 'moderate' | 'deep';\n    categoryBreadth: 'narrow' | 'moderate' | 'broad';\n\n    // Timing\n    seasonalPosition: 'pre_peak' | 'peak' | 'post_peak' | 'off_season';\n    monthsUntilPeak: number;\n}\n\n// ============================================\n// MAIN FUNCTION\n// ============================================\n\nexport function determineExpansionStrategy(signals: DNASignals): StrategyRecommendation {\n    const alternatives: StrategyRecommendation['alternativeStrategies'] = [];\n\n    // ═══════════════════════════════════════════════════════════════\n    // RULE 1: If margins are stressed, don't add products\n    // ═══════════════════════════════════════════════════════════════\n    if (signals.marginHealthStatus === 'stressed') {\n        return {\n            primaryStrategy: 'OPTIMIZE_EXISTING',\n            reasoning: [\n                'Margin health indicates financial stress',\n                'Focus on improving existing product profitability before expansion',\n                'New products would add complexity without solving core margin issues',\n            ],\n            confidence: 0.9,\n            alternativeStrategies: [],\n            launchTiming: {\n                recommended: 'After margin recovery',\n                reasoning: 'Stabilize margins before investing in new products',\n            },\n        };\n    }\n\n    // ═══════════════════════════════════════════════════════════════\n    // RULE 2: If highly dependent on hero + hero is accelerating\n    // → Diversify with variants (reduce risk while it's hot)\n    // ═══════════════════════════════════════════════════════════════\n    if (\n        signals.heroProductShare > 40 &&\n        signals.orderVelocityTrend === 'accelerating'\n    ) {\n        alternatives.push({\n            strategy: 'HORIZONTAL_EXTENSION',\n            reasoning: 'Could also introduce a complementary product in same category',\n        });\n\n        return {\n            primaryStrategy: 'VARIANT_EXTENSION',\n            reasoning: [\n                `Hero product drives ${signals.heroProductShare.toFixed(0)}% of revenue - high concentration risk`,\n                'Velocity is accelerating - capitalize on momentum while it lasts',\n                'Adding variants reduces dependency risk while leveraging the winner',\n            ],\n            confidence: 0.85,\n            alternativeStrategies: alternatives,\n            launchTiming: {\n                recommended: 'Now',\n                reasoning: 'Strike while momentum is strong',\n            },\n        };\n    }\n\n    // ═══════════════════════════════════════════════════════════════\n    // RULE 3: If highly dependent on hero + hero is declining\n    // → Horizontal extension (same category, new product)\n    // ═══════════════════════════════════════════════════════════════\n    if (\n        signals.heroProductShare > 40 &&\n        signals.orderVelocityTrend === 'declining'\n    ) {\n        alternatives.push({\n            strategy: 'VARIANT_EXTENSION',\n            reasoning: 'Could refresh the hero with new variants to revive interest',\n        });\n\n        return {\n            primaryStrategy: 'HORIZONTAL_EXTENSION',\n            reasoning: [\n                `Hero product (${signals.heroProductShare.toFixed(0)}% of revenue) is losing momentum`,\n                'Need a new flagship product in the same category',\n                'Customers already trust your category expertise - give them something fresh',\n            ],\n            confidence: 0.8,\n            alternativeStrategies: alternatives,\n            launchTiming: {\n                recommended: 'Within 30 days',\n                reasoning: 'Urgently need to replace declining hero',\n            },\n        };\n    }\n\n    // ═══════════════════════════════════════════════════════════════\n    // RULE 4: If cash-rich + diversified + good margins\n    // → Category expansion (you can afford to experiment)\n    // ═══════════════════════════════════════════════════════════════\n    if (\n        signals.inferredCashPosition === 'cash_rich' &&\n        signals.concentrationRisk === 'low' &&\n        signals.marginHealthStatus === 'healthy'\n    ) {\n        alternatives.push({\n            strategy: 'NEW_DOMAIN_ENTRY',\n            reasoning: 'Strong position could support entering completely new market',\n        });\n        alternatives.push({\n            strategy: 'VERTICAL_EXTENSION',\n            reasoning: 'Could introduce premium tier to capture higher-value segment',\n        });\n\n        return {\n            primaryStrategy: 'CATEGORY_EXPANSION',\n            reasoning: [\n                'Strong financial position allows for strategic category bets',\n                'Revenue is well diversified - experimentation risk is manageable',\n                'Time to expand market reach with an adjacent category',\n            ],\n            confidence: 0.75,\n            alternativeStrategies: alternatives,\n            launchTiming: {\n                recommended: signals.seasonalPosition === 'pre_peak' ? 'Before peak season' : 'When ready',\n                reasoning: 'Financial runway supports thoughtful planning',\n            },\n        };\n    }\n\n    // ═══════════════════════════════════════════════════════════════\n    // RULE 5: If category depth is shallow + winners exist\n    // → Variant extension (fill out the line)\n    // ═══════════════════════════════════════════════════════════════\n    if (\n        signals.categoryDepth === 'shallow' &&\n        signals.starProductCount > 0\n    ) {\n        alternatives.push({\n            strategy: 'HORIZONTAL_EXTENSION',\n            reasoning: 'Could add complementary products instead of variants',\n        });\n\n        return {\n            primaryStrategy: 'VARIANT_EXTENSION',\n            reasoning: [\n                'Catalog depth is shallow - clear opportunity to fill out variants',\n                `${signals.starProductCount} star product(s) can be extended with more options`,\n                'Lower risk than new product development - proven demand exists',\n            ],\n            confidence: 0.8,\n            alternativeStrategies: alternatives,\n            launchTiming: {\n                recommended: 'Now',\n                reasoning: 'Quick wins available from variant additions',\n            },\n        };\n    }\n\n    // ═══════════════════════════════════════════════════════════════\n    // RULE 6: If breadth is narrow + margins are good\n    // → Category expansion (broaden your reach)\n    // Note: marginHealthStatus already checked for 'stressed' in RULE 1\n    // ═══════════════════════════════════════════════════════════════\n    if (signals.categoryBreadth === 'narrow') {\n        alternatives.push({\n            strategy: 'HORIZONTAL_EXTENSION',\n            reasoning: 'Could deepen existing category before expanding',\n        });\n\n        return {\n            primaryStrategy: 'CATEGORY_EXPANSION',\n            reasoning: [\n                'Category breadth is narrow - vulnerability to market shifts in single category',\n                'Margins can support investment in new categories',\n                'Basket affinity data can guide which adjacent category to enter',\n            ],\n            confidence: 0.7,\n            alternativeStrategies: alternatives,\n            launchTiming: {\n                recommended: 'Within 60 days',\n                reasoning: 'Diversification reduces long-term risk',\n            },\n        };\n    }\n\n    // ═══════════════════════════════════════════════════════════════\n    // RULE 7: If approaching peak season + have cash\n    // → Horizontal extension (quick wins for the season)\n    // ═══════════════════════════════════════════════════════════════\n    if (\n        signals.seasonalPosition === 'pre_peak' &&\n        signals.inferredCashPosition !== 'tight' &&\n        signals.monthsUntilPeak <= 3\n    ) {\n        alternatives.push({\n            strategy: 'VARIANT_EXTENSION',\n            reasoning: 'Variants of existing products are faster to launch',\n        });\n\n        return {\n            primaryStrategy: 'HORIZONTAL_EXTENSION',\n            reasoning: [\n                `Peak season approaching in ${signals.monthsUntilPeak} month(s)`,\n                'Time to launch complementary products for seasonal demand',\n                'Lower risk than category expansion, faster time to market',\n            ],\n            confidence: 0.75,\n            alternativeStrategies: alternatives,\n            launchTiming: {\n                recommended: `Within ${signals.monthsUntilPeak * 4} weeks`,\n                reasoning: 'Must launch before peak to capture seasonal demand',\n            },\n        };\n    }\n\n    // ═══════════════════════════════════════════════════════════════\n    // DEFAULT: Horizontal extension (safest growth move)\n    // ═══════════════════════════════════════════════════════════════\n    alternatives.push({\n        strategy: 'VARIANT_EXTENSION',\n        reasoning: 'Could focus on extending existing products first',\n    });\n\n    return {\n        primaryStrategy: 'HORIZONTAL_EXTENSION',\n        reasoning: [\n            'Standard growth path: extend within known category',\n            'Leverage existing brand equity and customer trust',\n            'Moderate risk with moderate reward potential',\n        ],\n        confidence: 0.6,\n        alternativeStrategies: alternatives,\n        launchTiming: {\n            recommended: 'When ready',\n            reasoning: 'No urgent timing pressure detected',\n        },\n    };\n}\n\n// ============================================\n// EXTRACT SIGNALS FROM STORE DNA\n// ============================================\n\nexport async function getStrategyRecommendation(shopId: string): Promise<StrategyRecommendation | null> {\n    const dna = await prisma.storeDNA.findUnique({\n        where: { shopId },\n    });\n\n    if (!dna) {\n        console.log(`[StrategyRouter] No StoreDNA found for shop ${shopId}`);\n        return null;\n    }\n\n    // Extract signals from DNA\n    const signals: DNASignals = {\n        heroProductShare: dna.heroProductShare ?? 0,\n        top5ProductShare: dna.top5ProductShare ?? 0,\n        concentrationRisk: (dna.concentrationRisk as DNASignals['concentrationRisk']) ?? 'medium',\n        orderVelocityTrend: (dna.orderVelocityTrend as DNASignals['orderVelocityTrend']) ?? 'stable',\n        revenueGrowth30d: dna.revenueGrowth30d ?? 0,\n        marginHealthStatus: (dna.marginHealthStatus as DNASignals['marginHealthStatus']) ?? 'moderate',\n        inferredCashPosition: (dna.inferredCashPosition as DNASignals['inferredCashPosition']) ?? 'balanced',\n        cashCowProductCount: dna.cashCowProductCount ?? 0,\n        starProductCount: dna.starProductCount ?? 0,\n        categoryDepth: (dna.categoryDepth as DNASignals['categoryDepth']) ?? 'moderate',\n        categoryBreadth: (dna.categoryBreadth as DNASignals['categoryBreadth']) ?? 'moderate',\n        seasonalPosition: (dna.seasonalPosition as DNASignals['seasonalPosition']) ?? 'off_season',\n        monthsUntilPeak: dna.monthsUntilPeak ?? 6,\n    };\n\n    const recommendation = determineExpansionStrategy(signals);\n\n    // Save recommendation to DNA\n    await prisma.storeDNA.update({\n        where: { shopId },\n        data: {\n            recommendedStrategy: recommendation.primaryStrategy,\n            strategyReasons: recommendation.reasoning,\n            strategyConfidence: recommendation.confidence,\n            alternativeStrategies: recommendation.alternativeStrategies as unknown as Prisma.InputJsonValue,\n            recommendedLaunchTiming: recommendation.launchTiming.recommended,\n            launchTimingReason: recommendation.launchTiming.reasoning,\n        },\n    });\n\n    console.log(`[StrategyRouter] Recommended ${recommendation.primaryStrategy} for shop ${shopId} (confidence: ${recommendation.confidence})`);\n\n    return recommendation;\n}\n\n// ============================================\n// STRATEGY DESCRIPTIONS (For UI)\n// ============================================\n\nexport const STRATEGY_INFO: Record<ExpansionStrategy, {\n    name: string;\n    description: string;\n    riskLevel: 'low' | 'medium' | 'high';\n    timeToMarket: string;\n    examples: string[];\n}> = {\n    VARIANT_EXTENSION: {\n        name: 'Variant Extension',\n        description: 'Add new sizes, colors, or materials to your existing winning products',\n        riskLevel: 'low',\n        timeToMarket: '2-4 weeks',\n        examples: [\n            'Adding new colors to your best-selling dress',\n            'Introducing size XXL for popular items',\n            'Offering a leather version of a canvas bag',\n        ],\n    },\n    HORIZONTAL_EXTENSION: {\n        name: 'Horizontal Extension',\n        description: 'Launch a new product in the same category as your current offerings',\n        riskLevel: 'medium',\n        timeToMarket: '4-8 weeks',\n        examples: [\n            'Adding pants to complement your tops collection',\n            'Launching a new serum alongside existing skincare',\n            'Introducing a new flavor of your popular snack',\n        ],\n    },\n    VERTICAL_EXTENSION: {\n        name: 'Vertical Extension',\n        description: 'Create a premium or budget version of existing products',\n        riskLevel: 'medium',\n        timeToMarket: '6-10 weeks',\n        examples: [\n            'Premium organic version of your bestseller',\n            'Budget-friendly line for price-sensitive customers',\n            'Luxury limited edition collection',\n        ],\n    },\n    CATEGORY_EXPANSION: {\n        name: 'Category Expansion',\n        description: 'Enter an adjacent category that complements your current offerings',\n        riskLevel: 'medium',\n        timeToMarket: '8-12 weeks',\n        examples: [\n            'Clothing brand adding accessories',\n            'Skincare brand launching makeup',\n            'Coffee company adding tea products',\n        ],\n    },\n    NEW_DOMAIN_ENTRY: {\n        name: 'New Domain Entry',\n        description: 'Enter a completely new product category or market',\n        riskLevel: 'high',\n        timeToMarket: '12-16 weeks',\n        examples: [\n            'Fashion brand launching home goods',\n            'Food company entering wellness supplements',\n            'Beauty brand creating lifestyle products',\n        ],\n    },\n    OPTIMIZE_EXISTING: {\n        name: 'Optimize Existing',\n        description: 'Focus on improving current product performance before adding new products',\n        riskLevel: 'low',\n        timeToMarket: 'Ongoing',\n        examples: [\n            'Improve margins on existing products',\n            'Reduce refund rates',\n            'Optimize pricing strategy',\n        ],\n    },\n};\n"],"names":[],"mappings":"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"}},
    {"offset": {"line": 3305, "column": 0}, "map": {"version":3,"sources":["file:///Users/mac/Desktop/NEW/packages/brain/src/intelligence/dna-seeder.ts"],"sourcesContent":["/**\n * DNA Seeder\n * Auto-populates Brand DNA from Shopify data and domain analysis\n */\n\nimport { prisma } from '@brandmind/shared';\n\n// ============================================\n// TYPES\n// ============================================\n\ninterface ShopifyMetrics {\n  totalOrders: number;\n  totalRevenue: number;\n  avgOrderValue: number;\n  totalProducts: number;\n  totalCustomers: number;\n  repeatCustomerCount: number;\n  topProducts: Array<{\n    id: string;\n    title: string;\n    revenue: number;\n    quantity: number;\n    productType?: string;\n  }>;\n  productTypes: string[];\n  priceRange: { min: number; max: number; avg: number };\n  recentOrders: number;\n  monthlyRevenue: Array<{ month: string; revenue: number }>;\n}\n\n// ============================================\n// MAIN SEEDING FUNCTION\n// ============================================\n\nexport async function seedDNAFromShopify(shopId: string): Promise<void> {\n  console.log(`[DNASeeder] Starting DNA seed for shop ${shopId}`);\n\n  const metrics = await gatherShopifyMetrics(shopId);\n\n  if (!metrics) {\n    console.log(`[DNASeeder] No metrics available for shop ${shopId}`);\n    return;\n  }\n\n  // Calculate derived signals\n  const heroProductShare = calculateHeroProductShare(metrics);\n  const top5ProductShare = calculateTop5ProductShare(metrics);\n  const concentrationRisk = determineConcentrationRisk(heroProductShare);\n  const orderVelocityTrend = calculateVelocityTrend(metrics);\n  const pricePositioning = determinePricePositioning(metrics);\n  const categoryDepth = determineCategoryDepth(metrics);\n  const categoryBreadth = determineCategoryBreadth(metrics);\n  const priceBands = calculatePriceBands(metrics);\n  const bcgMatrix = calculateBCGMatrix(metrics);\n  const revenueGrowth = calculateRevenueGrowth(metrics);\n  const repeatPurchaseRate = metrics.repeatCustomerCount / Math.max(1, metrics.totalCustomers);\n\n  // Calculate topPerformingTypes from topProducts grouped by productType\n  const typeRevenue: Record<string, { revenue: number; quantity: number }> = {};\n  // Filter out products with unknown/missing titles\n  const validProducts = metrics.topProducts.filter(p => p.title && p.title !== 'Unknown');\n\n  for (const product of validProducts) {\n    // Use productType if set, otherwise derive from title\n    let type: string = product.productType || '';\n    if (!type || type === 'Other' || type === 'Uncategorized') {\n      type = deriveProductTypeFromTitle(product.title);\n    }\n    if (!typeRevenue[type]) {\n      typeRevenue[type] = { revenue: 0, quantity: 0 };\n    }\n    typeRevenue[type].revenue += product.revenue;\n    typeRevenue[type].quantity += product.quantity;\n  }\n\n  const topPerformingTypes = Object.entries(typeRevenue)\n    // Filter out generic/fallback types\n    .filter(([type]) => type && type !== 'General' && type !== 'Unknown' && type !== 'Other')\n    .map(([type, data]) => ({\n      type,\n      revenue: data.revenue,\n      revenueShare: metrics.totalRevenue > 0 ? (data.revenue / metrics.totalRevenue) * 100 : 0,\n      growthRate: 0, // Would need historical data\n      avgOrderValue: data.quantity > 0 ? data.revenue / data.quantity : 0,\n    }))\n    .sort((a, b) => b.revenue - a.revenue)\n    .slice(0, 10);\n\n  // Build update data object\n  const dnaData = {\n    totalProducts: metrics.totalProducts,\n    avgOrderValue: metrics.avgOrderValue,\n    priceBands: priceBands,\n    categoryDepth,\n    categoryBreadth,\n    heroProductShare,\n    top5ProductShare,\n    concentrationRisk,\n    orderVelocityTrend,\n    revenueGrowth30d: revenueGrowth,\n    starProductCount: bcgMatrix.stars.length,\n    cashCowProductCount: bcgMatrix.cashCows.length,\n    questionMarkProductCount: bcgMatrix.questionMarks.length,\n    inferredCashPosition: inferCashPosition(bcgMatrix),\n    pricePositioning,\n    repeatPurchaseRate,\n    entryProducts: metrics.topProducts.slice(0, 3).map(p => p.title),\n    topPerformingTypes,\n    hasShopifyData: true,\n    lastShopifySync: new Date(),\n  };\n\n  // Upsert StoreDNA using raw query to avoid type issues\n  const existingDna = await prisma.storeDNA.findUnique({ where: { shopId } });\n\n  if (existingDna) {\n    await prisma.storeDNA.update({\n      where: { shopId },\n      data: dnaData as any,\n    });\n  } else {\n    await prisma.storeDNA.create({\n      data: {\n        shopId,\n        ...dnaData,\n      } as any,\n    });\n  }\n\n  console.log(`[DNASeeder] DNA seeded for shop ${shopId}`);\n}\n\n// ============================================\n// GATHER SHOPIFY METRICS\n// ============================================\n\nasync function gatherShopifyMetrics(shopId: string): Promise<ShopifyMetrics | null> {\n  const [orderAgg, productAgg, customerAgg, products, recentOrdersCount] = await Promise.all([\n    prisma.order.aggregate({\n      where: { shopId },\n      _count: true,\n      _sum: { totalPrice: true },\n      _avg: { totalPrice: true },\n    }),\n    prisma.product.aggregate({\n      where: { shopId },\n      _count: true,\n    }),\n    prisma.customer.aggregate({\n      where: { shopId },\n      _count: true,\n    }),\n    prisma.product.findMany({\n      where: { shopId },\n      select: {\n        id: true,\n        title: true,\n        productType: true,\n        variants: {\n          select: { price: true },\n        },\n      },\n    }),\n    prisma.order.count({\n      where: {\n        shopId,\n        createdAt: { gte: new Date(Date.now() - 30 * 24 * 60 * 60 * 1000) },\n      },\n    }),\n  ]);\n\n  if (orderAgg._count === 0) {\n    return null;\n  }\n\n  // Get top products by revenue using line items\n  const lineItemsWithRevenue = await prisma.orderLineItem.groupBy({\n    by: ['productId'],\n    where: {\n      order: { shopId },\n      productId: { not: null },\n    },\n    _sum: { price: true, quantity: true },\n    orderBy: { _sum: { price: 'desc' } },\n    take: 20,\n  });\n\n  const topProductIds = lineItemsWithRevenue.map(li => li.productId).filter(Boolean) as string[];\n  const topProductDetails = await prisma.product.findMany({\n    where: { id: { in: topProductIds } },\n    select: { id: true, title: true, productType: true },\n  });\n\n  const topProducts = lineItemsWithRevenue\n    .map(li => {\n      const product = topProductDetails.find(p => p.id === li.productId);\n      return {\n        id: li.productId || '',\n        title: product?.title || '',\n        revenue: Number(li._sum.price || 0),\n        quantity: Number(li._sum.quantity || 0),\n        productType: product?.productType || undefined,\n      };\n    })\n    .filter(p => p.title && p.title.length > 0); // Filter out products without titles\n\n  // Get distinct product types\n  const productTypes = [...new Set(products.map(p => p.productType).filter(Boolean))] as string[];\n\n  // Calculate price range\n  const allPrices = products.flatMap(p => p.variants.map(v => Number(v.price))).filter(p => p > 0);\n  const priceRange = {\n    min: allPrices.length > 0 ? Math.min(...allPrices) : 0,\n    max: allPrices.length > 0 ? Math.max(...allPrices) : 0,\n    avg: allPrices.length > 0 ? allPrices.reduce((a, b) => a + b, 0) / allPrices.length : 0,\n  };\n\n  // Get repeat customers\n  let repeatCustomerCount = 0;\n  try {\n    const repeatCustomers = await prisma.$queryRaw`\n      SELECT COUNT(*) as count FROM (\n        SELECT \"customerId\"\n        FROM \"Order\"\n        WHERE \"shopId\" = ${shopId}\n          AND \"customerId\" IS NOT NULL\n        GROUP BY \"customerId\"\n        HAVING COUNT(*) > 1\n      ) as repeat_customers\n    ` as any[];\n    repeatCustomerCount = Number(repeatCustomers[0]?.count || 0);\n  } catch (e) {\n    repeatCustomerCount = 0;\n  }\n\n  // Get monthly revenue for trend analysis\n  const sixMonthsAgo = new Date(Date.now() - 180 * 24 * 60 * 60 * 1000);\n  const orders = await prisma.order.findMany({\n    where: { shopId, createdAt: { gte: sixMonthsAgo } },\n    select: { createdAt: true, totalPrice: true },\n  });\n\n  const monthlyRevenue: Record<string, number> = {};\n  orders.forEach(order => {\n    const month = order.createdAt.toISOString().slice(0, 7);\n    monthlyRevenue[month] = (monthlyRevenue[month] || 0) + Number(order.totalPrice);\n  });\n\n  return {\n    totalOrders: orderAgg._count,\n    totalRevenue: Number(orderAgg._sum.totalPrice || 0),\n    avgOrderValue: Number(orderAgg._avg.totalPrice || 0),\n    totalProducts: productAgg._count,\n    totalCustomers: customerAgg._count,\n    repeatCustomerCount,\n    topProducts,\n    productTypes,\n    priceRange,\n    recentOrders: recentOrdersCount,\n    monthlyRevenue: Object.entries(monthlyRevenue)\n      .map(([month, revenue]) => ({ month, revenue }))\n      .sort((a, b) => a.month.localeCompare(b.month)),\n  };\n}\n\n// ============================================\n// CALCULATION HELPERS\n// ============================================\n\nfunction calculateHeroProductShare(metrics: ShopifyMetrics): number {\n  if (metrics.topProducts.length === 0 || metrics.totalRevenue === 0) return 0;\n  return (metrics.topProducts[0].revenue / metrics.totalRevenue) * 100;\n}\n\nfunction calculateTop5ProductShare(metrics: ShopifyMetrics): number {\n  if (metrics.topProducts.length === 0 || metrics.totalRevenue === 0) return 0;\n  const top5Revenue = metrics.topProducts.slice(0, 5).reduce((sum, p) => sum + p.revenue, 0);\n  return (top5Revenue / metrics.totalRevenue) * 100;\n}\n\nfunction determineConcentrationRisk(heroShare: number): 'low' | 'medium' | 'high' {\n  if (heroShare > 50) return 'high';\n  if (heroShare > 30) return 'medium';\n  return 'low';\n}\n\nfunction calculateVelocityTrend(metrics: ShopifyMetrics): 'accelerating' | 'stable' | 'declining' {\n  if (metrics.monthlyRevenue.length < 2) return 'stable';\n\n  const recent = metrics.monthlyRevenue.slice(-3);\n  if (recent.length < 2) return 'stable';\n\n  const firstHalf = recent.slice(0, Math.ceil(recent.length / 2));\n  const secondHalf = recent.slice(Math.ceil(recent.length / 2));\n\n  const firstAvg = firstHalf.reduce((sum, m) => sum + m.revenue, 0) / firstHalf.length;\n  const secondAvg = secondHalf.reduce((sum, m) => sum + m.revenue, 0) / secondHalf.length;\n\n  const changePercent = ((secondAvg - firstAvg) / Math.max(1, firstAvg)) * 100;\n\n  if (changePercent > 15) return 'accelerating';\n  if (changePercent < -15) return 'declining';\n  return 'stable';\n}\n\nfunction calculateRevenueGrowth(metrics: ShopifyMetrics): number {\n  if (metrics.monthlyRevenue.length < 2) return 0;\n\n  const lastMonth = metrics.monthlyRevenue[metrics.monthlyRevenue.length - 1]?.revenue || 0;\n  const prevMonth = metrics.monthlyRevenue[metrics.monthlyRevenue.length - 2]?.revenue || 0;\n\n  if (prevMonth === 0) return 0;\n  return ((lastMonth - prevMonth) / prevMonth) * 100;\n}\n\nfunction determinePricePositioning(metrics: ShopifyMetrics): string {\n  const avg = metrics.priceRange.avg;\n  if (avg < 25) return 'budget';\n  if (avg < 75) return 'mid-market';\n  if (avg < 200) return 'premium';\n  return 'luxury';\n}\n\nfunction determineCategoryDepth(metrics: ShopifyMetrics): 'shallow' | 'moderate' | 'deep' {\n  const avgProductsPerType = metrics.totalProducts / Math.max(1, metrics.productTypes.length);\n  if (avgProductsPerType < 5) return 'shallow';\n  if (avgProductsPerType < 15) return 'moderate';\n  return 'deep';\n}\n\nfunction determineCategoryBreadth(metrics: ShopifyMetrics): 'narrow' | 'moderate' | 'broad' {\n  const typeCount = metrics.productTypes.length;\n  if (typeCount <= 2) return 'narrow';\n  if (typeCount <= 5) return 'moderate';\n  return 'broad';\n}\n\nfunction calculatePriceBands(metrics: ShopifyMetrics): { low: number; mid: number; high: number } {\n  const { min, max } = metrics.priceRange;\n  const range = max - min;\n  return {\n    low: min + range * 0.33,\n    mid: min + range * 0.66,\n    high: max,\n  };\n}\n\nfunction calculateBCGMatrix(metrics: ShopifyMetrics): {\n  stars: string[];\n  cashCows: string[];\n  questionMarks: string[];\n  dogs: string[];\n} {\n  const totalRevenue = metrics.totalRevenue;\n  const avgShare = 100 / Math.max(1, metrics.topProducts.length);\n\n  const stars: string[] = [];\n  const cashCows: string[] = [];\n  const questionMarks: string[] = [];\n  const dogs: string[] = [];\n\n  metrics.topProducts.forEach((product, idx) => {\n    const share = (product.revenue / Math.max(1, totalRevenue)) * 100;\n    const isHighShare = share > avgShare;\n    const isHighGrowth = idx < 5;\n\n    if (isHighShare && isHighGrowth) {\n      stars.push(product.title);\n    } else if (isHighShare && !isHighGrowth) {\n      cashCows.push(product.title);\n    } else if (!isHighShare && isHighGrowth) {\n      questionMarks.push(product.title);\n    } else {\n      dogs.push(product.title);\n    }\n  });\n\n  return { stars, cashCows, questionMarks, dogs };\n}\n\nfunction inferCashPosition(bcg: ReturnType<typeof calculateBCGMatrix>): 'cash_rich' | 'balanced' | 'tight' {\n  const hasCashCows = bcg.cashCows.length > 0;\n  const hasStars = bcg.stars.length > 0;\n  const manyDogs = bcg.dogs.length > 5;\n\n  if (hasCashCows && hasStars) return 'cash_rich';\n  if (manyDogs && !hasCashCows) return 'tight';\n  return 'balanced';\n}\n\nfunction deriveProductTypeFromTitle(title: string): string {\n  if (!title || title === 'Unknown') return 'General';\n\n  const lowerTitle = title.toLowerCase();\n\n  // Common product type keywords - extend based on your catalog\n  const typeKeywords: Record<string, string[]> = {\n    'Haremshose': ['haremshose', 'harem pants', 'harem'],\n    'Palazzo': ['palazzo', 'wide leg'],\n    'Jumpsuit': ['jumpsuit', 'overall', 'einteiler'],\n    'Kleid': ['kleid', 'dress'],\n    'Top': ['top', 'shirt', 'bluse', 'blouse'],\n    'Hose': ['hose', 'pants', 'trousers'],\n    'Rock': ['rock', 'skirt'],\n    'Jacke': ['jacke', 'jacket', 'cardigan'],\n    'Loungewear': ['loungewear', 'lounge'],\n    'Set': ['set', 'combo', 'bundle'],\n  };\n\n  for (const [type, keywords] of Object.entries(typeKeywords)) {\n    for (const keyword of keywords) {\n      if (lowerTitle.includes(keyword)) {\n        return type;\n      }\n    }\n  }\n\n  // Words to skip when extracting type from title\n  const skipWords = ['warme', 'warm', 'mystery', 'long', 'short', 'version', 'new', 'sale', 'special'];\n\n  // Extract first significant word from title as fallback\n  const words = title.split(/[\\s\\-–]+/).filter(w =>\n    w.length > 3 && !skipWords.includes(w.toLowerCase())\n  );\n\n  if (words.length > 0) {\n    // Capitalize first letter\n    return words[0].charAt(0).toUpperCase() + words[0].slice(1).toLowerCase();\n  }\n\n  return 'General';\n}\n\n// ============================================\n// SEED FROM DOMAIN ANALYSIS\n// ============================================\n\nexport async function seedDNAFromDomainAnalysis(\n  shopId: string,\n  analysis: {\n    brandName?: string;\n    description?: string;\n    industry?: string;\n  }\n): Promise<void> {\n  const existingDna = await prisma.storeDNA.findUnique({ where: { shopId } });\n\n  const dnaData = {\n    brandName: analysis.brandName,\n    industry: analysis.industry,\n    hasPublicDemoData: true,\n  };\n\n  if (existingDna) {\n    await prisma.storeDNA.update({\n      where: { shopId },\n      data: dnaData as any,\n    });\n  } else {\n    await prisma.storeDNA.create({\n      data: {\n        shopId,\n        ...dnaData,\n      } as any,\n    });\n  }\n\n  console.log(`[DNASeeder] Seeded DNA from domain analysis for shop ${shopId}`);\n}\n"],"names":[],"mappings":"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"}},
    {"offset": {"line": 3789, "column": 0}, "map": {"version":3,"sources":["file:///Users/mac/Desktop/NEW/packages/brain/src/intelligence/insights-engine.ts"],"sourcesContent":["/**\n * Insights Engine\n * Unified intelligence layer for all store insights\n */\n\nimport { prisma } from '@brandmind/shared';\n\n// ============================================\n// TYPES\n// ============================================\n\nexport interface CatalogHealth {\n  overallScore: number;\n  grade: 'A' | 'B' | 'C' | 'D' | 'F';\n  metrics: {\n    diversification: { score: number; label: string; detail: string };\n    priceCoverage: { score: number; label: string; detail: string };\n    categoryDepth: { score: number; label: string; detail: string };\n    velocity: { score: number; label: string; detail: string };\n    customerLoyalty: { score: number; label: string; detail: string };\n  };\n  recommendations: string[];\n}\n\nexport interface PatternInsight {\n  id: string;\n  type: 'color_winner' | 'bundle_opportunity' | 'price_sweet_spot' | 'seasonal_peak' | 'growth_category';\n  title: string;\n  detail: string;\n  action: string;\n  confidence: number;\n  impact: 'high' | 'medium' | 'low';\n  icon: string;\n}\n\nexport interface ProductGrade {\n  productId: string;\n  title: string;\n  grade: 'A' | 'B' | 'C' | 'D' | 'F';\n  score: number;\n  metrics: {\n    velocity: number;\n    revenue: number;\n    refundRate: number;\n  };\n  trend: 'up' | 'down' | 'stable';\n  recommendation: string;\n}\n\nexport interface BundleSuggestion {\n  id: string;\n  products: string[];\n  productIds: string[];\n  coOccurrences: number;\n  suggestedDiscount: number;\n  estimatedUplift: number;\n  bundleName: string;\n  confidence: number;\n}\n\nexport interface PriceAlert {\n  productId: string;\n  productTitle: string;\n  currentPrice: number;\n  currentBand: string;\n  optimalBand: string;\n  suggestion: string;\n  potentialUplift: string;\n}\n\nexport interface SeasonalMonth {\n  month: string;\n  monthIndex: number;\n  revenueIndex: number;\n  isPeak: boolean;\n  isSlow: boolean;\n  recommendation: string;\n  icon: string;\n}\n\nexport interface CannibalizationPair {\n  product1: { id: string; title: string };\n  product2: { id: string; title: string };\n  similarity: number;\n  sharedAttributes: string[];\n  recommendation: string;\n}\n\nexport interface CustomerCohort {\n  name: string;\n  count: number;\n  percentage: number;\n  totalRevenue: number;\n  avgOrderValue: number;\n  color: string;\n  action: string;\n}\n\nexport interface RestockAlert {\n  productId: string;\n  productTitle: string;\n  currentStock: number;\n  dailyVelocity: number;\n  daysUntilStockout: number;\n  urgency: 'critical' | 'warning' | 'ok';\n  suggestedReorder: number;\n}\n\nexport interface MarketingMoment {\n  id: string;\n  type: 'product_launch' | 'flash_sale' | 'bundle_promo' | 'winback' | 'loyalty';\n  timing: string;\n  title: string;\n  description: string;\n  targetAudience: string;\n  expectedImpact: string;\n  priority: 'high' | 'medium' | 'low';\n}\n\n// ============================================\n// CATALOG HEALTH\n// ============================================\n\nexport async function calculateCatalogHealth(shopId: string): Promise<CatalogHealth> {\n  const dnaRaw = await prisma.storeDNA.findUnique({ where: { shopId } });\n  const patterns = await prisma.patternMemory.findMany({ where: { shopId } });\n\n  if (!dnaRaw) {\n    return getDefaultCatalogHealth();\n  }\n\n  // Cast to any to access dynamic fields\n  const dna = dnaRaw as any;\n\n  // Diversification score based on concentration risk\n  const concentrationRisk = dna.concentrationRisk || 'medium';\n  const heroShare = dna.heroProductShare || 0;\n  const diversification = {\n    score: concentrationRisk === 'low' ? 90 : concentrationRisk === 'medium' ? 65 : 35,\n    label: concentrationRisk === 'low' ? 'Well Diversified' : concentrationRisk === 'medium' ? 'Moderate Risk' : 'High Concentration',\n    detail: `Hero product is ${heroShare.toFixed(1)}% of revenue`\n  };\n\n  // Price coverage\n  const pricePattern = patterns.find(p => p.patternType === 'price_band');\n  const priceBands = (pricePattern?.patternData as any)?.winners || [];\n  const priceCoverage = {\n    score: Math.min(100, priceBands.length * 25),\n    label: priceBands.length >= 4 ? 'Full Coverage' : priceBands.length >= 2 ? 'Partial Coverage' : 'Limited',\n    detail: `Active in ${priceBands.length} price bands`\n  };\n\n  // Category depth\n  const catDepth = dna.categoryDepth || 'moderate';\n  const catBreadth = dna.categoryBreadth || 'moderate';\n  const categoryDepth = {\n    score: catDepth === 'deep' ? 90 : catDepth === 'moderate' ? 65 : 40,\n    label: catDepth === 'deep' ? 'Deep Catalog' : catDepth === 'moderate' ? 'Moderate Depth' : 'Shallow',\n    detail: `${catBreadth} category breadth`\n  };\n\n  // Velocity - use revenueGrowth30d to determine trend\n  const revenueGrowth = dna.revenueGrowth30d || 0;\n  const velocityTrend = revenueGrowth > 15 ? 'accelerating' : revenueGrowth > -5 ? 'stable' : 'declining';\n  const velocity = {\n    score: velocityTrend === 'accelerating' ? 95 : velocityTrend === 'stable' ? 70 : 40,\n    label: velocityTrend === 'accelerating' ? 'Growing Fast' : velocityTrend === 'stable' ? 'Stable' : 'Slowing',\n    detail: `${revenueGrowth.toFixed(1)}% growth last 30d`\n  };\n\n  // Customer loyalty\n  const repeatRate = dna.repeatPurchaseRate || 0;\n  const customerLoyalty = {\n    score: Math.min(100, repeatRate * 200),\n    label: repeatRate > 0.3 ? 'Strong Loyalty' : repeatRate > 0.15 ? 'Moderate' : 'Needs Work',\n    detail: `${(repeatRate * 100).toFixed(1)}% repeat purchase rate`\n  };\n\n  const overallScore = Math.round(\n    (diversification.score * 0.2) +\n    (priceCoverage.score * 0.15) +\n    (categoryDepth.score * 0.15) +\n    (velocity.score * 0.3) +\n    (customerLoyalty.score * 0.2)\n  );\n\n  const grade = overallScore >= 85 ? 'A' : overallScore >= 70 ? 'B' : overallScore >= 55 ? 'C' : overallScore >= 40 ? 'D' : 'F';\n\n  const recommendations: string[] = [];\n  if (diversification.score < 60) recommendations.push('Reduce dependency on hero product');\n  if (priceCoverage.score < 50) recommendations.push('Expand into more price bands');\n  if (velocity.score < 60) recommendations.push('Focus on marketing to boost velocity');\n  if (customerLoyalty.score < 50) recommendations.push('Implement loyalty program');\n\n  return {\n    overallScore,\n    grade,\n    metrics: { diversification, priceCoverage, categoryDepth, velocity, customerLoyalty },\n    recommendations\n  };\n}\n\nfunction getDefaultCatalogHealth(): CatalogHealth {\n  return {\n    overallScore: 0,\n    grade: 'F',\n    metrics: {\n      diversification: { score: 0, label: 'No Data', detail: 'Sync your store first' },\n      priceCoverage: { score: 0, label: 'No Data', detail: 'Sync your store first' },\n      categoryDepth: { score: 0, label: 'No Data', detail: 'Sync your store first' },\n      velocity: { score: 0, label: 'No Data', detail: 'Sync your store first' },\n      customerLoyalty: { score: 0, label: 'No Data', detail: 'Sync your store first' },\n    },\n    recommendations: ['Connect your Shopify store to get insights']\n  };\n}\n\n// ============================================\n// PATTERN INSIGHTS\n// ============================================\n\nexport async function getPatternInsights(shopId: string): Promise<PatternInsight[]> {\n  const patterns = await prisma.patternMemory.findMany({ where: { shopId } });\n  const insights: PatternInsight[] = [];\n\n  for (const pattern of patterns) {\n    const data = pattern.patternData as any;\n\n    if (pattern.patternType === 'color_preference' && data?.winners?.length > 0) {\n      const winner = data.winners[0];\n      insights.push({\n        id: `color-${winner.value}`,\n        type: 'color_winner',\n        title: `${capitalize(winner.value)} is your champion color`,\n        detail: `${(winner.successRate * 100).toFixed(0)}% success rate across ${winner.sampleSize} orders`,\n        action: 'Expand this color to more product types',\n        confidence: pattern.confidence,\n        impact: winner.successRate > 0.8 ? 'high' : 'medium',\n        icon: 'palette'\n      });\n    }\n\n    if (pattern.patternType === 'cross_purchase' && data?.topPairs?.length > 0) {\n      const pair = data.topPairs[0];\n      insights.push({\n        id: `bundle-${pair.products[0].slice(0, 10)}`,\n        type: 'bundle_opportunity',\n        title: 'Bundle opportunity detected',\n        detail: `${pair.count} customers buy these together`,\n        action: `Create bundle: ${shortenName(pair.products[0])} + ${shortenName(pair.products[1])}`,\n        confidence: pattern.confidence,\n        impact: pair.count > 20 ? 'high' : 'medium',\n        icon: 'package'\n      });\n    }\n\n    if (pattern.patternType === 'price_band' && data?.optimalBand) {\n      insights.push({\n        id: 'price-sweet-spot',\n        type: 'price_sweet_spot',\n        title: `${capitalize(data.optimalBand)} is your sweet spot`,\n        detail: 'Customers convert best at this price point',\n        action: 'Focus new products in this price range',\n        confidence: pattern.confidence,\n        impact: 'high',\n        icon: 'dollar-sign'\n      });\n    }\n\n    if (pattern.patternType === 'seasonal' && data?.peakMonths?.length > 0) {\n      const peak = data.peakMonths[0];\n      insights.push({\n        id: `seasonal-${peak.month}`,\n        type: 'seasonal_peak',\n        title: `${peak.month} is your peak season`,\n        detail: `Revenue ${((peak.avgRevenue / (data.monthlyData?.reduce((s: number, m: any) => s + m.avgRevenue, 0) / 12 || 1)) * 100 - 100).toFixed(0)}% above average`,\n        action: 'Plan inventory and launches for this period',\n        confidence: pattern.confidence,\n        impact: 'high',\n        icon: 'trending-up'\n      });\n    }\n\n    if (pattern.patternType === 'category_affinity' && data?.winners?.length > 0) {\n      const top = data.winners[0];\n      if (top.velocityPerProduct > 5) {\n        insights.push({\n          id: `category-${top.value}`,\n          type: 'growth_category',\n          title: `${top.value} has high velocity`,\n          detail: `${top.velocityPerProduct.toFixed(1)} units/product in 90 days`,\n          action: 'Consider expanding this category',\n          confidence: pattern.confidence,\n          impact: 'medium',\n          icon: 'zap'\n        });\n      }\n    }\n  }\n\n  return insights.sort((a, b) => {\n    const impactOrder = { high: 0, medium: 1, low: 2 };\n    return impactOrder[a.impact] - impactOrder[b.impact];\n  });\n}\n\n// ============================================\n// PRODUCT GRADER\n// ============================================\n\nexport async function gradeProducts(shopId: string): Promise<ProductGrade[]> {\n  const thirtyDaysAgo = new Date();\n  thirtyDaysAgo.setDate(thirtyDaysAgo.getDate() - 30);\n\n  const sixtyDaysAgo = new Date();\n  sixtyDaysAgo.setDate(sixtyDaysAgo.getDate() - 60);\n\n  const products = await prisma.product.findMany({\n    where: { shopId },\n    include: {\n      variants: {\n        include: {\n          metrics: {\n            where: { date: { gte: sixtyDaysAgo } },\n            orderBy: { date: 'desc' }\n          }\n        }\n      }\n    }\n  });\n\n  const grades: ProductGrade[] = [];\n\n  for (const product of products) {\n    const recentMetrics = product.variants.flatMap(v =>\n      v.metrics.filter(m => m.date >= thirtyDaysAgo)\n    );\n    const olderMetrics = product.variants.flatMap(v =>\n      v.metrics.filter(m => m.date < thirtyDaysAgo && m.date >= sixtyDaysAgo)\n    );\n\n    const recentRevenue = recentMetrics.reduce((s, m) => s + Number(m.revenue), 0);\n    const olderRevenue = olderMetrics.reduce((s, m) => s + Number(m.revenue), 0);\n    const recentUnits = recentMetrics.reduce((s, m) => s + m.unitsSold, 0);\n\n    const velocity = recentUnits / 30;\n    const refundRate = 0.05; // Would calculate from actual refund data\n\n    // Score: 40% velocity, 40% revenue, 20% low refund\n    const velocityScore = Math.min(100, velocity * 10);\n    const revenueScore = Math.min(100, recentRevenue / 50);\n    const refundScore = (1 - refundRate) * 100;\n    const score = (velocityScore * 0.4) + (revenueScore * 0.4) + (refundScore * 0.2);\n\n    const grade = score >= 80 ? 'A' : score >= 60 ? 'B' : score >= 40 ? 'C' : score >= 20 ? 'D' : 'F';\n\n    let trend: 'up' | 'down' | 'stable' = 'stable';\n    if (olderRevenue > 0) {\n      const change = (recentRevenue - olderRevenue) / olderRevenue;\n      trend = change > 0.1 ? 'up' : change < -0.1 ? 'down' : 'stable';\n    }\n\n    let recommendation = 'Keep stocked';\n    if (grade === 'F') recommendation = 'Consider discontinuing';\n    else if (grade === 'D') recommendation = 'Needs marketing boost';\n    else if (grade === 'A') recommendation = 'Expand variants';\n\n    grades.push({\n      productId: product.id,\n      title: product.title,\n      grade,\n      score: Math.round(score),\n      metrics: { velocity, revenue: recentRevenue, refundRate },\n      trend,\n      recommendation\n    });\n  }\n\n  return grades.sort((a, b) => b.score - a.score);\n}\n\n// ============================================\n// BUNDLE SUGGESTIONS\n// ============================================\n\nexport async function suggestBundles(shopId: string): Promise<BundleSuggestion[]> {\n  const crossPurchase = await prisma.patternMemory.findUnique({\n    where: { shopId_patternType: { shopId, patternType: 'cross_purchase' } }\n  });\n\n  const topPairs = (crossPurchase?.patternData as any)?.topPairs || [];\n  const suggestions: BundleSuggestion[] = [];\n\n  for (let i = 0; i < Math.min(5, topPairs.length); i++) {\n    const pair = topPairs[i];\n    if (!pair.products || pair.products.length < 2) continue;\n\n    suggestions.push({\n      id: `bundle-${i}`,\n      products: pair.products,\n      productIds: [], // Would need to resolve from titles\n      coOccurrences: pair.count,\n      suggestedDiscount: pair.count > 20 ? 10 : 15,\n      estimatedUplift: pair.count * 15,\n      bundleName: `${shortenName(pair.products[0])} + ${shortenName(pair.products[1])} Set`,\n      confidence: Math.min(0.9, 0.5 + pair.count / 50)\n    });\n  }\n\n  return suggestions;\n}\n\n// ============================================\n// PRICE ALERTS\n// ============================================\n\nexport async function getPriceAlerts(shopId: string): Promise<PriceAlert[]> {\n  const pricePattern = await prisma.patternMemory.findUnique({\n    where: { shopId_patternType: { shopId, patternType: 'price_band' } }\n  });\n\n  const optimalBand = (pricePattern?.patternData as any)?.optimalBand || 'value';\n\n  const products = await prisma.product.findMany({\n    where: { shopId },\n    include: { variants: { take: 1 } }\n  });\n\n  const alerts: PriceAlert[] = [];\n  const priceRanges: Record<string, [number, number]> = {\n    'budget': [0, 30],\n    'value': [30, 60],\n    'mid': [60, 100],\n    'premium': [100, 200],\n    'luxury': [200, 1000]\n  };\n\n  for (const product of products) {\n    const price = Number(product.variants[0]?.price || 0);\n    if (price === 0) continue;\n\n    let currentBand = 'value';\n    for (const [band, [min, max]] of Object.entries(priceRanges)) {\n      if (price >= min && price < max) {\n        currentBand = band;\n        break;\n      }\n    }\n\n    if (currentBand !== optimalBand) {\n      const [optMin, optMax] = priceRanges[optimalBand];\n      alerts.push({\n        productId: product.id,\n        productTitle: product.title,\n        currentPrice: price,\n        currentBand,\n        optimalBand,\n        suggestion: `Consider a variant at €${optMin}-${optMax}`,\n        potentialUplift: '+15-25% conversion'\n      });\n    }\n  }\n\n  return alerts.slice(0, 10);\n}\n\n// ============================================\n// SEASONAL CALENDAR\n// ============================================\n\nexport async function getSeasonalCalendar(shopId: string): Promise<SeasonalMonth[]> {\n  const seasonal = await prisma.patternMemory.findUnique({\n    where: { shopId_patternType: { shopId, patternType: 'seasonal' } }\n  });\n\n  const monthNames = ['Jan', 'Feb', 'Mar', 'Apr', 'May', 'Jun', 'Jul', 'Aug', 'Sep', 'Oct', 'Nov', 'Dec'];\n  const data = seasonal?.patternData as any;\n  const monthlyData = data?.monthlyData || [];\n  const peakMonths = data?.peakMonths || [];\n  const slowMonths = data?.slowMonths || [];\n\n  const avgRevenue = monthlyData.length > 0\n    ? monthlyData.reduce((s: number, m: any) => s + m.avgRevenue, 0) / monthlyData.length\n    : 1;\n\n  return monthNames.map((month, idx) => {\n    const monthData = monthlyData.find((m: any) => m.month === month);\n    const revenue = monthData?.avgRevenue || 0;\n    const isPeak = peakMonths.some((p: any) => p.month === month);\n    const isSlow = slowMonths.some((s: any) => s.month === month);\n\n    let recommendation = 'Maintain steady operations';\n    let icon = 'minus';\n    if (isPeak) {\n      recommendation = 'Launch new products, stock up inventory';\n      icon = 'rocket';\n    } else if (isSlow) {\n      recommendation = 'Run promotions, clear old stock';\n      icon = 'tag';\n    }\n\n    return {\n      month,\n      monthIndex: idx,\n      revenueIndex: avgRevenue > 0 ? revenue / avgRevenue : 1,\n      isPeak,\n      isSlow,\n      recommendation,\n      icon\n    };\n  });\n}\n\n// ============================================\n// CANNIBALIZATION DETECTOR\n// ============================================\n\nexport async function detectCannibalization(shopId: string): Promise<CannibalizationPair[]> {\n  const products = await prisma.product.findMany({\n    where: { shopId },\n    include: { variants: { take: 1 } }\n  });\n\n  const pairs: CannibalizationPair[] = [];\n\n  for (let i = 0; i < products.length && pairs.length < 10; i++) {\n    for (let j = i + 1; j < products.length && pairs.length < 10; j++) {\n      const p1 = products[i];\n      const p2 = products[j];\n\n      const sharedAttributes: string[] = [];\n      let similarity = 0;\n\n      // Same product type\n      if (p1.productType && p1.productType === p2.productType) {\n        similarity += 0.4;\n        sharedAttributes.push(`Same type: ${p1.productType}`);\n      }\n\n      // Similar price\n      const price1 = Number(p1.variants[0]?.price || 0);\n      const price2 = Number(p2.variants[0]?.price || 0);\n      if (price1 > 0 && price2 > 0 && Math.abs(price1 - price2) < 15) {\n        similarity += 0.3;\n        sharedAttributes.push(`Similar price: €${price1.toFixed(0)} vs €${price2.toFixed(0)}`);\n      }\n\n      // Title word overlap\n      const words1 = new Set(p1.title.toLowerCase().split(/\\s+/).filter(w => w.length > 3));\n      const words2 = new Set(p2.title.toLowerCase().split(/\\s+/).filter(w => w.length > 3));\n      const overlap = [...words1].filter(w => words2.has(w)).length;\n      if (overlap >= 2) {\n        similarity += 0.3 * Math.min(1, overlap / 3);\n        sharedAttributes.push(`${overlap} shared keywords`);\n      }\n\n      if (similarity >= 0.6) {\n        pairs.push({\n          product1: { id: p1.id, title: p1.title },\n          product2: { id: p2.id, title: p2.title },\n          similarity: Math.round(similarity * 100),\n          sharedAttributes,\n          recommendation: similarity > 0.8 ? 'Consider consolidating' : 'Differentiate positioning'\n        });\n      }\n    }\n  }\n\n  return pairs.sort((a, b) => b.similarity - a.similarity);\n}\n\n// ============================================\n// CUSTOMER COHORTS\n// ============================================\n\nexport async function analyzeCustomerCohorts(shopId: string): Promise<CustomerCohort[]> {\n  // Get orders grouped by customer\n  const orders = await prisma.order.findMany({\n    where: { shopId, customerId: { not: null } },\n    select: { customerId: true, totalPrice: true, createdAt: true },\n    orderBy: { createdAt: 'desc' }\n  });\n\n  // Group orders by customer\n  const customerOrders: Record<string, { orders: Array<{ totalPrice: any; createdAt: Date }> }> = {};\n  for (const order of orders) {\n    if (!order.customerId) continue;\n    if (!customerOrders[order.customerId]) {\n      customerOrders[order.customerId] = { orders: [] };\n    }\n    customerOrders[order.customerId].orders.push({\n      totalPrice: order.totalPrice,\n      createdAt: order.createdAt\n    });\n  }\n\n  const ninetyDaysAgo = new Date();\n  ninetyDaysAgo.setDate(ninetyDaysAgo.getDate() - 90);\n\n  const thirtyDaysAgo = new Date();\n  thirtyDaysAgo.setDate(thirtyDaysAgo.getDate() - 30);\n\n  const cohorts = {\n    vip: { count: 0, revenue: 0 },\n    loyal: { count: 0, revenue: 0 },\n    atRisk: { count: 0, revenue: 0 },\n    oneTime: { count: 0, revenue: 0 },\n    new: { count: 0, revenue: 0 }\n  };\n\n  for (const customerId of Object.keys(customerOrders)) {\n    const customerData = customerOrders[customerId];\n    const orderCount = customerData.orders.length;\n    const totalRevenue = customerData.orders.reduce((s: number, o) => s + Number(o.totalPrice), 0);\n    const lastOrder = customerData.orders[0]?.createdAt;\n    const daysSince = lastOrder ? Math.floor((Date.now() - lastOrder.getTime()) / (1000 * 60 * 60 * 24)) : 999;\n\n    if (orderCount >= 3 && totalRevenue > 300) {\n      cohorts.vip.count++;\n      cohorts.vip.revenue += totalRevenue;\n    } else if (orderCount >= 2) {\n      cohorts.loyal.count++;\n      cohorts.loyal.revenue += totalRevenue;\n    } else if (orderCount === 1 && daysSince > 90) {\n      cohorts.atRisk.count++;\n      cohorts.atRisk.revenue += totalRevenue;\n    } else if (orderCount === 1 && daysSince <= 30) {\n      cohorts.new.count++;\n      cohorts.new.revenue += totalRevenue;\n    } else {\n      cohorts.oneTime.count++;\n      cohorts.oneTime.revenue += totalRevenue;\n    }\n  }\n\n  const total = Object.keys(customerOrders).length || 1;\n\n  return [\n    {\n      name: 'VIP',\n      count: cohorts.vip.count,\n      percentage: (cohorts.vip.count / total) * 100,\n      totalRevenue: cohorts.vip.revenue,\n      avgOrderValue: cohorts.vip.count > 0 ? cohorts.vip.revenue / cohorts.vip.count : 0,\n      color: '#f59e0b',\n      action: 'Exclusive early access & perks'\n    },\n    {\n      name: 'Loyal',\n      count: cohorts.loyal.count,\n      percentage: (cohorts.loyal.count / total) * 100,\n      totalRevenue: cohorts.loyal.revenue,\n      avgOrderValue: cohorts.loyal.count > 0 ? cohorts.loyal.revenue / cohorts.loyal.count : 0,\n      color: '#10b981',\n      action: 'Loyalty rewards program'\n    },\n    {\n      name: 'New',\n      count: cohorts.new.count,\n      percentage: (cohorts.new.count / total) * 100,\n      totalRevenue: cohorts.new.revenue,\n      avgOrderValue: cohorts.new.count > 0 ? cohorts.new.revenue / cohorts.new.count : 0,\n      color: '#3b82f6',\n      action: 'Welcome series & second purchase incentive'\n    },\n    {\n      name: 'One-Time',\n      count: cohorts.oneTime.count,\n      percentage: (cohorts.oneTime.count / total) * 100,\n      totalRevenue: cohorts.oneTime.revenue,\n      avgOrderValue: cohorts.oneTime.count > 0 ? cohorts.oneTime.revenue / cohorts.oneTime.count : 0,\n      color: '#6b7280',\n      action: 'Re-engagement campaign'\n    },\n    {\n      name: 'At Risk',\n      count: cohorts.atRisk.count,\n      percentage: (cohorts.atRisk.count / total) * 100,\n      totalRevenue: cohorts.atRisk.revenue,\n      avgOrderValue: cohorts.atRisk.count > 0 ? cohorts.atRisk.revenue / cohorts.atRisk.count : 0,\n      color: '#ef4444',\n      action: 'Win-back campaign with discount'\n    }\n  ];\n}\n\n// ============================================\n// RESTOCK PREDICTOR\n// ============================================\n\nexport async function predictRestocks(shopId: string): Promise<RestockAlert[]> {\n  const thirtyDaysAgo = new Date();\n  thirtyDaysAgo.setDate(thirtyDaysAgo.getDate() - 30);\n\n  const products = await prisma.product.findMany({\n    where: { shopId },\n    include: {\n      variants: {\n        include: {\n          metrics: {\n            where: { date: { gte: thirtyDaysAgo } }\n          }\n        }\n      }\n    }\n  });\n\n  const alerts: RestockAlert[] = [];\n\n  for (const product of products) {\n    const totalUnits = product.variants.reduce((s, v) =>\n      s + v.metrics.reduce((ss, m) => ss + m.unitsSold, 0), 0);\n    const dailyVelocity = totalUnits / 30;\n\n    const currentStock = product.variants.reduce((s, v) => s + (v.inventoryQuantity || 0), 0);\n    const daysUntilStockout = dailyVelocity > 0 ? currentStock / dailyVelocity : 999;\n\n    let urgency: 'critical' | 'warning' | 'ok' = 'ok';\n    if (daysUntilStockout < 7) urgency = 'critical';\n    else if (daysUntilStockout < 14) urgency = 'warning';\n\n    if (urgency !== 'ok' || dailyVelocity > 0.5) {\n      alerts.push({\n        productId: product.id,\n        productTitle: product.title,\n        currentStock,\n        dailyVelocity: Math.round(dailyVelocity * 10) / 10,\n        daysUntilStockout: Math.round(daysUntilStockout),\n        urgency,\n        suggestedReorder: Math.round(dailyVelocity * 45) // 45 day supply\n      });\n    }\n  }\n\n  return alerts.sort((a, b) => a.daysUntilStockout - b.daysUntilStockout).slice(0, 15);\n}\n\n// ============================================\n// MARKETING MOMENTS\n// ============================================\n\nexport async function findMarketingMoments(shopId: string): Promise<MarketingMoment[]> {\n  const seasonal = await prisma.patternMemory.findUnique({\n    where: { shopId_patternType: { shopId, patternType: 'seasonal' } }\n  });\n  const crossPurchase = await prisma.patternMemory.findUnique({\n    where: { shopId_patternType: { shopId, patternType: 'cross_purchase' } }\n  });\n  const cohorts = await analyzeCustomerCohorts(shopId);\n\n  const moments: MarketingMoment[] = [];\n  const now = new Date();\n  const nextMonth = new Date(now.getFullYear(), now.getMonth() + 1, 1)\n    .toLocaleString('en', { month: 'short' });\n\n  const seasonalData = seasonal?.patternData as any;\n  const peakMonths = seasonalData?.peakMonths || [];\n  const slowMonths = seasonalData?.slowMonths || [];\n\n  // Peak month coming - product launch\n  if (peakMonths.some((p: any) => p.month === nextMonth)) {\n    moments.push({\n      id: 'launch-peak',\n      type: 'product_launch',\n      timing: `Early ${nextMonth}`,\n      title: 'Peak Season Launch Window',\n      description: `${nextMonth} is historically your best month. Launch new products now.`,\n      targetAudience: 'All customers',\n      expectedImpact: '+20-40% revenue vs off-peak',\n      priority: 'high'\n    });\n  }\n\n  // Slow month coming - flash sale\n  if (slowMonths.some((s: any) => s.month === nextMonth)) {\n    moments.push({\n      id: 'flash-slow',\n      type: 'flash_sale',\n      timing: `Start of ${nextMonth}`,\n      title: 'Pre-emptive Flash Sale',\n      description: `${nextMonth} typically underperforms. Run a flash sale to boost traffic.`,\n      targetAudience: 'Email subscribers',\n      expectedImpact: 'Mitigate 15-25% revenue dip',\n      priority: 'high'\n    });\n  }\n\n  // Bundle promo from cross-purchase\n  const topPairs = (crossPurchase?.patternData as any)?.topPairs || [];\n  if (topPairs.length > 0) {\n    moments.push({\n      id: 'bundle-promo',\n      type: 'bundle_promo',\n      timing: 'This week',\n      title: 'Bundle Campaign',\n      description: `Promote top bundle: ${shortenName(topPairs[0].products[0])} + ${shortenName(topPairs[0].products[1])}`,\n      targetAudience: 'Past purchasers of either product',\n      expectedImpact: `+€${(topPairs[0].count * 15).toFixed(0)}/month potential`,\n      priority: 'medium'\n    });\n  }\n\n  // Win-back for at-risk\n  const atRisk = cohorts.find(c => c.name === 'At Risk');\n  if (atRisk && atRisk.count > 10) {\n    moments.push({\n      id: 'winback',\n      type: 'winback',\n      timing: 'Next 7 days',\n      title: 'Win-Back Campaign',\n      description: `${atRisk.count} customers haven't ordered in 90+ days`,\n      targetAudience: 'At-risk segment',\n      expectedImpact: `Recover €${(atRisk.count * 50).toFixed(0)} potential revenue`,\n      priority: 'medium'\n    });\n  }\n\n  // VIP appreciation\n  const vip = cohorts.find(c => c.name === 'VIP');\n  if (vip && vip.count > 5) {\n    moments.push({\n      id: 'vip-love',\n      type: 'loyalty',\n      timing: 'Ongoing',\n      title: 'VIP Appreciation',\n      description: `${vip.count} VIPs drive significant revenue. Show them love.`,\n      targetAudience: 'VIP segment',\n      expectedImpact: 'Increase LTV by 20%+',\n      priority: 'low'\n    });\n  }\n\n  return moments.sort((a, b) => {\n    const priorityOrder = { high: 0, medium: 1, low: 2 };\n    return priorityOrder[a.priority] - priorityOrder[b.priority];\n  });\n}\n\n// ============================================\n// HELPERS\n// ============================================\n\nfunction capitalize(str: string): string {\n  return str.charAt(0).toUpperCase() + str.slice(1).toLowerCase();\n}\n\nfunction shortenName(name: string): string {\n  const shortened = name\n    .replace(/^(Warme Loungewear |Warme |Mystery )/i, '')\n    .replace(/ Long Version$/i, '')\n    .replace(/ Short Version$/i, '');\n  return shortened.length > 25 ? shortened.substring(0, 22) + '...' : shortened;\n}\n"],"names":[],"mappings":"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"}},
    {"offset": {"line": 4577, "column": 0}, "map": {"version":3,"sources":["file:///Users/mac/Desktop/NEW/packages/brain/src/agents/launch-kit-agent.ts"],"sourcesContent":["/**\n * Launch Kit Agent\n * Product launch strategy, copy generation, and success planning\n */\n\nimport { prisma } from '@brandmind/shared';\nimport { Prisma } from '@prisma/client';\nimport OpenAI from 'openai';\n\n// OpenAI client is initialized lazily within functions to ensure \n// environment variables (OPENAI_API_KEY) are loaded before usage.\n\n// ============================================\n// TYPES\n// ============================================\n\nexport interface LaunchKitInput {\n    productName: string;\n    productType: string;\n    targetPrice: number;\n    description?: string;\n    shopId: string;\n    candidateId?: string;\n}\n\nexport interface LaunchStrategy {\n    timing: {\n        recommendedLaunch: string;\n        peakMonth: string;\n        reasoning: string;\n    };\n    channels: {\n        primary: string;\n        secondary: string[];\n        prioritization: string;\n    };\n    budget: {\n        suggested: number;\n        breakdown: Record<string, number>;\n    };\n}\n\nexport interface CopyAssets {\n    headline: string;\n    tagline: string;\n    description: string;\n    emailSubject: string;\n    socialPosts: string[];\n}\n\nexport interface PricingStrategy {\n    msrp: number;\n    introPrice: number;\n    introDiscountPercent: number;\n    bundleOptions: Array<{\n        name: string;\n        products: string[];\n        bundlePrice: number;\n        savings: number;\n    }>;\n}\n\n// ============================================\n// LAUNCH STRATEGY GENERATOR\n// ============================================\n\nasync function generateLaunchStrategy(input: LaunchKitInput): Promise<LaunchStrategy> {\n    // Get store DNA for context\n    const storeDNA = await prisma.storeDNA.findUnique({\n        where: { shopId: input.shopId },\n    });\n\n    const seasonality = (storeDNA as any)?.seasonalityCurve || [];\n    const currentMonth = new Date().getMonth();\n\n    // Find peak month\n    const peakMonth = seasonality.reduce((best: any, current: any) => {\n        if (!best || current.revenueIndex > best.revenueIndex) return current;\n        return best;\n    }, null);\n\n    // Determine launch timing\n    const monthsUntilPeak = peakMonth\n        ? (peakMonth.month - currentMonth + 12) % 12\n        : 1;\n\n    const timing = {\n        recommendedLaunch: monthsUntilPeak <= 2\n            ? 'Launch now to catch upcoming peak'\n            : `Launch in ${monthsUntilPeak - 1} months, 1 month before peak`,\n        peakMonth: peakMonth?.monthName || 'Unknown',\n        reasoning: peakMonth\n            ? `${peakMonth.monthName} shows ${Math.round(peakMonth.revenueIndex * 100)}% of average revenue`\n            : 'Insufficient data for seasonality analysis',\n    };\n\n    // Channel prioritization based on price point\n    const channels = {\n        primary: input.targetPrice > 100 ? 'Email to existing customers' : 'Social media',\n        secondary: input.targetPrice > 100\n            ? ['Instagram stories', 'SMS', 'Influencer seeding']\n            : ['Email newsletter', 'Google Shopping', 'TikTok'],\n        prioritization: input.targetPrice > 100\n            ? 'Focus on existing customers and premium positioning'\n            : 'Maximize reach with social and paid acquisition',\n    };\n\n    // Budget suggestion (roughly 10-15% of target first month revenue)\n    const estimatedFirstMonthUnits = input.targetPrice > 100 ? 20 : 50;\n    const estimatedRevenue = estimatedFirstMonthUnits * input.targetPrice;\n    const suggestedBudget = Math.round(estimatedRevenue * 0.12);\n\n    const budget = {\n        suggested: suggestedBudget,\n        breakdown: {\n            'Paid Social': Math.round(suggestedBudget * 0.4),\n            'Email/SMS': Math.round(suggestedBudget * 0.1),\n            'Influencer': Math.round(suggestedBudget * 0.3),\n            'Creative': Math.round(suggestedBudget * 0.2),\n        },\n    };\n\n    return { timing, channels, budget };\n}\n\n// ============================================\n// COPY ASSETS GENERATOR (LLM)\n// ============================================\n\nasync function generateCopyAssets(input: LaunchKitInput): Promise<CopyAssets> {\n    // Get brand voice for context\n    const brandVoice = await prisma.brandVoice.findUnique({\n        where: { shopId: input.shopId },\n    });\n\n    const toneDescription = brandVoice?.toneAttributes?.join(', ') || 'professional, friendly';\n\n    const prompt = `Generate marketing copy for a new product launch.\n\nProduct: ${input.productName}\nType: ${input.productType}\nPrice: €${input.targetPrice}\nDescription: ${input.description || 'A new addition to our collection'}\nBrand Voice: ${toneDescription}\n\nGenerate:\n1. A compelling headline (max 8 words)\n2. A tagline (max 12 words)\n3. Product description (2-3 sentences)\n4. Email subject line (max 50 chars)\n5. Three social media posts (Instagram-style, with emojis)\n\nReturn as JSON with keys: headline, tagline, description, emailSubject, socialPosts (array)`;\n\n    try {\n        const openai = new OpenAI();\n        const response = await openai.chat.completions.create({\n            model: 'gpt-4o-mini',\n            messages: [{ role: 'user', content: prompt }],\n            response_format: { type: 'json_object' },\n            temperature: 0.8,\n        });\n\n        const content = response.choices[0].message.content || '{}';\n        const parsed = JSON.parse(content);\n\n        return {\n            headline: parsed.headline || `Introducing ${input.productName}`,\n            tagline: parsed.tagline || 'Your new favorite is here',\n            description: parsed.description || input.description || '',\n            emailSubject: parsed.emailSubject || `New Arrival: ${input.productName}`,\n            socialPosts: parsed.socialPosts || [\n                `✨ New drop alert! ${input.productName} is here`,\n                `Just launched: ${input.productName} 🚀`,\n                `The wait is over! Shop ${input.productName} now 🛒`,\n            ],\n        };\n    } catch (error) {\n        console.error('[LaunchKit] Copy generation failed:', error);\n        return {\n            headline: `Introducing ${input.productName}`,\n            tagline: 'Your new favorite is here',\n            description: input.description || '',\n            emailSubject: `New: ${input.productName}`,\n            socialPosts: [\n                `✨ Just launched: ${input.productName}`,\n                `New arrival alert! 🚀`,\n                `Shop our newest addition 🛒`,\n            ],\n        };\n    }\n}\n\n// ============================================\n// PRICING STRATEGY\n// ============================================\n\nasync function generatePricingStrategy(input: LaunchKitInput): Promise<PricingStrategy> {\n    const storeDNA = await prisma.storeDNA.findUnique({\n        where: { shopId: input.shopId },\n    });\n\n    const priceBands = (storeDNA as any)?.priceBands;\n\n    // Find the best performing band near target price\n    let nearestBand: any = null;\n    if (Array.isArray(priceBands) && priceBands.length > 0) {\n        nearestBand = priceBands.reduce((best: any, band: any) => {\n            const bandMid = (band.min + band.max) / 2;\n            const distance = Math.abs(bandMid - input.targetPrice);\n            if (!best || distance < best.distance) {\n                return { ...band, distance };\n            }\n            return best;\n        }, null);\n    } else if (priceBands && typeof priceBands === 'object') {\n        // Object format: { low, mid, high } - use thresholds to find nearest band\n        const bands = [\n            { band: 'budget', min: 0, max: priceBands.low || 30 },\n            { band: 'mid', min: priceBands.low || 30, max: priceBands.mid || 100 },\n            { band: 'premium', min: priceBands.mid || 100, max: priceBands.high || 200 },\n        ];\n        nearestBand = bands.reduce((best: any, band: any) => {\n            const bandMid = (band.min + band.max) / 2;\n            const distance = Math.abs(bandMid - input.targetPrice);\n            if (!best || distance < best.distance) {\n                return { ...band, distance };\n            }\n            return best;\n        }, null);\n    }\n\n    // Intro pricing (10-15% off for launch)\n    const introDiscountPercent = nearestBand?.refundRate > 10 ? 10 : 15;\n    const introPrice = Math.round(input.targetPrice * (1 - introDiscountPercent / 100) * 100) / 100;\n\n    // Get potential bundle products\n    const topProducts = await prisma.product.findMany({\n        where: { shopId: input.shopId },\n        orderBy: { createdAt: 'desc' },\n        take: 5,\n        select: { title: true },\n    });\n\n    const bundleOptions = topProducts.slice(0, 2).map((p: { title: string }, i: number) => ({\n        name: `${input.productName} + ${p.title}`,\n        products: [input.productName, p.title],\n        bundlePrice: Math.round((input.targetPrice * 1.6) * 100) / 100,\n        savings: Math.round(input.targetPrice * 0.15 * 100) / 100,\n    }));\n\n    return {\n        msrp: input.targetPrice,\n        introPrice,\n        introDiscountPercent,\n        bundleOptions,\n    };\n}\n\n// ============================================\n// SUCCESS METRICS\n// ============================================\n\nfunction generateSuccessMetrics(input: LaunchKitInput, strategy: LaunchStrategy): {\n    day7Target: { units: number; revenue: number };\n    day30Target: { units: number; revenue: number };\n    breakeven: { units: number; days: number };\n} {\n    const estimatedFirstWeekUnits = input.targetPrice > 100 ? 5 : 15;\n    const estimatedFirstMonthUnits = estimatedFirstWeekUnits * 3;\n\n    return {\n        day7Target: {\n            units: estimatedFirstWeekUnits,\n            revenue: Math.round(estimatedFirstWeekUnits * input.targetPrice),\n        },\n        day30Target: {\n            units: estimatedFirstMonthUnits,\n            revenue: Math.round(estimatedFirstMonthUnits * input.targetPrice),\n        },\n        breakeven: {\n            units: Math.ceil(strategy.budget.suggested / (input.targetPrice * 0.4)),\n            days: 30,\n        },\n    };\n}\n\n// ============================================\n// MAIN FUNCTION\n// ============================================\n\nexport async function generateLaunchKit(input: LaunchKitInput): Promise<any> {\n    console.log(`[LaunchKit] Generating kit for: ${input.productName}`);\n\n    // Generate all components\n    const [strategy, copyAssets, pricing] = await Promise.all([\n        generateLaunchStrategy(input),\n        generateCopyAssets(input),\n        generatePricingStrategy(input),\n    ]);\n\n    const successMetrics = generateSuccessMetrics(input, strategy);\n\n    // Build risk mitigation\n    const riskMitigation = {\n        topRisks: [\n            { risk: 'Low initial traction', mitigation: 'Prepare retargeting campaign', severity: 'medium' },\n            { risk: 'Price sensitivity', mitigation: 'A/B test with different intro discounts', severity: 'low' },\n            { risk: 'Supply issues', mitigation: 'Start with limited quantity messaging', severity: 'low' },\n        ],\n        mitigationSteps: [\n            'Monitor first 48 hours closely',\n            'Prepare backup creative assets',\n            'Have customer support briefed',\n        ],\n    };\n\n    // Pre-launch checklist\n    const prelaunchChecklist = [\n        { task: 'Product photography ready', status: 'pending', owner: 'Marketing', dueDate: '-7 days' },\n        { task: 'Email campaign drafted', status: 'pending', owner: 'Marketing', dueDate: '-5 days' },\n        { task: 'Social posts scheduled', status: 'pending', owner: 'Social', dueDate: '-3 days' },\n        { task: 'Inventory confirmed', status: 'pending', owner: 'Operations', dueDate: '-2 days' },\n        { task: 'Team briefed', status: 'pending', owner: 'All', dueDate: '-1 day' },\n    ];\n\n    // Save to database\n    const launchKit = await prisma.launchKit.create({\n        data: {\n            shopId: input.shopId,\n            candidateId: input.candidateId || null,\n            productName: input.productName,\n            productType: input.productType,\n            targetPrice: input.targetPrice,\n            launchStrategy: strategy as unknown as Prisma.InputJsonValue,\n            copyAssets: copyAssets as unknown as Prisma.InputJsonValue,\n            pricingStrategy: pricing as unknown as Prisma.InputJsonValue,\n            targetAudience: {\n                primaryPersona: 'Existing customers',\n                secondaryPersona: 'Social followers',\n                messaging: copyAssets.tagline,\n            } as Prisma.InputJsonValue,\n            successMetrics: successMetrics as unknown as Prisma.InputJsonValue,\n            riskMitigation: riskMitigation as unknown as Prisma.InputJsonValue,\n            prelaunchChecklist: prelaunchChecklist as unknown as Prisma.InputJsonValue,\n            status: 'draft',\n        },\n    });\n\n    console.log(`[LaunchKit] Created kit ID: ${launchKit.id}`);\n\n    return launchKit;\n}\n\n// ============================================\n// GET LAUNCH KITS\n// ============================================\n\nexport async function getLaunchKits(shopId: string): Promise<any[]> {\n    return prisma.launchKit.findMany({\n        where: { shopId },\n        orderBy: { createdAt: 'desc' },\n    });\n}\n\nexport async function getLaunchKit(id: string): Promise<any | null> {\n    return prisma.launchKit.findUnique({ where: { id } });\n}\n"],"names":[],"mappings":"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"}},
    {"offset": {"line": 4942, "column": 0}, "map": {"version":3,"sources":["file:///Users/mac/Desktop/NEW/packages/brain/src/agents/retention-agent.ts"],"sourcesContent":["/**\n * Retention Agent\n * RFM analysis, churn prediction, and retention insights\n */\n\nimport { prisma } from '@brandmind/shared';\nimport { Decimal } from '@prisma/client/runtime/library';\n\n// ============================================\n// TYPES\n// ============================================\n\ninterface RFMData {\n    customerId: string;\n    recencyScore: number;      // 1-5\n    frequencyScore: number;    // 1-5\n    monetaryScore: number;     // 1-5\n    rfmSegment: string;\n    daysSinceLastOrder: number;\n    totalOrders: number;\n    totalSpent: number;\n    avgOrderValue: number;\n    churnRisk: number;         // 0-1\n    predictedNextOrderDays: number | null;\n}\n\ntype RFMSegment =\n    | 'champions'\n    | 'loyal'\n    | 'potential_loyal'\n    | 'new'\n    | 'promising'\n    | 'need_attention'\n    | 'about_to_sleep'\n    | 'at_risk'\n    | 'hibernating'\n    | 'lost';\n\n// ============================================\n// HELPERS\n// ============================================\n\nfunction toNumber(val: Decimal | number | null | undefined): number {\n    if (val === null || val === undefined) return 0;\n    if (typeof val === 'number') return val;\n    return Number(val);\n}\n\nfunction calculateRFMScore(value: number, thresholds: number[]): number {\n    // Higher value = higher score for Frequency and Monetary\n    if (value >= thresholds[0]) return 5;\n    if (value >= thresholds[1]) return 4;\n    if (value >= thresholds[2]) return 3;\n    if (value >= thresholds[3]) return 2;\n    return 1;\n}\n\nfunction calculateRecencyScore(daysSince: number, thresholds: number[]): number {\n    // Lower days = higher score for Recency\n    if (daysSince <= thresholds[0]) return 5;\n    if (daysSince <= thresholds[1]) return 4;\n    if (daysSince <= thresholds[2]) return 3;\n    if (daysSince <= thresholds[3]) return 2;\n    return 1;\n}\n\nfunction determineSegment(r: number, f: number, m: number): RFMSegment {\n    const rfm = `${r}${f}${m}`;\n\n    // Champions: High in all dimensions\n    if (r >= 4 && f >= 4 && m >= 4) return 'champions';\n\n    // Loyal: High frequency and monetary\n    if (f >= 4 && m >= 4) return 'loyal';\n\n    // Potential Loyal: Recent with medium frequency\n    if (r >= 4 && (f === 3 || f === 4) && m >= 3) return 'potential_loyal';\n\n    // New: Very recent, low frequency\n    if (r >= 4 && f === 1) return 'new';\n\n    // Promising: Recent with low to medium frequency\n    if (r >= 3 && f <= 2 && m <= 2) return 'promising';\n\n    // Need Attention: Above average in all\n    if (r === 3 && f === 3 && m === 3) return 'need_attention';\n\n    // About to Sleep: Below average recency\n    if (r === 2 && f >= 2 && m >= 2) return 'about_to_sleep';\n\n    // At Risk: High value but haven't purchased recently\n    if (r <= 2 && f >= 3 && m >= 3) return 'at_risk';\n\n    // Hibernating: Low recency, low frequency\n    if (r <= 2 && f <= 2) return 'hibernating';\n\n    // Lost: Lowest in all\n    if (r === 1 && f === 1) return 'lost';\n\n    return 'need_attention';\n}\n\nfunction calculateChurnRisk(r: number, f: number, daysSince: number, avgFrequency: number): number {\n    // Base risk from RFM scores\n    let risk = 0;\n\n    // Recency is the strongest predictor\n    risk += (5 - r) * 0.15;\n\n    // Low frequency increases risk\n    risk += (5 - f) * 0.05;\n\n    // If days since last order exceeds average by 2x, high risk\n    if (avgFrequency > 0 && daysSince > avgFrequency * 2) {\n        risk += 0.3;\n    }\n\n    return Math.min(1, Math.max(0, risk));\n}\n\n// ============================================\n// RFM CALCULATOR\n// ============================================\n\nexport async function calculateRFM(shopId: string): Promise<RFMData[]> {\n    console.log(`[RetentionAgent] Calculating RFM for shop: ${shopId}`);\n\n    // Get all customers with orders\n    const customers = await prisma.customer.findMany({\n        where: { shopId },\n        select: { id: true, shopifyId: true },\n    });\n\n    // Get all orders grouped by customer\n    const orders = await prisma.order.findMany({\n        where: { shopId, customerId: { not: null } },\n        select: {\n            customerId: true,\n            totalPrice: true,\n            createdAt: true,\n        },\n        orderBy: { createdAt: 'desc' },\n    });\n\n    // Group orders by customer\n    const customerOrders = new Map<string, typeof orders>();\n    for (const order of orders) {\n        if (!order.customerId) continue;\n        const existing = customerOrders.get(order.customerId) || [];\n        existing.push(order);\n        customerOrders.set(order.customerId, existing);\n    }\n\n    // Calculate RFM values for each customer\n    const now = new Date();\n    const rfmValues: Array<{\n        customerId: string;\n        daysSince: number;\n        orderCount: number;\n        totalSpent: number;\n    }> = [];\n\n    for (const [customerId, custOrders] of customerOrders.entries()) {\n        if (custOrders.length === 0) continue;\n\n        const lastOrder = custOrders[0];\n        const daysSince = Math.floor((now.getTime() - lastOrder.createdAt.getTime()) / (1000 * 60 * 60 * 24));\n        const totalSpent = custOrders.reduce((sum: number, o: any) => sum + toNumber(o.totalPrice), 0);\n\n        rfmValues.push({\n            customerId,\n            daysSince,\n            orderCount: custOrders.length,\n            totalSpent,\n        });\n    }\n\n    if (rfmValues.length === 0) {\n        return [];\n    }\n\n    // Calculate percentile thresholds\n    const recencyValues = rfmValues.map(r => r.daysSince).sort((a, b) => a - b);\n    const frequencyValues = rfmValues.map(r => r.orderCount).sort((a, b) => b - a);\n    const monetaryValues = rfmValues.map(r => r.totalSpent).sort((a, b) => b - a);\n\n    const getPercentile = (arr: number[], p: number) => arr[Math.floor(arr.length * p)] || arr[0];\n\n    const recencyThresholds = [\n        getPercentile(recencyValues, 0.2),\n        getPercentile(recencyValues, 0.4),\n        getPercentile(recencyValues, 0.6),\n        getPercentile(recencyValues, 0.8),\n    ];\n\n    const frequencyThresholds = [\n        getPercentile(frequencyValues, 0.2),\n        getPercentile(frequencyValues, 0.4),\n        getPercentile(frequencyValues, 0.6),\n        getPercentile(frequencyValues, 0.8),\n    ];\n\n    const monetaryThresholds = [\n        getPercentile(monetaryValues, 0.2),\n        getPercentile(monetaryValues, 0.4),\n        getPercentile(monetaryValues, 0.6),\n        getPercentile(monetaryValues, 0.8),\n    ];\n\n    // Calculate average order frequency\n    const avgFrequency = rfmValues.reduce((sum, r) => sum + r.daysSince, 0) / rfmValues.length;\n\n    // Generate RFM data\n    const rfmData: RFMData[] = [];\n\n    for (const customer of rfmValues) {\n        const r = calculateRecencyScore(customer.daysSince, recencyThresholds);\n        const f = calculateRFMScore(customer.orderCount, frequencyThresholds);\n        const m = calculateRFMScore(customer.totalSpent, monetaryThresholds);\n\n        const segment = determineSegment(r, f, m);\n        const churnRisk = calculateChurnRisk(r, f, customer.daysSince, avgFrequency);\n\n        // Predict next order based on average frequency\n        const avgDaysBetweenOrders = customer.orderCount > 1\n            ? customer.daysSince / (customer.orderCount - 1)\n            : null;\n        const predictedNextOrderDays = avgDaysBetweenOrders\n            ? Math.max(0, Math.round(avgDaysBetweenOrders - customer.daysSince))\n            : null;\n\n        rfmData.push({\n            customerId: customer.customerId,\n            recencyScore: r,\n            frequencyScore: f,\n            monetaryScore: m,\n            rfmSegment: segment,\n            daysSinceLastOrder: customer.daysSince,\n            totalOrders: customer.orderCount,\n            totalSpent: Math.round(customer.totalSpent * 100) / 100,\n            avgOrderValue: Math.round((customer.totalSpent / customer.orderCount) * 100) / 100,\n            churnRisk: Math.round(churnRisk * 100) / 100,\n            predictedNextOrderDays,\n        });\n    }\n\n    // Save to database\n    for (const data of rfmData) {\n        await prisma.customerRFM.upsert({\n            where: {\n                id: `${shopId}-${data.customerId}`,\n            },\n            update: {\n                recencyScore: data.recencyScore,\n                frequencyScore: data.frequencyScore,\n                monetaryScore: data.monetaryScore,\n                rfmSegment: data.rfmSegment,\n                daysSinceLastOrder: data.daysSinceLastOrder,\n                totalOrders: data.totalOrders,\n                totalSpent: data.totalSpent,\n                avgOrderValue: data.avgOrderValue,\n                churnRisk: data.churnRisk,\n                predictedNextOrderDays: data.predictedNextOrderDays,\n                computedAt: new Date(),\n            },\n            create: {\n                id: `${shopId}-${data.customerId}`,\n                shopId,\n                customerId: data.customerId,\n                recencyScore: data.recencyScore,\n                frequencyScore: data.frequencyScore,\n                monetaryScore: data.monetaryScore,\n                rfmSegment: data.rfmSegment,\n                daysSinceLastOrder: data.daysSinceLastOrder,\n                totalOrders: data.totalOrders,\n                totalSpent: data.totalSpent,\n                avgOrderValue: data.avgOrderValue,\n                churnRisk: data.churnRisk,\n                predictedNextOrderDays: data.predictedNextOrderDays,\n            },\n        });\n    }\n\n    console.log(`[RetentionAgent] Calculated RFM for ${rfmData.length} customers`);\n    return rfmData;\n}\n\n// ============================================\n// RETENTION INSIGHTS\n// ============================================\n\nexport async function generateRetentionInsights(shopId: string): Promise<any[]> {\n    // First calculate RFM\n    const rfmData = await calculateRFM(shopId);\n    if (rfmData.length === 0) return [];\n\n    // Group by segment\n    const segmentGroups = new Map<string, RFMData[]>();\n    for (const data of rfmData) {\n        const existing = segmentGroups.get(data.rfmSegment) || [];\n        existing.push(data);\n        segmentGroups.set(data.rfmSegment, existing);\n    }\n\n    const insights: any[] = [];\n\n    // At-Risk Segment\n    const atRisk = segmentGroups.get('at_risk') || [];\n    if (atRisk.length > 0) {\n        const revenueAtRisk = atRisk.reduce((sum, c) => sum + c.totalSpent, 0);\n        insights.push({\n            segmentType: 'at_risk',\n            customerCount: atRisk.length,\n            revenueAtRisk,\n            avgChurnProbability: atRisk.reduce((sum, c) => sum + c.churnRisk, 0) / atRisk.length,\n            recommendedAction: 'Send win-back email campaign with personalized discount',\n            actionType: 'win_back',\n            campaignSuggestion: {\n                channel: 'email',\n                timing: 'within 7 days',\n                offer: '15% off next purchase',\n                messaging: 'We miss you! Come back for an exclusive offer',\n            },\n            expectedLift: 0.15,\n            confidence: 0.75,\n        });\n    }\n\n    // Champions\n    const champions = segmentGroups.get('champions') || [];\n    if (champions.length > 0) {\n        insights.push({\n            segmentType: 'vip',\n            customerCount: champions.length,\n            revenueAtRisk: 0,\n            recommendedAction: 'Invite to VIP program or early access',\n            actionType: 'loyalty_reward',\n            campaignSuggestion: {\n                channel: 'email',\n                timing: 'this week',\n                offer: 'Early access to new arrivals',\n                messaging: 'As a valued VIP customer, you get first look',\n            },\n            expectedLift: 0.2,\n            confidence: 0.85,\n        });\n    }\n\n    // Hibernating\n    const hibernating = segmentGroups.get('hibernating') || [];\n    if (hibernating.length > 0) {\n        insights.push({\n            segmentType: 'dormant',\n            customerCount: hibernating.length,\n            revenueAtRisk: hibernating.reduce((sum, c) => sum + c.totalSpent * 0.3, 0),\n            avgReactivationProbability: 0.1,\n            recommendedAction: 'Deep discount reactivation campaign',\n            actionType: 'win_back',\n            campaignSuggestion: {\n                channel: 'email',\n                timing: 'within 14 days',\n                offer: '25% off or free shipping',\n                messaging: 'It\\'s been a while! Here\\'s something special.',\n            },\n            expectedLift: 0.08,\n            confidence: 0.6,\n        });\n    }\n\n    // Save insights to database\n    for (const insight of insights) {\n        await prisma.retentionInsight.create({\n            data: {\n                shopId,\n                segmentType: insight.segmentType,\n                customerCount: insight.customerCount,\n                revenueAtRisk: insight.revenueAtRisk || 0,\n                churnProbability: insight.avgChurnProbability,\n                reactivationProbability: insight.avgReactivationProbability,\n                recommendedAction: insight.recommendedAction,\n                actionType: insight.actionType,\n                campaignSuggestion: insight.campaignSuggestion,\n                expectedLift: insight.expectedLift,\n                confidence: insight.confidence,\n            },\n        });\n    }\n\n    return insights;\n}\n\n// ============================================\n// SUMMARY\n// ============================================\n\nexport async function getRetentionSummary(shopId: string): Promise<{\n    totalCustomers: number;\n    segmentBreakdown: Record<string, number>;\n    atRiskCount: number;\n    revenueAtRisk: number;\n    topInsights: any[];\n}> {\n    const rfm = await prisma.customerRFM.findMany({\n        where: { shopId },\n    });\n\n    const segmentBreakdown: Record<string, number> = {};\n    let atRiskCount = 0;\n    let revenueAtRisk = 0;\n\n    for (const customer of rfm) {\n        segmentBreakdown[customer.rfmSegment] = (segmentBreakdown[customer.rfmSegment] || 0) + 1;\n        if (customer.rfmSegment === 'at_risk' || customer.rfmSegment === 'hibernating') {\n            atRiskCount++;\n            revenueAtRisk += toNumber(customer.totalSpent) * 0.3;\n        }\n    }\n\n    const insights = await prisma.retentionInsight.findMany({\n        where: { shopId, status: 'active' },\n        orderBy: { revenueAtRisk: 'desc' },\n        take: 5,\n    });\n\n    return {\n        totalCustomers: rfm.length,\n        segmentBreakdown,\n        atRiskCount,\n        revenueAtRisk: Math.round(revenueAtRisk),\n        topInsights: insights,\n    };\n}\n"],"names":[],"mappings":"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"}},
    {"offset": {"line": 5297, "column": 0}, "map": {"version":3,"sources":["file:///Users/mac/Desktop/NEW/packages/brain/src/nexthit/candidate-scorer.ts"],"sourcesContent":["/**\n * Unified Candidate Scorer\n * Single scoring pipeline that uses the deterministic formula v1.0.0\n *\n * SCORING FORMULA v1.0.0:\n * SCORE = (0.25×store_fit + 0.20×gap_fill + 0.20×trend + 0.15×margin + 0.10×competition + 0.10×seasonality)\n */\n\nimport { prisma } from '@brandmind/shared';\nimport { createHash } from 'crypto';\nimport { getTrendData, TrendResult } from '../intelligence/trends';\n\n// ============================================\n// VERSION & WEIGHTS (Single Source of Truth)\n// ============================================\n\nexport const SCORING_VERSION = '1.0.0';\n\nexport const SCORING_WEIGHTS = {\n    storeFit: 0.25,\n    gapFill: 0.20,\n    trendMomentum: 0.20,\n    marginPotential: 0.15,\n    competition: 0.10,\n    seasonalityMatch: 0.10,\n};\n\n// ============================================\n// TYPES\n// ============================================\n\nexport interface RawCandidate {\n    title: string;\n    description: string;\n    patternSource: string;\n    patternEvidence: Record<string, any>;\n    confidence: number;\n    hitType: 'safe' | 'moderate' | 'bold';\n}\n\nexport interface ScoredCandidate extends RawCandidate {\n    scores: {\n        storeFit: number;\n        gapFill: number;\n        trendMomentum: number;\n        marginPotential: number;\n        competition: number;\n        seasonalityMatch: number;\n    };\n    totalScore: number;\n    rank: number;\n    scoreExplanation: string;\n    inputHash: string;\n}\n\nexport interface ScoringContext {\n    storeDNA: any;\n    catalogGaps: any[];\n    patterns: any[];\n    existingProducts: any[];\n    seasonalityData: any[];\n    trendData: Map<string, TrendResult>;\n}\n\n// ============================================\n// MAIN SCORING FUNCTION\n// ============================================\n\nexport async function scoreAndFilterCandidates(\n    shopId: string,\n    candidates: RawCandidate[]\n): Promise<ScoredCandidate[]> {\n    console.log(`[CandidateScorer] Scoring ${candidates.length} candidates with unified formula v${SCORING_VERSION}`);\n\n    // Load all context data once\n    const context = await loadScoringContext(shopId, candidates);\n\n    const scoredCandidates: ScoredCandidate[] = [];\n\n    for (const candidate of candidates) {\n        const scores = {\n            storeFit: calculateStoreFitScore(candidate, context),\n            gapFill: calculateGapFillScore(candidate, context),\n            trendMomentum: calculateTrendMomentum(candidate, context),\n            marginPotential: calculateMarginPotential(candidate, context),\n            competition: calculateCompetitionScore(candidate, context),\n            seasonalityMatch: calculateSeasonalityMatch(candidate, context),\n        };\n\n        // Calculate weighted total score using unified formula\n        const totalScore =\n            scores.storeFit * SCORING_WEIGHTS.storeFit +\n            scores.gapFill * SCORING_WEIGHTS.gapFill +\n            scores.trendMomentum * SCORING_WEIGHTS.trendMomentum +\n            scores.marginPotential * SCORING_WEIGHTS.marginPotential +\n            scores.competition * SCORING_WEIGHTS.competition +\n            scores.seasonalityMatch * SCORING_WEIGHTS.seasonalityMatch;\n\n        const inputHash = computeInputHash(candidate, context, shopId);\n        const scoreExplanation = generateExplanation(scores, candidate);\n\n        scoredCandidates.push({\n            ...candidate,\n            scores,\n            totalScore: Math.round(totalScore * 100) / 100,\n            rank: 0,\n            scoreExplanation,\n            inputHash,\n        });\n    }\n\n    // Sort by total score and assign ranks\n    scoredCandidates.sort((a, b) => b.totalScore - a.totalScore);\n    scoredCandidates.forEach((c, i) => c.rank = i + 1);\n\n    // Return top 10\n    const top10 = scoredCandidates.slice(0, 10);\n\n    // Persist top 10 to database\n    await persistCandidates(shopId, top10);\n\n    console.log(`[CandidateScorer] Returning top 10 candidates`);\n    return top10;\n}\n\n// ============================================\n// CONTEXT LOADING\n// ============================================\n\nasync function loadScoringContext(shopId: string, candidates: RawCandidate[]): Promise<ScoringContext> {\n    const [storeDNA, catalogGaps, patterns, existingProducts] = await Promise.all([\n        prisma.storeDNA.findUnique({ where: { shopId } }),\n        prisma.catalogGap.findMany({ where: { shopId, status: 'active' } }),\n        prisma.patternMemory.findMany({ where: { shopId } }),\n        prisma.product.findMany({\n            where: { shopId },\n            select: { title: true, productType: true },\n        }),\n    ]);\n\n    const seasonalityData = (storeDNA as any)?.seasonalityCurve || [];\n\n    // Fetch trend data for candidate keywords\n    const trendData = new Map<string, TrendResult>();\n    const keywords = new Set<string>();\n\n    for (const candidate of candidates) {\n        // Extract keywords from title and evidence\n        const words = candidate.title.toLowerCase().split(/\\s+/).filter(w => w.length > 3);\n        words.forEach(w => keywords.add(w));\n\n        if (candidate.patternEvidence?.category) {\n            keywords.add(candidate.patternEvidence.category.toLowerCase());\n        }\n        if (candidate.patternEvidence?.suggestedLine) {\n            keywords.add(candidate.patternEvidence.suggestedLine.toLowerCase());\n        }\n    }\n\n    // Fetch trends for keywords (limit to 10 to avoid rate limiting)\n    const keywordsArray = Array.from(keywords).slice(0, 10);\n    for (const keyword of keywordsArray) {\n        try {\n            const trend = await getTrendData(keyword);\n            trendData.set(keyword, trend);\n        } catch (err) {\n            // Silently continue if trend fetch fails\n        }\n    }\n\n    return {\n        storeDNA: storeDNA as any,\n        catalogGaps,\n        patterns,\n        existingProducts,\n        seasonalityData,\n        trendData,\n    };\n}\n\n// ============================================\n// INDIVIDUAL SCORERS\n// ============================================\n\n/**\n * Store Fit Score - How well does this match the store's DNA patterns?\n */\nfunction calculateStoreFitScore(candidate: RawCandidate, context: ScoringContext): number {\n    const { storeDNA, patterns } = context;\n    if (!storeDNA) return 0.5;\n\n    let score = 0.5;\n    const titleLower = candidate.title.toLowerCase();\n    const source = candidate.patternSource;\n\n    // Check if candidate matches top performing types\n    const topTypes = storeDNA.topPerformingTypes || [];\n    for (const t of topTypes) {\n        const typeName = (t.type || '').toLowerCase();\n        if (titleLower.includes(typeName) || source.includes(typeName)) {\n            score += 0.25;\n            break;\n        }\n    }\n\n    // Check category affinity pattern\n    const categoryPattern = patterns.find(p => p.patternType === 'category_affinity');\n    if (categoryPattern) {\n        const topCategory = (categoryPattern.patternData as any)?.topCategory?.toLowerCase() || '';\n        if (titleLower.includes(topCategory) || source.includes(topCategory)) {\n            score += 0.15;\n        }\n    }\n\n    // Check if it matches the price sweet spot\n    const priceSweetSpot = storeDNA.priceSweetSpot?.sweetSpot || '';\n    if (priceSweetSpot) {\n        const evidence = candidate.patternEvidence;\n        if (evidence.suggestedPrice || evidence.priceRange) {\n            score += 0.1;\n        }\n    }\n\n    return Math.min(1, score);\n}\n\n/**\n * Gap Fill Score - Does this address a detected CatalogGap?\n */\nfunction calculateGapFillScore(candidate: RawCandidate, context: ScoringContext): number {\n    const { catalogGaps } = context;\n    if (!catalogGaps || catalogGaps.length === 0) return 0.3;\n\n    let maxScore = 0.3;\n    const titleLower = candidate.title.toLowerCase();\n    const source = candidate.patternSource;\n\n    for (const gap of catalogGaps) {\n        const gapData = gap.gapData || {};\n\n        // Price gap match\n        if (gap.gapType === 'price_gap') {\n            const band = (gapData.band || '').toLowerCase();\n            if (source === 'market_gap' && candidate.patternEvidence?.gapType === 'Price Void') {\n                maxScore = Math.max(maxScore, gap.gapScore * 1.2);\n            } else if (titleLower.includes('budget') && band.includes('0-25')) {\n                maxScore = Math.max(maxScore, gap.gapScore);\n            } else if (titleLower.includes('premium') && band.includes('100')) {\n                maxScore = Math.max(maxScore, gap.gapScore);\n            }\n        }\n\n        // Category gap match\n        if (gap.gapType === 'category_gap') {\n            const missingCategory = (gapData.missingCategory || '').toLowerCase();\n            if (source === 'market_gap' || source === 'category_expansion') {\n                if (titleLower.includes(missingCategory)) {\n                    maxScore = Math.max(maxScore, gap.gapScore * 1.3);\n                }\n            }\n        }\n\n        // Variant gap match\n        if (gap.gapType === 'variant_gap') {\n            const colorValue = (gapData.value || '').toLowerCase();\n            if (source === 'color_extension' && titleLower.includes(colorValue)) {\n                maxScore = Math.max(maxScore, gap.gapScore);\n            }\n        }\n    }\n\n    return Math.min(1, maxScore);\n}\n\n/**\n * Trend Momentum Score - External trend data integration\n */\nfunction calculateTrendMomentum(candidate: RawCandidate, context: ScoringContext): number {\n    const { trendData } = context;\n\n    // Find matching trend data\n    const titleWords = candidate.title.toLowerCase().split(/\\s+/);\n    let bestTrend: TrendResult | null = null;\n\n    for (const word of titleWords) {\n        const trend = trendData.get(word);\n        if (trend && (!bestTrend || trend.trendScore > bestTrend.trendScore)) {\n            bestTrend = trend;\n        }\n    }\n\n    // Also check evidence keywords\n    if (candidate.patternEvidence?.category) {\n        const trend = trendData.get(candidate.patternEvidence.category.toLowerCase());\n        if (trend && (!bestTrend || trend.trendScore > bestTrend.trendScore)) {\n            bestTrend = trend;\n        }\n    }\n\n    if (!bestTrend || bestTrend.source === 'error') {\n        // Fallback to pattern-based scoring if no external trend data\n        const source = candidate.patternSource;\n        if (source === 'market_gap') return 0.7; // Market gaps indicate demand\n        if (source === 'category_expansion') return 0.6;\n        if (source === 'color_extension') return 0.55;\n        return 0.5;\n    }\n\n    // Calculate score from trend data\n    const velocity = bestTrend.velocity;\n    const trendScore = bestTrend.trendScore;\n\n    // High trend score + positive velocity = strong momentum\n    if (trendScore > 70 && velocity > 0) {\n        return Math.min(1, 0.7 + (trendScore / 100) * 0.2 + (velocity / 50) * 0.1);\n    }\n\n    // Moderate trend score\n    if (trendScore > 40) {\n        return 0.5 + (trendScore / 100) * 0.3;\n    }\n\n    // Low or declining trend\n    if (velocity < 0) {\n        return Math.max(0.2, 0.5 + velocity / 100);\n    }\n\n    return 0.5;\n}\n\n/**\n * Margin Potential Score - Estimated profitability\n */\nfunction calculateMarginPotential(candidate: RawCandidate, context: ScoringContext): number {\n    const { storeDNA } = context;\n    const source = candidate.patternSource;\n    const titleLower = candidate.title.toLowerCase();\n\n    // Premium products typically have higher margins\n    if (titleLower.includes('premium') || titleLower.includes('luxury') || titleLower.includes('elite')) {\n        return 0.85;\n    }\n\n    // Bundles have good margin due to perceived value\n    if (source === 'bundle_merge') {\n        return 0.75;\n    }\n\n    // Check price band pattern for refund rates (proxy for quality/margin)\n    if (storeDNA?.priceBands) {\n        const priceBands = storeDNA.priceBands as any;\n        // Handle both array format (from PatternMemory) and object format (from DNA seeder)\n        if (Array.isArray(priceBands)) {\n            const lowestRefundBand = priceBands.reduce((best: any, band: any) => {\n                if (!best || (band.refundRate !== undefined && band.refundRate < best.refundRate)) return band;\n                return best;\n            }, null);\n\n            if (lowestRefundBand && candidate.patternEvidence?.priceRange?.includes(lowestRefundBand.band)) {\n                return 0.7;\n            }\n        } else if (typeof priceBands === 'object') {\n            // Object format: { low: number, mid: number, high: number }\n            // Use price positioning instead\n            const positioning = storeDNA.pricePositioning;\n            if (positioning === 'premium' || positioning === 'luxury') {\n                return 0.75;\n            }\n        }\n    }\n\n    // Category expansions have uncertain margins\n    if (source === 'category_expansion') {\n        return 0.5;\n    }\n\n    return 0.6;\n}\n\n/**\n * Competition Score - Market saturation estimate (higher = less competition = better)\n */\nfunction calculateCompetitionScore(candidate: RawCandidate, context: ScoringContext): number {\n    const { storeDNA, existingProducts } = context;\n    const titleLower = candidate.title.toLowerCase();\n    const source = candidate.patternSource;\n\n    // Check for cannibalization with existing products\n    let highestOverlap = 0;\n    for (const product of existingProducts) {\n        const existingTitle = product.title.toLowerCase();\n        const candidateWords = new Set(titleLower.split(/\\s+/).filter((w: string) => w.length > 3));\n        const existingWords = new Set(existingTitle.split(/\\s+/).filter((w: string) => w.length > 3));\n        const overlap = [...candidateWords].filter((w: string) => existingWords.has(w)).length;\n        highestOverlap = Math.max(highestOverlap, overlap);\n    }\n\n    // High overlap = competing with existing products\n    if (highestOverlap >= 3) {\n        return 0.3;\n    }\n\n    // Bundles don't compete - they complement\n    if (source === 'bundle_merge') {\n        return 0.85;\n    }\n\n    // Category expansions open new space\n    if (source === 'category_expansion' || source === 'market_gap') {\n        return 0.8;\n    }\n\n    // Check if category is growing or declining\n    if (storeDNA) {\n        const decliningTypes = storeDNA.decliningTypes || [];\n        const growingTypes = storeDNA.growingTypes || [];\n\n        for (const t of decliningTypes) {\n            if (titleLower.includes((t.type || '').toLowerCase())) {\n                return 0.35;\n            }\n        }\n\n        for (const t of growingTypes) {\n            if (titleLower.includes((t.type || '').toLowerCase())) {\n                return 0.75;\n            }\n        }\n    }\n\n    return 0.6;\n}\n\n/**\n * Seasonality Match Score - Timing alignment\n */\nfunction calculateSeasonalityMatch(candidate: RawCandidate, context: ScoringContext): number {\n    const { seasonalityData } = context;\n    const currentMonth = new Date().getMonth();\n\n    if (!seasonalityData || seasonalityData.length === 0) return 0.5;\n\n    const currentMonthData = seasonalityData.find((s: any) => s.month === currentMonth);\n    if (!currentMonthData) return 0.5;\n\n    const revenueIndex = currentMonthData.revenueIndex || 1.0;\n\n    // Peak month - great time to launch\n    if (revenueIndex > 1.2) {\n        return 0.9;\n    }\n\n    // Above average month\n    if (revenueIndex > 1.0) {\n        return 0.7;\n    }\n\n    // Slow month - launching now is riskier\n    if (revenueIndex < 0.7) {\n        return 0.4;\n    }\n\n    return 0.6;\n}\n\n// ============================================\n// HELPERS\n// ============================================\n\nfunction computeInputHash(candidate: RawCandidate, context: ScoringContext, shopId: string): string {\n    const serialized = JSON.stringify({\n        title: candidate.title,\n        source: candidate.patternSource,\n        shopId,\n        gapsCount: context.catalogGaps.length,\n        hasStoreDNA: !!context.storeDNA,\n        patternsCount: context.patterns.length,\n    });\n    return createHash('sha256').update(serialized).digest('hex').slice(0, 16);\n}\n\nfunction generateExplanation(scores: Record<string, number>, candidate: RawCandidate): string {\n    const parts: string[] = [];\n\n    if (scores.storeFit > 0.7) parts.push('Strong DNA match');\n    else if (scores.storeFit < 0.4) parts.push('Limited store fit');\n\n    if (scores.gapFill > 0.6) parts.push('fills catalog gap');\n    if (scores.trendMomentum > 0.7) parts.push('positive trend momentum');\n    else if (scores.trendMomentum < 0.4) parts.push('low market trend');\n\n    if (scores.marginPotential > 0.7) parts.push('high margin potential');\n    if (scores.competition > 0.7) parts.push('low competition');\n    else if (scores.competition < 0.4) parts.push('may overlap existing products');\n\n    if (scores.seasonalityMatch > 0.7) parts.push('good timing');\n    else if (scores.seasonalityMatch < 0.5) parts.push('off-peak timing');\n\n    return parts.length > 0 ? parts.join(', ') : 'Balanced opportunity';\n}\n\nasync function persistCandidates(shopId: string, candidates: ScoredCandidate[]) {\n    // Clear old generated candidates (keep shortlisted, analyzing, etc.)\n    await prisma.nextHitCandidate.deleteMany({\n        where: { shopId, status: 'generated' },\n    });\n\n    // Insert new top 10\n    for (const candidate of candidates) {\n        await prisma.nextHitCandidate.create({\n            data: {\n                shopId,\n                title: candidate.title,\n                description: candidate.description,\n                patternSource: candidate.patternSource,\n                patternEvidence: candidate.patternEvidence,\n                confidence: candidate.totalScore, // Use unified score as confidence\n                hitType: candidate.hitType,\n                status: 'generated',\n                scores: candidate.scores,\n                rank: candidate.rank,\n            },\n        });\n    }\n}\n"],"names":[],"mappings":"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"}},
    {"offset": {"line": 5720, "column": 0}, "map": {"version":3,"sources":["file:///Users/mac/Desktop/NEW/packages/brain/src/nexthit/deterministic-scorer.ts"],"sourcesContent":["/**\n * Deterministic Candidate Scorer\n * Enhanced scoring with SHA256 hashing, version tracking, and full audit trail\n * \n * SCORING FORMULA v1.0.0:\n * SCORE = (0.25×store_fit + 0.20×gap_fill + 0.20×trend + 0.15×margin + 0.10×competition + 0.10×seasonality)\n */\n\nimport { prisma } from '@brandmind/shared';\nimport { createHash } from 'crypto';\n\n// ============================================\n// VERSION & WEIGHTS\n// ============================================\n\n// Use weights from candidate-scorer as single source of truth\nimport { SCORING_WEIGHTS, SCORING_VERSION } from './candidate-scorer';\nexport { SCORING_WEIGHTS, SCORING_VERSION };\n\n// ============================================\n// TYPES\n// ============================================\n\nexport interface ScoringInput {\n    candidateId: string;\n    candidateTitle: string;\n    candidateType: string;\n    shopId: string;\n    storeDNA: Record<string, any> | null;\n    catalogGaps: any[];\n    trendData: any | null;\n    seasonalityData: any[];\n}\n\nexport interface ScoreBreakdown {\n    storeFitScore: number;\n    gapFillScore: number;\n    trendMomentum: number;\n    marginPotential: number;\n    competitionScore: number;\n    seasonalityMatch: number;\n    finalScore: number;\n}\n\nexport interface ScoringResult {\n    candidateId: string;\n    inputHash: string;\n    scores: ScoreBreakdown;\n    weights: typeof SCORING_WEIGHTS;\n    version: string;\n    explanation: string;\n}\n\n// ============================================\n// HASH FUNCTION\n// ============================================\n\nfunction computeInputHash(input: ScoringInput): string {\n    const serialized = JSON.stringify({\n        candidateId: input.candidateId,\n        candidateTitle: input.candidateTitle,\n        candidateType: input.candidateType,\n        shopId: input.shopId,\n        storeDNAHash: input.storeDNA ? JSON.stringify(input.storeDNA).slice(0, 500) : null,\n        gapsCount: input.catalogGaps.length,\n        hasTrend: !!input.trendData,\n        seasonalityCount: input.seasonalityData.length,\n    });\n    return createHash('sha256').update(serialized).digest('hex');\n}\n\n// ============================================\n// INDIVIDUAL SCORERS\n// ============================================\n\n/**\n * Store Fit Score - How well does this match the store's DNA patterns?\n */\nfunction calculateStoreFitScore(input: ScoringInput): number {\n    const { storeDNA, candidateType } = input;\n    if (!storeDNA) return 0.5;\n\n    let score = 0.5;\n    const dna = storeDNA as any;\n\n    // Check if candidate matches top performing types\n    const topTypes = dna.topPerformingTypes || [];\n    if (topTypes.some((t: any) => t.type?.toLowerCase().includes(candidateType.toLowerCase()))) {\n        score += 0.3;\n    }\n\n    // Check if it matches the price sweet spot\n    const priceSweetSpot = dna.priceSweetSpot?.sweetSpot || '';\n    if (priceSweetSpot && candidateType.includes('Premium')) {\n        score += 0.1;\n    }\n\n    // Check vendor concentration - if low, new vendors are encouraged\n    const vendorConcentration = dna.vendorConcentration || 0;\n    if (vendorConcentration > 0.5) {\n        score += 0.1; // Encourage diversification\n    }\n\n    return Math.min(1, score);\n}\n\n/**\n * Gap Fill Score - Does this address a detected CatalogGap?\n */\nfunction calculateGapFillScore(input: ScoringInput): number {\n    const { catalogGaps, candidateTitle, candidateType } = input;\n    if (!catalogGaps || catalogGaps.length === 0) return 0.3;\n\n    let maxScore = 0.3;\n    const titleLower = candidateTitle.toLowerCase();\n    const typeLower = candidateType.toLowerCase();\n\n    for (const gap of catalogGaps) {\n        const gapData = gap.gapData || {};\n\n        // Price gap match\n        if (gap.gapType === 'price_gap') {\n            const band = gapData.band?.toLowerCase() || '';\n            if (titleLower.includes('budget') && band.includes('0-25')) {\n                maxScore = Math.max(maxScore, gap.gapScore);\n            } else if (titleLower.includes('premium') && band.includes('100')) {\n                maxScore = Math.max(maxScore, gap.gapScore);\n            }\n        }\n\n        // Category gap match\n        if (gap.gapType === 'category_gap') {\n            const missingCategory = gapData.missingCategory?.toLowerCase() || '';\n            if (typeLower.includes(missingCategory)) {\n                maxScore = Math.max(maxScore, gap.gapScore * 1.2);\n            }\n        }\n\n        // Variant gap match\n        if (gap.gapType === 'variant_gap') {\n            const colorValue = gapData.value?.toLowerCase() || '';\n            if (titleLower.includes(colorValue)) {\n                maxScore = Math.max(maxScore, gap.gapScore);\n            }\n        }\n    }\n\n    return Math.min(1, maxScore);\n}\n\n/**\n * Trend Momentum Score - External trend data if available\n */\nfunction calculateTrendMomentum(input: ScoringInput): number {\n    const { trendData } = input;\n    if (!trendData) return 0.5; // Neutral if no trend data\n\n    const velocity = trendData.velocity || 0;\n    const acceleration = trendData.acceleration || 0;\n\n    // Positive velocity with positive acceleration = strong momentum\n    if (velocity > 0 && acceleration > 0) {\n        return Math.min(1, 0.6 + velocity * 0.3 + acceleration * 0.1);\n    }\n\n    // Positive velocity but slowing\n    if (velocity > 0 && acceleration <= 0) {\n        return 0.5 + velocity * 0.2;\n    }\n\n    // Negative velocity = declining trend\n    if (velocity < 0) {\n        return Math.max(0.1, 0.5 + velocity * 0.3);\n    }\n\n    return 0.5;\n}\n\n/**\n * Margin Potential Score - Estimated profitability\n */\nfunction calculateMarginPotential(input: ScoringInput): number {\n    const { storeDNA, candidateType } = input;\n    if (!storeDNA) return 0.5;\n\n    const priceBands = (storeDNA as any).priceBands;\n\n    // Premium products typically have higher margins\n    if (candidateType.toLowerCase().includes('premium')) {\n        return 0.8;\n    }\n\n    // Find the band with lowest refund rate (indicates quality)\n    if (Array.isArray(priceBands) && priceBands.length > 0) {\n        const lowestRefundBand = priceBands.reduce((best: any, band: any) => {\n            if (!best || (band.refundRate !== undefined && band.refundRate < best.refundRate)) return band;\n            return best;\n        }, null);\n\n        if (lowestRefundBand && candidateType.includes(lowestRefundBand.band)) {\n            return 0.7;\n        }\n    } else if (priceBands && typeof priceBands === 'object') {\n        // Object format from dna-seeder: { low, mid, high }\n        const positioning = (storeDNA as any).pricePositioning;\n        if (positioning === 'premium' || positioning === 'luxury') {\n            return 0.7;\n        }\n    }\n\n    return 0.5;\n}\n\n/**\n * Competition Score - Market saturation estimate (higher = less competition = better)\n */\nfunction calculateCompetitionScore(input: ScoringInput): number {\n    const { storeDNA, candidateType } = input;\n    if (!storeDNA) return 0.5;\n\n    const topTypes = (storeDNA as any).topPerformingTypes || [];\n    const decliningTypes = (storeDNA as any).decliningTypes || [];\n\n    // If the category is declining, there might be over-saturation\n    if (decliningTypes.some((t: any) => t.type?.toLowerCase().includes(candidateType.toLowerCase()))) {\n        return 0.3;\n    }\n\n    // If category is growing, good opportunity\n    const growingTypes = (storeDNA as any).growingTypes || [];\n    if (growingTypes.some((t: any) => t.type?.toLowerCase().includes(candidateType.toLowerCase()))) {\n        return 0.8;\n    }\n\n    // Check catalog health - higher health = more competitive market\n    const catalogHealth = (storeDNA as any).catalogHealthScore || 50;\n    return catalogHealth > 70 ? 0.4 : 0.6;\n}\n\n/**\n * Seasonality Match Score - Timing alignment\n */\nfunction calculateSeasonalityMatch(input: ScoringInput): number {\n    const { seasonalityData, candidateType } = input;\n    const currentMonth = new Date().getMonth();\n\n    if (!seasonalityData || seasonalityData.length === 0) return 0.5;\n\n    const currentMonthData = seasonalityData.find((s: any) => s.month === currentMonth);\n    if (!currentMonthData) return 0.5;\n\n    // If current month is a peak month, launching now is good\n    if (currentMonthData.revenueIndex > 1.2) {\n        return 0.9;\n    }\n\n    // If current month is slow, might want to wait\n    if (currentMonthData.revenueIndex < 0.7) {\n        return 0.4;\n    }\n\n    return 0.6;\n}\n\n// ============================================\n// MAIN SCORING FUNCTION\n// ============================================\n\nexport async function scoreCandidate(input: ScoringInput): Promise<ScoringResult> {\n    // Calculate input hash for reproducibility\n    const inputHash = computeInputHash(input);\n\n    // Calculate all individual scores\n    const storeFitScore = calculateStoreFitScore(input);\n    const gapFillScore = calculateGapFillScore(input);\n    const trendMomentum = calculateTrendMomentum(input);\n    const marginPotential = calculateMarginPotential(input);\n    const competitionScore = calculateCompetitionScore(input);\n    const seasonalityMatch = calculateSeasonalityMatch(input);\n\n    // Calculate weighted final score\n    const finalScore =\n        storeFitScore * SCORING_WEIGHTS.storeFit +\n        gapFillScore * SCORING_WEIGHTS.gapFill +\n        trendMomentum * SCORING_WEIGHTS.trendMomentum +\n        marginPotential * SCORING_WEIGHTS.marginPotential +\n        competitionScore * SCORING_WEIGHTS.competition +\n        seasonalityMatch * SCORING_WEIGHTS.seasonalityMatch;\n\n    const scores: ScoreBreakdown = {\n        storeFitScore: Math.round(storeFitScore * 100) / 100,\n        gapFillScore: Math.round(gapFillScore * 100) / 100,\n        trendMomentum: Math.round(trendMomentum * 100) / 100,\n        marginPotential: Math.round(marginPotential * 100) / 100,\n        competitionScore: Math.round(competitionScore * 100) / 100,\n        seasonalityMatch: Math.round(seasonalityMatch * 100) / 100,\n        finalScore: Math.round(finalScore * 100) / 100,\n    };\n\n    // Generate explanation\n    const explanation = generateScoringExplanation(scores);\n\n    return {\n        candidateId: input.candidateId,\n        inputHash,\n        scores,\n        weights: SCORING_WEIGHTS,\n        version: SCORING_VERSION,\n        explanation,\n    };\n}\n\n/**\n * Score and persist audit trail\n */\nexport async function scoreCandidateWithAudit(input: ScoringInput): Promise<ScoringResult> {\n    const result = await scoreCandidate(input);\n\n    // Persist to ScoringAudit table\n    await prisma.scoringAudit.create({\n        data: {\n            candidateId: input.candidateId,\n            inputHash: result.inputHash,\n            storeFitScore: result.scores.storeFitScore,\n            gapFillScore: result.scores.gapFillScore,\n            trendMomentum: result.scores.trendMomentum,\n            marginPotential: result.scores.marginPotential,\n            competitionScore: result.scores.competitionScore,\n            seasonalityMatch: result.scores.seasonalityMatch,\n            weights: result.weights,\n            finalScore: result.scores.finalScore,\n            version: result.version,\n            inputSnapshot: {\n                candidateTitle: input.candidateTitle,\n                candidateType: input.candidateType,\n                shopId: input.shopId,\n                gapsCount: input.catalogGaps.length,\n                hasTrend: !!input.trendData,\n            },\n        },\n    });\n\n    return result;\n}\n\n/**\n * Batch score multiple candidates\n */\nexport async function scoreCandidates(\n    shopId: string,\n    candidates: Array<{ id: string; title: string; productType: string }>\n): Promise<ScoringResult[]> {\n    // Load shared context once\n    const [storeDNA, catalogGaps] = await Promise.all([\n        prisma.storeDNA.findUnique({ where: { shopId } }),\n        prisma.catalogGap.findMany({ where: { shopId, status: 'active' } }),\n    ]);\n\n    const seasonalityData = (storeDNA as any)?.seasonalityCurve || [];\n\n    const results: ScoringResult[] = [];\n\n    for (const candidate of candidates) {\n        const input: ScoringInput = {\n            candidateId: candidate.id,\n            candidateTitle: candidate.title,\n            candidateType: candidate.productType || 'Unknown',\n            shopId,\n            storeDNA: storeDNA as any,\n            catalogGaps,\n            trendData: null, // Would be fetched from TrendData table in production\n            seasonalityData,\n        };\n\n        const result = await scoreCandidateWithAudit(input);\n        results.push(result);\n    }\n\n    // Sort by final score\n    results.sort((a, b) => b.scores.finalScore - a.scores.finalScore);\n\n    return results;\n}\n\n// ============================================\n// HELPERS\n// ============================================\n\nfunction generateScoringExplanation(scores: ScoreBreakdown): string {\n    const parts: string[] = [];\n\n    if (scores.storeFitScore > 0.7) parts.push('Strong store DNA match');\n    else if (scores.storeFitScore < 0.4) parts.push('Limited store fit');\n\n    if (scores.gapFillScore > 0.6) parts.push('fills catalog gap');\n    if (scores.trendMomentum > 0.7) parts.push('positive trend momentum');\n    if (scores.marginPotential > 0.7) parts.push('high margin potential');\n    if (scores.competitionScore > 0.7) parts.push('low competition');\n    if (scores.seasonalityMatch > 0.7) parts.push('good timing');\n\n    return parts.length > 0 ? parts.join(', ') : 'Balanced opportunity';\n}\n"],"names":[],"mappings":"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"}},
    {"offset": {"line": 6024, "column": 0}, "map": {"version":3,"sources":["file:///Users/mac/Desktop/NEW/packages/brain/src/nexthit/candidate-generator.ts"],"sourcesContent":["import { prisma } from '@brandmind/shared';\nimport { researchNewProducts } from '../intelligence/product-research';\n\ninterface RawCandidate {\n    title: string;\n    description: string;\n    patternSource: string;\n    patternEvidence: Record<string, any>;\n    confidence: number;\n    hitType: 'safe' | 'moderate' | 'bold';\n}\n\ninterface StoreDNAData {\n    topPerformingTypes: Array<{\n        type: string;\n        revenue: number;\n        growthRate: number;\n        revenueShare: number;\n        avgOrderValue: number;\n    }>;\n    priceSweetSpot: { sweetSpot: string };\n    priceBands?: Array<{ label: string; min: number; max: number; count: number }>;\n}\n\ninterface ColorWinner {\n    value: string;\n    revenue: number;\n    sampleSize: number;\n    successRate: number;\n}\n\ninterface CrossPurchasePair {\n    count: number;\n    products: string[];\n}\n\nexport async function generateCandidates(shopId: string): Promise<RawCandidate[]> {\n    console.log(`[CandidateGenerator] Generating candidates for shop ${shopId}`);\n\n    const candidates: RawCandidate[] = [];\n\n    // Load StoreDNA for context\n    const storeDNA = await prisma.storeDNA.findUnique({ where: { shopId } });\n    const dnaData = storeDNA as unknown as StoreDNAData | null;\n\n    // Load all pattern memories\n    const patterns = await prisma.patternMemory.findMany({\n        where: { shopId },\n    });\n    const patternMap = new Map(patterns.map(p => [p.patternType, p]));\n\n    // Load top-performing products for reference\n    const topProducts = await getTopProducts(shopId);\n\n    // Strategy 1: Color + Product Type Combinations (Highest confidence - data-driven)\n    const colorProductCandidates = generateColorProductCombinations(dnaData, patternMap);\n    candidates.push(...colorProductCandidates);\n\n    // Strategy 2: Price-Optimized Products (specific price points for specific products)\n    const priceOptimizedCandidates = generatePriceOptimizedCandidates(dnaData, patternMap);\n    candidates.push(...priceOptimizedCandidates);\n\n    // Strategy 3: Cross-Purchase Bundle Opportunities\n    const bundleCandidates = generateBundleCandidates(patternMap);\n    candidates.push(...bundleCandidates);\n\n    // Strategy 4: Growth Category Expansion\n    const growthCandidates = generateGrowthCategoryCandidates(dnaData);\n    candidates.push(...growthCandidates);\n\n    // Strategy 5: Gap Fillers (price gaps, seasonal gaps)\n    const gapCandidates = await generateGapCandidates(shopId, dnaData);\n    candidates.push(...gapCandidates);\n\n    // Strategy 6: Variant Expansion based on top sellers\n    const variantCandidates = generateVariantExpansionCandidates(topProducts, patternMap);\n    candidates.push(...variantCandidates);\n\n    // Strategy 7: AI-Researched NEW Product Ideas (External Market Intelligence)\n    try {\n        const aiResearchCandidates = await generateAIResearchedCandidates(shopId);\n        candidates.push(...aiResearchCandidates);\n    } catch (error) {\n        console.error('[CandidateGenerator] AI research failed, continuing with internal data:', error);\n    }\n\n    console.log(`[CandidateGenerator] Generated ${candidates.length} raw candidates`);\n\n    return candidates;\n}\n\n/**\n * Strategy 1: Combine winning colors with top product types\n * e.g., \"Launch Palazzo Pants in Olive\" or \"Launch Haremshosen in Gold\"\n */\nfunction generateColorProductCombinations(\n    dnaData: StoreDNAData | null,\n    patternMap: Map<string, any>\n): RawCandidate[] {\n    const candidates: RawCandidate[] = [];\n\n    if (!dnaData?.topPerformingTypes?.length) return candidates;\n\n    const colorPattern = patternMap.get('color_preference');\n    if (!colorPattern) return candidates;\n\n    const winningColors: ColorWinner[] = (colorPattern.patternData as any)?.winners || [];\n    // Filter out generic \"Other\" type - only use actual product types\n    const topTypes = dnaData.topPerformingTypes\n        .filter(t => t.type && t.type !== 'Other' && t.type !== 'Uncategorized')\n        .slice(0, 3);\n\n    // Combine top 2 colors with top 2 product types\n    for (const color of winningColors.slice(0, 2)) {\n        for (const productType of topTypes.slice(0, 2)) {\n            const title = `Launch ${productType.type} in ${capitalizeFirst(color.value)}`;\n\n            candidates.push({\n                title,\n                description: `Combine your best-performing product type (${productType.type}, ${productType.revenueShare.toFixed(1)}% of revenue) with your winning color (${color.value}, ${(color.successRate * 100).toFixed(0)}% success rate). This is a data-backed safe bet.`,\n                patternSource: 'color_product_combination',\n                patternEvidence: {\n                    productType: productType.type,\n                    productTypeRevenue: productType.revenue,\n                    productTypeShare: productType.revenueShare,\n                    color: color.value,\n                    colorSuccessRate: (color.successRate * 100).toFixed(1) + '%',\n                    colorRevenue: color.revenue,\n                    colorSampleSize: color.sampleSize,\n                    combinedConfidence: (color.successRate * 0.5 + (productType.revenueShare / 100) * 0.5).toFixed(2),\n                },\n                confidence: Math.min(0.92, color.successRate * 0.5 + (productType.revenueShare / 100) * 0.5),\n                hitType: 'safe',\n            });\n        }\n    }\n\n    return candidates;\n}\n\n/**\n * Strategy 2: Price-optimized product suggestions\n * e.g., \"Launch Premium Haremshosen at €85-95\" targeting optimal price bands\n */\nfunction generatePriceOptimizedCandidates(\n    dnaData: StoreDNAData | null,\n    patternMap: Map<string, any>\n): RawCandidate[] {\n    const candidates: RawCandidate[] = [];\n\n    const pricePattern = patternMap.get('price_band');\n    if (!pricePattern) return candidates;\n\n    const priceData = pricePattern.patternData as any;\n    const optimalBand = priceData?.optimalBand;\n    const winners = priceData?.winners || [];\n\n    const priceRanges: Record<string, { min: number; max: number; tier: string }> = {\n        'budget': { min: 15, max: 30, tier: 'Entry-Level' },\n        'value': { min: 30, max: 60, tier: 'Value' },\n        'mid': { min: 60, max: 100, tier: 'Mid-Range' },\n        'premium': { min: 100, max: 200, tier: 'Premium' },\n        'luxury': { min: 200, max: 400, tier: 'Luxury' },\n    };\n\n    const range = priceRanges[optimalBand] || priceRanges['value'];\n\n    // Filter out generic types - only use actual product types\n    const validTypes = (dnaData?.topPerformingTypes || [])\n        .filter(t => t.type && t.type !== 'Other' && t.type !== 'Uncategorized');\n\n    // If no valid product types, skip this strategy\n    if (!validTypes.length) return candidates;\n\n    const topType = validTypes[0];\n    const secondType = validTypes[1];\n\n    // Suggest optimal price point for top product type\n    candidates.push({\n        title: `Launch ${range.tier} ${topType.type} at €${range.min}-${range.max}`,\n        description: `Your customers convert best in the ${optimalBand} price band (${range.min}-${range.max}€). Launch a ${topType.type} specifically designed for this sweet spot to maximize conversion.`,\n        patternSource: 'price_optimization',\n        patternEvidence: {\n            optimalBand,\n            priceRange: `€${range.min}-${range.max}`,\n            targetProductType: topType.type,\n            bandSuccessRate: winners.find((w: any) => w.value === optimalBand)?.successRate || 0.85,\n            sampleSize: pricePattern.sampleSize,\n        },\n        confidence: (pricePattern.confidence || 0.7) * 0.9,\n        hitType: 'safe',\n    });\n\n    // If there's a second product type with good growth, suggest for that too\n    if (secondType && secondType.growthRate > 10) {\n        candidates.push({\n            title: `Launch ${range.tier} ${secondType.type} at €${range.min}-${range.max}`,\n            description: `${secondType.type} is growing at ${secondType.growthRate.toFixed(0)}% and would benefit from a product at your optimal ${optimalBand} price point.`,\n            patternSource: 'price_optimization',\n            patternEvidence: {\n                optimalBand,\n                priceRange: `€${range.min}-${range.max}`,\n                targetProductType: secondType.type,\n                growthRate: secondType.growthRate,\n            },\n            confidence: (pricePattern.confidence || 0.7) * 0.75,\n            hitType: 'moderate',\n        });\n    }\n\n    return candidates;\n}\n\n/**\n * Strategy 3: Bundle candidates based on cross-purchase patterns\n * e.g., \"Create Bundle: Haremshose Tiefsee + Haremshose Schwarz\"\n */\nfunction generateBundleCandidates(patternMap: Map<string, any>): RawCandidate[] {\n    const candidates: RawCandidate[] = [];\n\n    const crossPurchase = patternMap.get('cross_purchase');\n    if (!crossPurchase) return candidates;\n\n    const topPairs: CrossPurchasePair[] = (crossPurchase.patternData as any)?.topPairs || [];\n\n    for (const pair of topPairs.slice(0, 3)) {\n        if (pair.products.length < 2) continue;\n\n        const product1 = shortenProductName(pair.products[0]);\n        const product2 = shortenProductName(pair.products[1]);\n\n        candidates.push({\n            title: `Create Bundle: ${product1} + ${product2}`,\n            description: `${pair.count} customers already buy these together. A pre-made bundle captures this demand with higher AOV and no new inventory risk.`,\n            patternSource: 'bundle_opportunity',\n            patternEvidence: {\n                product1: pair.products[0],\n                product2: pair.products[1],\n                coOccurrenceCount: pair.count,\n                bundleType: 'duo',\n                inventoryRisk: 'none',\n            },\n            confidence: Math.min(0.9, 0.6 + (pair.count / 100)),\n            hitType: 'safe',\n        });\n    }\n\n    return candidates;\n}\n\n/**\n * Strategy 4: Growth category expansion\n * e.g., \"Expand Rock Collection\" (264% growth rate)\n */\nfunction generateGrowthCategoryCandidates(dnaData: StoreDNAData | null): RawCandidate[] {\n    const candidates: RawCandidate[] = [];\n\n    if (!dnaData?.topPerformingTypes?.length) return candidates;\n\n    // Find categories with high growth but lower revenue share (expansion opportunity)\n    // Filter out generic \"Other\" type\n    const growthOpportunities = dnaData.topPerformingTypes\n        .filter(t => t.type && t.type !== 'Other' && t.type !== 'Uncategorized')\n        .filter(t => t.growthRate > 20 && t.revenueShare < 15)\n        .sort((a, b) => b.growthRate - a.growthRate);\n\n    for (const category of growthOpportunities.slice(0, 2)) {\n        candidates.push({\n            title: `Expand ${category.type} Collection`,\n            description: `${category.type} is growing at ${category.growthRate.toFixed(0)}% but only represents ${category.revenueShare.toFixed(1)}% of revenue. Expanding this line captures growing demand.`,\n            patternSource: 'growth_expansion',\n            patternEvidence: {\n                category: category.type,\n                growthRate: category.growthRate,\n                currentRevenueShare: category.revenueShare,\n                currentRevenue: category.revenue,\n                avgOrderValue: category.avgOrderValue,\n                potential: 'high_growth_underserved',\n            },\n            confidence: Math.min(0.85, 0.5 + (category.growthRate / 200)),\n            hitType: 'moderate',\n        });\n    }\n\n    return candidates;\n}\n\n/**\n * Strategy 5: Gap-based candidates (price gaps, seasonal gaps)\n */\nasync function generateGapCandidates(\n    shopId: string,\n    dnaData: StoreDNAData | null\n): Promise<RawCandidate[]> {\n    const candidates: RawCandidate[] = [];\n\n    const gaps = await prisma.catalogGap.findMany({\n        where: { shopId, status: 'active' },\n        orderBy: { gapScore: 'desc' },\n        take: 5,\n    });\n\n    // Get first valid product type (not \"Other\")\n    const validTypes = (dnaData?.topPerformingTypes || [])\n        .filter(t => t.type && t.type !== 'Other' && t.type !== 'Uncategorized');\n    const topType = validTypes[0]?.type || 'Product';\n\n    for (const gap of gaps) {\n        const data = gap.gapData as any;\n\n        if (gap.gapType === 'price_gap') {\n            candidates.push({\n                title: `Launch ${topType} in ${data.band} Price Range`,\n                description: `You have only ${data.currentProducts} products in the ${data.band} range, but ${data.adjacentDemand} orders came from adjacent price bands. There's unmet demand here.`,\n                patternSource: 'price_gap',\n                patternEvidence: {\n                    gapType: 'price_void',\n                    priceRange: data.band,\n                    currentProducts: data.currentProducts,\n                    adjacentDemand: data.adjacentDemand,\n                    suggestedProductType: topType,\n                },\n                confidence: gap.confidence,\n                hitType: 'moderate',\n            });\n        } else if (gap.gapType === 'seasonal_gap') {\n            candidates.push({\n                title: `Launch ${data.month} Seasonal ${topType}`,\n                description: `${data.month} underperforms at ${(data.revenueIndex * 100).toFixed(0)}% of average. A seasonal collection or promotion could lift this period.`,\n                patternSource: 'seasonal_gap',\n                patternEvidence: {\n                    gapType: 'seasonal_weakness',\n                    month: data.month,\n                    revenueIndex: data.revenueIndex,\n                    currentRevenue: data.currentRevenue,\n                    averageRevenue: data.averageRevenue,\n                },\n                confidence: gap.confidence * 0.8,\n                hitType: 'bold',\n            });\n        }\n    }\n\n    return candidates;\n}\n\n/**\n * Strategy 6: Variant expansion based on top sellers\n * e.g., \"Launch Long Version of top-selling Haremshose\"\n */\nfunction generateVariantExpansionCandidates(\n    topProducts: any[],\n    patternMap: Map<string, any>\n): RawCandidate[] {\n    const candidates: RawCandidate[] = [];\n\n    if (!topProducts.length) return candidates;\n\n    // Get color preferences\n    const colorPattern = patternMap.get('color_preference');\n    const winningColors: ColorWinner[] = (colorPattern?.patternData as any)?.winners || [];\n    const topColor = winningColors[0]?.value;\n\n    // Find top seller that could have variants\n    const topSeller = topProducts[0];\n    if (topSeller && topSeller.revenue > 1000) {\n        // Check if it's a \"Long Version\" or regular\n        const isLongVersion = topSeller.title.toLowerCase().includes('long');\n        const variantSuggestion = isLongVersion ? 'Short Version' : 'Long Version';\n\n        candidates.push({\n            title: `Launch ${variantSuggestion} of ${shortenProductName(topSeller.title)}`,\n            description: `Your top seller \"${shortenProductName(topSeller.title)}\" (€${topSeller.revenue.toFixed(0)} revenue) could have a ${variantSuggestion} to capture different customer preferences.`,\n            patternSource: 'variant_expansion',\n            patternEvidence: {\n                baseProduct: topSeller.title,\n                baseRevenue: topSeller.revenue,\n                baseUnits: topSeller.unitsSold,\n                suggestedVariant: variantSuggestion,\n            },\n            confidence: 0.75,\n            hitType: 'safe',\n        });\n\n        // If we have a winning color, suggest that color for a different top product\n        if (topColor && topProducts[1]) {\n            const secondProduct = topProducts[1];\n            if (!secondProduct.title.toLowerCase().includes(topColor.toLowerCase())) {\n                candidates.push({\n                    title: `Launch ${shortenProductName(secondProduct.title)} in ${capitalizeFirst(topColor)}`,\n                    description: `${capitalizeFirst(topColor)} has a ${(winningColors[0].successRate * 100).toFixed(0)}% success rate. Apply this winning color to \"${shortenProductName(secondProduct.title)}\" for a low-risk variant.`,\n                    patternSource: 'color_variant',\n                    patternEvidence: {\n                        baseProduct: secondProduct.title,\n                        suggestedColor: topColor,\n                        colorSuccessRate: winningColors[0].successRate,\n                    },\n                    confidence: winningColors[0].successRate * 0.8,\n                    hitType: 'safe',\n                });\n            }\n        }\n    }\n\n    return candidates;\n}\n\n/**\n * Strategy 7: AI-Researched NEW Product Ideas\n * Uses external market intelligence + AI to suggest genuinely new products\n */\nasync function generateAIResearchedCandidates(shopId: string): Promise<RawCandidate[]> {\n    console.log('[CandidateGenerator] Running AI product research...');\n\n    const researchResults = await researchNewProducts(shopId);\n    const candidates: RawCandidate[] = [];\n\n    for (const result of researchResults) {\n        // Determine hit type based on risk level\n        const hitType: 'safe' | 'moderate' | 'bold' =\n            result.riskLevel === 'low' ? 'safe' :\n            result.riskLevel === 'high' ? 'bold' : 'moderate';\n\n        candidates.push({\n            title: `NEW: ${result.productIdea}`,\n            description: result.reasoning,\n            patternSource: 'ai_market_research',\n            patternEvidence: {\n                source: 'AI Market Research',\n                productType: result.productType,\n                targetPrice: `€${result.targetPrice}`,\n                trendScore: result.marketEvidence.trendScore,\n                searchVolume: result.marketEvidence.searchVolume,\n                competitorGap: result.marketEvidence.competitorGap,\n                seasonalRelevance: result.marketEvidence.seasonalRelevance,\n                differentiators: result.differentiators,\n                riskLevel: result.riskLevel,\n            },\n            confidence: result.confidence,\n            hitType,\n        });\n    }\n\n    console.log(`[CandidateGenerator] AI research generated ${candidates.length} new product ideas`);\n    return candidates;\n}\n\n// ============================================\n// HELPER FUNCTIONS\n// ============================================\n\nasync function getTopProducts(shopId: string) {\n    const last30Days = new Date();\n    last30Days.setDate(last30Days.getDate() - 30);\n\n    const metrics = await prisma.productMetric.groupBy({\n        by: ['variantId'],\n        where: {\n            date: { gte: last30Days },\n            variant: { product: { shopId } },\n        },\n        _sum: { revenue: true, unitsSold: true },\n        orderBy: { _sum: { revenue: 'desc' } },\n        take: 20,\n    });\n\n    const products = await Promise.all(\n        metrics.map(async (m) => {\n            const variant = await prisma.variant.findUnique({\n                where: { id: m.variantId },\n                include: { product: true },\n            });\n            return {\n                variantId: m.variantId,\n                title: variant?.product.title || 'Unknown',\n                variantTitle: variant?.title || '',\n                productType: variant?.product.productType || 'General',\n                price: Number(variant?.price || 0),\n                revenue: Number(m._sum.revenue || 0),\n                unitsSold: m._sum.unitsSold || 0,\n            };\n        })\n    );\n\n    return products;\n}\n\nfunction capitalizeFirst(str: string): string {\n    return str.charAt(0).toUpperCase() + str.slice(1).toLowerCase();\n}\n\nfunction shortenProductName(name: string): string {\n    // Remove common prefixes and shorten for readability\n    const shortened = name\n        .replace(/^(Warme Loungewear |Warme |Mystery )/i, '')\n        .replace(/ Long Version$/i, ' (Long)')\n        .replace(/ Short Version$/i, ' (Short)');\n\n    // Truncate if still too long\n    if (shortened.length > 40) {\n        return shortened.substring(0, 37) + '...';\n    }\n    return shortened;\n}\n"],"names":[],"mappings":"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"}},
    {"offset": {"line": 6456, "column": 0}, "map": {"version":3,"sources":["file:///Users/mac/Desktop/NEW/packages/brain/src/nexthit/deep-analyzer.ts"],"sourcesContent":["import { prisma } from '@brandmind/shared';\nimport { Prisma } from '@prisma/client';\n\ninterface RiskLevel {\n    level: 'low' | 'moderate' | 'high';\n    score: number;\n    evidence: string;\n    confidence: number;\n    category: 'internal' | 'external';\n}\n\ninterface RevenueScenario {\n    label: string;\n    revenue: number;\n    units: number;\n    assumptions: string[];\n    probability: number;\n}\n\ninterface TestPath {\n    type: string;\n    description: string;\n    successCriteria: string;\n    stopConditions: string;\n    dataLearned: string;\n    investmentRequired: string;\n}\n\nexport async function runDeepAnalysis(candidateId: string) {\n    const candidate = await prisma.nextHitCandidate.findUnique({\n        where: { id: candidateId },\n        include: {\n            shop: {\n                include: {\n                    products: { include: { variants: true } },\n                    goals: { orderBy: { createdAt: 'desc' }, take: 1 },\n                },\n            },\n        },\n    });\n\n    if (!candidate) throw new Error('Candidate not found');\n\n    const shopId = candidate.shopId;\n    const patterns = await prisma.patternMemory.findMany({ where: { shopId } });\n    const goal = candidate.shop.goals[0];\n\n    // 1. Multi-dimensional risk decomposition\n    const demandRisk = assessDemandRisk(candidate, patterns);\n    const refundRisk = assessRefundRisk(candidate, patterns);\n    const brandRisk = assessBrandRisk(candidate, patterns);\n    const operationalRisk = assessOperationalRisk(candidate);\n    const cannibalizationRisk = assessCannibalizationRisk(candidate, candidate.shop.products);\n\n    // 2. Revenue scenarios\n    const revenueScenarios = generateRevenueScenarios(candidate, patterns);\n\n    // 3. Test path recommendation\n    const testPath = recommendTestPath(candidate, revenueScenarios);\n\n    // Persist the analysis\n    const analysis = await prisma.nextHitAnalysis.upsert({\n        where: { candidateId },\n        update: {\n            demandRisk: demandRisk as unknown as Prisma.InputJsonValue,\n            refundRisk: refundRisk as unknown as Prisma.InputJsonValue,\n            brandRisk: brandRisk as unknown as Prisma.InputJsonValue,\n            operationalRisk: operationalRisk as unknown as Prisma.InputJsonValue,\n            cannibalizationRisk: cannibalizationRisk as unknown as Prisma.InputJsonValue,\n            revenueScenarios: revenueScenarios as unknown as Prisma.InputJsonValue,\n            testPath: testPath as unknown as Prisma.InputJsonValue,\n        },\n        create: {\n            candidateId,\n            demandRisk: demandRisk as unknown as Prisma.InputJsonValue,\n            refundRisk: refundRisk as unknown as Prisma.InputJsonValue,\n            brandRisk: brandRisk as unknown as Prisma.InputJsonValue,\n            operationalRisk: operationalRisk as unknown as Prisma.InputJsonValue,\n            cannibalizationRisk: cannibalizationRisk as unknown as Prisma.InputJsonValue,\n            revenueScenarios: revenueScenarios as unknown as Prisma.InputJsonValue,\n            testPath: testPath as unknown as Prisma.InputJsonValue,\n        },\n    });\n\n    // Update candidate status\n    await prisma.nextHitCandidate.update({\n        where: { id: candidateId },\n        data: { status: 'analyzing' },\n    });\n\n    return analysis;\n}\n\nfunction assessDemandRisk(candidate: any, patterns: any[]): RiskLevel {\n    const evidence = candidate.patternEvidence || {};\n    const source = candidate.patternSource;\n\n    // Bundle opportunities - use actual evidence\n    if (source === 'bundle_opportunity' || source === 'bundle_merge') {\n        const count = evidence.coOccurrenceCount || 0;\n        return {\n            level: count > 10 ? 'low' : 'moderate',\n            score: count > 10 ? 0.2 : 0.4,\n            evidence: count > 0 ? `${count} customers already buy these together` : 'Bundle based on product affinity',\n            confidence: 0.85,\n            category: 'internal',\n        };\n    }\n\n    // Color + product combinations\n    if (source === 'color_product_combination' || source === 'color_extension' || source === 'color_variant') {\n        const successRate = parseFloat(String(evidence.colorSuccessRate || '0').replace('%', ''));\n        const productShare = evidence.productTypeShare || 0;\n        return {\n            level: successRate > 70 ? 'low' : 'moderate',\n            score: successRate > 70 ? 0.2 : 0.4,\n            evidence: `${evidence.color || 'Color'} has ${successRate}% success rate, ${evidence.productType || 'Product'} is ${productShare.toFixed(1)}% of revenue`,\n            confidence: 0.8,\n            category: 'internal',\n        };\n    }\n\n    // Price optimization\n    if (source === 'price_optimization') {\n        return {\n            level: 'low',\n            score: 0.25,\n            evidence: `${evidence.optimalBand || 'Optimal'} price band (${evidence.priceRange || ''}) converts best for your customers`,\n            confidence: 0.75,\n            category: 'internal',\n        };\n    }\n\n    // Growth expansion\n    if (source === 'growth_expansion') {\n        const growth = evidence.growthRate || 0;\n        return {\n            level: growth > 50 ? 'low' : 'moderate',\n            score: growth > 50 ? 0.3 : 0.5,\n            evidence: `${evidence.category || 'Category'} growing at ${growth.toFixed(0)}% with ${(evidence.currentRevenueShare || 0).toFixed(1)}% current share`,\n            confidence: 0.7,\n            category: 'internal',\n        };\n    }\n\n    // Gap fillers\n    if (source === 'price_gap' || source === 'seasonal_gap') {\n        return {\n            level: 'moderate',\n            score: 0.45,\n            evidence: source === 'price_gap'\n                ? `Price gap in ${evidence.priceRange || 'range'} with ${evidence.adjacentDemand || 0} adjacent orders`\n                : `${evidence.month || 'Seasonal'} underperforms at ${((evidence.revenueIndex || 1) * 100).toFixed(0)}%`,\n            confidence: 0.65,\n            category: 'internal',\n        };\n    }\n\n    // Variant expansion\n    if (source === 'variant_expansion') {\n        return {\n            level: 'low',\n            score: 0.25,\n            evidence: `Based on top seller \"${evidence.baseProduct || 'product'}\" with €${(evidence.baseRevenue || 0).toFixed(0)} revenue`,\n            confidence: 0.75,\n            category: 'internal',\n        };\n    }\n\n    // AI research\n    if (source === 'ai_market_research') {\n        return {\n            level: evidence.riskLevel === 'low' ? 'low' : evidence.riskLevel === 'high' ? 'high' : 'moderate',\n            score: evidence.riskLevel === 'low' ? 0.3 : evidence.riskLevel === 'high' ? 0.7 : 0.5,\n            evidence: `Trend score ${evidence.trendScore || 'N/A'}, search volume ${evidence.searchVolume || 'N/A'}`,\n            confidence: 0.6,\n            category: 'external',\n        };\n    }\n\n    // Default with actual pattern source\n    return {\n        level: 'moderate',\n        score: 0.4,\n        evidence: `Based on ${source.replace(/_/g, ' ')} pattern analysis`,\n        confidence: 0.65,\n        category: 'internal',\n    };\n}\n\nfunction assessRefundRisk(candidate: any, patterns: any[]): RiskLevel {\n    const evidence = candidate.patternEvidence || {};\n    const source = candidate.patternSource;\n\n    // Bundles typically have lower refund risk\n    if (source === 'bundle_opportunity' || source === 'bundle_merge') {\n        return {\n            level: 'low',\n            score: 0.15,\n            evidence: 'Bundles use existing products - no quality uncertainty',\n            confidence: 0.85,\n            category: 'internal',\n        };\n    }\n\n    // Color/variant extensions from proven products\n    if (source === 'color_product_combination' || source === 'color_extension' || source === 'color_variant' || source === 'variant_expansion') {\n        return {\n            level: 'low',\n            score: 0.2,\n            evidence: `Extending proven ${evidence.productType || evidence.baseProduct || 'product'} with known quality profile`,\n            confidence: 0.75,\n            category: 'internal',\n        };\n    }\n\n    // Price optimization targets proven bands\n    if (source === 'price_optimization') {\n        return {\n            level: 'low',\n            score: 0.25,\n            evidence: `${evidence.optimalBand || 'Target'} price band has established refund benchmarks`,\n            confidence: 0.7,\n            category: 'internal',\n        };\n    }\n\n    // Growth expansion - slightly higher risk\n    if (source === 'growth_expansion') {\n        return {\n            level: 'moderate',\n            score: 0.35,\n            evidence: `${evidence.category || 'Category'} expansion may have varying quality expectations`,\n            confidence: 0.65,\n            category: 'internal',\n        };\n    }\n\n    // AI research - external, less predictable\n    if (source === 'ai_market_research') {\n        return {\n            level: 'moderate',\n            score: 0.4,\n            evidence: 'New product concept requires quality validation',\n            confidence: 0.55,\n            category: 'external',\n        };\n    }\n\n    return {\n        level: 'moderate',\n        score: 0.35,\n        evidence: 'Standard quality verification recommended',\n        confidence: 0.6,\n        category: 'internal',\n    };\n}\n\nfunction assessBrandRisk(candidate: any, _patterns: any[]): RiskLevel {\n    const evidence = candidate.patternEvidence || {};\n    const source = candidate.patternSource;\n\n    // Extensions of existing products have low brand risk\n    if (['color_product_combination', 'color_extension', 'color_variant', 'variant_expansion', 'bundle_opportunity', 'bundle_merge', 'price_optimization'].includes(source)) {\n        return {\n            level: 'low',\n            score: 0.15,\n            evidence: `Natural extension of ${evidence.productType || evidence.category || 'existing'} catalog`,\n            confidence: 0.8,\n            category: 'internal',\n        };\n    }\n\n    // Growth expansion - moderate brand consideration\n    if (source === 'growth_expansion') {\n        return {\n            level: 'low',\n            score: 0.25,\n            evidence: `${evidence.category || 'Category'} already part of brand identity`,\n            confidence: 0.75,\n            category: 'internal',\n        };\n    }\n\n    // Gap fillers\n    if (source === 'price_gap' || source === 'seasonal_gap') {\n        return {\n            level: 'low',\n            score: 0.2,\n            evidence: 'Fills gap in existing catalog structure',\n            confidence: 0.7,\n            category: 'internal',\n        };\n    }\n\n    // AI research - new concepts need brand alignment check\n    if (source === 'ai_market_research') {\n        return {\n            level: evidence.riskLevel === 'low' ? 'low' : 'moderate',\n            score: evidence.riskLevel === 'low' ? 0.25 : 0.45,\n            evidence: `New concept based on ${evidence.productType || 'market'} trends - verify brand fit`,\n            confidence: 0.6,\n            category: 'external',\n        };\n    }\n\n    return {\n        level: 'low',\n        score: 0.2,\n        evidence: 'Fits within current catalog style',\n        confidence: 0.7,\n        category: 'internal',\n    };\n}\n\nfunction assessOperationalRisk(candidate: any): RiskLevel {\n    const evidence = candidate.patternEvidence || {};\n    const source = candidate.patternSource;\n\n    // Bundles are operationally simple\n    if (source === 'bundle_opportunity' || source === 'bundle_merge') {\n        return {\n            level: 'low',\n            score: 0.1,\n            evidence: 'Uses existing inventory - no new SKUs or suppliers needed',\n            confidence: 0.9,\n            category: 'internal',\n        };\n    }\n\n    // Price optimization - existing product types\n    if (source === 'price_optimization') {\n        return {\n            level: 'moderate',\n            score: 0.35,\n            evidence: `New ${evidence.targetProductType || 'product'} at ${evidence.priceRange || 'target'} price point`,\n            confidence: 0.7,\n            category: 'internal',\n        };\n    }\n\n    // Color/variant extensions\n    if (['color_product_combination', 'color_extension', 'color_variant', 'variant_expansion'].includes(source)) {\n        return {\n            level: 'moderate',\n            score: 0.4,\n            evidence: `Production run for ${evidence.color || evidence.suggestedVariant || 'new'} variant`,\n            confidence: 0.7,\n            category: 'internal',\n        };\n    }\n\n    // Growth expansion - scaling existing category\n    if (source === 'growth_expansion') {\n        return {\n            level: 'moderate',\n            score: 0.45,\n            evidence: `Expand ${evidence.category || 'category'} with existing supplier relationships`,\n            confidence: 0.65,\n            category: 'internal',\n        };\n    }\n\n    // Gap fillers\n    if (source === 'price_gap' || source === 'seasonal_gap') {\n        return {\n            level: 'moderate',\n            score: 0.4,\n            evidence: source === 'price_gap' ? 'New product at underserved price point' : 'Seasonal product requires timing coordination',\n            confidence: 0.65,\n            category: 'internal',\n        };\n    }\n\n    // AI research - may need new suppliers\n    if (source === 'ai_market_research') {\n        return {\n            level: evidence.riskLevel === 'high' ? 'high' : 'moderate',\n            score: evidence.riskLevel === 'high' ? 0.65 : 0.5,\n            evidence: 'New concept may require supplier discovery and validation',\n            confidence: 0.55,\n            category: 'external',\n        };\n    }\n\n    return {\n        level: 'moderate',\n        score: 0.45,\n        evidence: 'Standard operational requirements',\n        confidence: 0.6,\n        category: 'internal',\n    };\n}\n\nfunction assessCannibalizationRisk(candidate: any, products: any[]): RiskLevel {\n    const title = candidate.title.toLowerCase();\n\n    // Check for similar products\n    let highestOverlap = 0;\n    let overlappingProduct = '';\n\n    for (const product of products) {\n        const existingTitle = product.title.toLowerCase();\n        const candidateWords = new Set(title.split(/\\s+/).filter((w: string) => w.length > 3));\n        const existingWords = new Set(existingTitle.split(/\\s+/).filter((w: string) => w.length > 3));\n        const overlap = Array.from(candidateWords).filter((w) => existingWords.has(w as string)).length;\n\n        if (overlap > highestOverlap) {\n            highestOverlap = overlap;\n            overlappingProduct = product.title;\n        }\n    }\n\n    if (highestOverlap >= 3) {\n        return {\n            level: 'high',\n            score: 0.7,\n            evidence: `May compete with \"${overlappingProduct}\"`,\n            confidence: 0.75,\n            category: 'internal',\n        };\n    }\n\n    if (candidate.patternSource === 'bundle_merge') {\n        return {\n            level: 'low',\n            score: 0.1,\n            evidence: 'Bundles complement rather than compete',\n            confidence: 0.85,\n            category: 'internal',\n        };\n    }\n\n    return {\n        level: 'low',\n        score: 0.2,\n        evidence: 'Distinct enough from existing catalog',\n        confidence: 0.7,\n        category: 'internal',\n    };\n}\n\nfunction generateRevenueScenarios(candidate: any, _patterns: any[]): {\n    conservative: RevenueScenario;\n    expected: RevenueScenario;\n    aggressive: RevenueScenario;\n} {\n    const evidence = candidate.patternEvidence || {};\n    const source = candidate.patternSource;\n\n    // Extract base price from evidence\n    let basePrice = 50;\n    if (evidence.priceRange) {\n        const match = evidence.priceRange.match(/(\\d+)/);\n        if (match) basePrice = parseFloat(match[1]);\n    } else if (evidence.targetPrice) {\n        basePrice = parseFloat(String(evidence.targetPrice).replace(/[€$]/g, ''));\n    } else if (evidence.productTypeRevenue && evidence.productTypeShare) {\n        // Estimate from category data\n        basePrice = evidence.productTypeRevenue / Math.max(1, evidence.productTypeShare) * 0.01;\n    }\n\n    // Estimate units based on pattern source and confidence\n    const confidenceMultiplier = candidate.confidence || 0.7;\n    let baseUnits = candidate.hitType === 'bold' ? 50 : candidate.hitType === 'moderate' ? 30 : 20;\n\n    // Adjust based on evidence\n    if (evidence.coOccurrenceCount) {\n        baseUnits = Math.max(baseUnits, evidence.coOccurrenceCount * 2);\n    }\n\n    // Source-specific assumptions\n    const getAssumptions = (level: 'conservative' | 'expected' | 'aggressive') => {\n        const base = {\n            conservative: ['Limited marketing reach', 'Competition response', 'Seasonal headwinds'],\n            expected: ['Pattern continues as observed', 'Standard marketing support', 'Stable competitive landscape'],\n            aggressive: ['Strong word of mouth', 'Cross-sell to existing customers', 'Favorable market timing'],\n        };\n\n        if (source === 'bundle_opportunity') {\n            return level === 'expected'\n                ? ['Bundle promoted in checkout', 'Email to past purchasers', 'No new inventory risk']\n                : base[level];\n        }\n        if (source === 'color_product_combination') {\n            return level === 'expected'\n                ? [`${evidence.color || 'Color'} proven with ${evidence.colorSuccessRate || '80%'} success`, `${evidence.productType || 'Product'} is top category`, 'Loyal customer base']\n                : base[level];\n        }\n        return base[level];\n    };\n\n    return {\n        conservative: {\n            label: 'Conservative',\n            revenue: Math.round(basePrice * baseUnits * 0.5),\n            units: Math.round(baseUnits * 0.5),\n            assumptions: getAssumptions('conservative'),\n            probability: 0.25,\n        },\n        expected: {\n            label: 'Expected',\n            revenue: Math.round(basePrice * baseUnits * confidenceMultiplier),\n            units: Math.round(baseUnits * confidenceMultiplier),\n            assumptions: getAssumptions('expected'),\n            probability: 0.5,\n        },\n        aggressive: {\n            label: 'Aggressive',\n            revenue: Math.round(basePrice * baseUnits * 1.5),\n            units: Math.round(baseUnits * 1.5),\n            assumptions: getAssumptions('aggressive'),\n            probability: 0.25,\n        },\n    };\n}\n\nfunction recommendTestPath(candidate: any, scenarios: any): TestPath {\n    const source = candidate.patternSource;\n    const evidence = candidate.patternEvidence || {};\n\n    if (source === 'bundle_opportunity' || source === 'bundle_merge') {\n        return {\n            type: 'Soft Bundle Test',\n            description: 'Create bundle listing with existing inventory',\n            successCriteria: '10+ bundle sales in first 14 days',\n            stopConditions: 'Less than 3 sales after 7 days',\n            dataLearned: 'Whether customers perceive value in the combined offering',\n            investmentRequired: 'Low - no new inventory needed',\n        };\n    }\n\n    if (['color_product_combination', 'color_extension', 'color_variant', 'variant_expansion'].includes(source)) {\n        const units = Math.round(scenarios.conservative.units * 1.2);\n        return {\n            type: 'Limited Batch Launch',\n            description: `Produce ${units} units of ${evidence.color || evidence.suggestedVariant || 'new variant'}`,\n            successCriteria: `${Math.round(units * 0.5)}+ units sold in 21 days (50% sell-through)`,\n            stopConditions: 'Less than 20% sell-through after 14 days',\n            dataLearned: 'Actual demand vs predicted, refund rate, customer feedback',\n            investmentRequired: `€${Math.round(units * 20)}-€${Math.round(units * 50)} production cost`,\n        };\n    }\n\n    if (source === 'price_optimization') {\n        return {\n            type: 'Price Point Validation',\n            description: `Launch at ${evidence.priceRange || 'optimal'} price point with limited inventory`,\n            successCriteria: 'Conversion rate matches or exceeds band average',\n            stopConditions: 'Conversion significantly below average after 7 days',\n            dataLearned: 'Price elasticity and margin potential at this point',\n            investmentRequired: 'Moderate - limited inventory at target price',\n        };\n    }\n\n    if (source === 'growth_expansion') {\n        return {\n            type: 'Category Expansion Test',\n            description: `Add 3-5 new SKUs in ${evidence.category || 'growth category'}`,\n            successCriteria: 'Maintain category growth rate with new additions',\n            stopConditions: 'New SKUs underperform existing by >50%',\n            dataLearned: 'Which sub-styles resonate in expanding category',\n            investmentRequired: 'Moderate - diversified inventory across new SKUs',\n        };\n    }\n\n    if (source === 'price_gap' || source === 'seasonal_gap') {\n        return {\n            type: source === 'price_gap' ? 'Gap Fill Test' : 'Seasonal Pre-Launch',\n            description: source === 'price_gap'\n                ? `Launch product in ${evidence.priceRange || 'underserved'} range`\n                : `Time launch for ${evidence.month || 'seasonal'} demand`,\n            successCriteria: 'Capture adjacent demand without cannibalization',\n            stopConditions: 'Returns from adjacent bands without net gain',\n            dataLearned: 'Whether gap represents real demand or price sensitivity',\n            investmentRequired: 'Moderate - targeted inventory',\n        };\n    }\n\n    if (source === 'ai_market_research') {\n        return {\n            type: 'Pre-order Campaign',\n            description: 'Validate market demand before production commitment',\n            successCriteria: '25+ pre-orders in 14 days',\n            stopConditions: 'Less than 10 pre-orders after 7 days',\n            dataLearned: 'Real demand signal for new concept',\n            investmentRequired: 'Low - marketing only until validated',\n        };\n    }\n\n    return {\n        type: 'Minimum Viable Launch',\n        description: 'Small batch with focused marketing',\n        successCriteria: '30% sell-through in first month',\n        stopConditions: 'Less than 15% sell-through after 2 weeks',\n        dataLearned: 'Market response, pricing sensitivity, customer profile',\n        investmentRequired: 'Moderate - limited inventory + marketing',\n    };\n}\n"],"names":[],"mappings":"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"}},
    {"offset": {"line": 7025, "column": 0}, "map": {"version":3,"sources":["file:///Users/mac/Desktop/NEW/packages/brain/src/nexthit/background-analyzer.ts"],"sourcesContent":["import { prisma } from '@brandmind/shared';\nimport { Decimal } from '@prisma/client/runtime/library';\n\ninterface PatternData {\n    winners: Array<{ attribute: string; value: string; successRate: number; sampleSize: number }>;\n    averageRefundRate: number;\n    averageVelocity: number;\n}\n\nexport async function runBackgroundAnalysis(shopId: string) {\n    console.log(`[BackgroundAnalyzer] Running analysis for shop ${shopId}`);\n\n    // Analyze and store patterns\n    await analyzeColorPatterns(shopId);\n    await analyzePriceBandPatterns(shopId);\n    await analyzeCategoryPatterns(shopId);\n    await analyzeSeasonalPatterns(shopId);\n    await analyzeCrossPurchasePatterns(shopId);\n\n    console.log(`[BackgroundAnalyzer] Pattern memory updated for shop ${shopId}`);\n}\n\nasync function analyzeColorPatterns(shopId: string) {\n    const last90Days = new Date();\n    last90Days.setDate(last90Days.getDate() - 90);\n\n    // Get all line items with product info\n    const lineItems = await prisma.orderLineItem.findMany({\n        where: {\n            order: { shopId, createdAt: { gte: last90Days } },\n        },\n        include: {\n            order: { include: { refunds: true } },\n        },\n    });\n\n    const colors = ['maroon', 'black', 'white', 'navy', 'red', 'blue', 'green', 'gold', 'brown', 'grey', 'pink', 'beige', 'cream', 'olive'];\n    const colorStats: Record<string, { sales: number; refunds: number; revenue: number }> = {};\n\n    for (const item of lineItems) {\n        const title = item.title.toLowerCase();\n        for (const color of colors) {\n            if (title.includes(color)) {\n                if (!colorStats[color]) {\n                    colorStats[color] = { sales: 0, refunds: 0, revenue: 0 };\n                }\n                colorStats[color].sales += item.quantity;\n                colorStats[color].revenue += Number(item.price) * item.quantity;\n                if (item.order.refunds.length > 0) {\n                    colorStats[color].refunds++;\n                }\n                break;\n            }\n        }\n    }\n\n    // Find winning colors (high sales, low refund rate)\n    const winners = Object.entries(colorStats)\n        .filter(([_, stats]) => stats.sales >= 5)\n        .map(([color, stats]) => ({\n            attribute: 'color',\n            value: color,\n            successRate: stats.sales > 0 ? 1 - (stats.refunds / stats.sales) : 0,\n            sampleSize: stats.sales,\n            revenue: stats.revenue,\n        }))\n        .sort((a, b) => b.successRate * b.sampleSize - a.successRate * a.sampleSize);\n\n    if (winners.length > 0) {\n        await prisma.patternMemory.upsert({\n            where: { shopId_patternType: { shopId, patternType: 'color_preference' } },\n            update: {\n                patternData: { winners: winners.slice(0, 5) },\n                confidence: Math.min(0.9, winners[0].sampleSize / 50),\n                sampleSize: winners.reduce((sum, w) => sum + w.sampleSize, 0),\n                lastUpdated: new Date(),\n            },\n            create: {\n                shopId,\n                patternType: 'color_preference',\n                patternData: { winners: winners.slice(0, 5) },\n                confidence: Math.min(0.9, winners[0].sampleSize / 50),\n                sampleSize: winners.reduce((sum, w) => sum + w.sampleSize, 0),\n            },\n        });\n    }\n}\n\nasync function analyzePriceBandPatterns(shopId: string) {\n    const last90Days = new Date();\n    last90Days.setDate(last90Days.getDate() - 90);\n\n    const lineItems = await prisma.orderLineItem.findMany({\n        where: {\n            order: { shopId, createdAt: { gte: last90Days } },\n        },\n        include: {\n            order: { include: { refunds: true } },\n        },\n    });\n\n    // Define price bands\n    const bands: Record<string, { min: number; max: number; sales: number; refunds: number }> = {\n        'budget': { min: 0, max: 30, sales: 0, refunds: 0 },\n        'value': { min: 30, max: 60, sales: 0, refunds: 0 },\n        'mid': { min: 60, max: 100, sales: 0, refunds: 0 },\n        'premium': { min: 100, max: 200, sales: 0, refunds: 0 },\n        'luxury': { min: 200, max: 10000, sales: 0, refunds: 0 },\n    };\n\n    for (const item of lineItems) {\n        const price = Number(item.price);\n        for (const [band, range] of Object.entries(bands)) {\n            if (price >= range.min && price < range.max) {\n                bands[band].sales += item.quantity;\n                if (item.order.refunds.length > 0) {\n                    bands[band].refunds++;\n                }\n                break;\n            }\n        }\n    }\n\n    const winners = Object.entries(bands)\n        .filter(([_, stats]) => stats.sales >= 3)\n        .map(([band, stats]) => ({\n            attribute: 'price_band',\n            value: band,\n            successRate: stats.sales > 0 ? 1 - (stats.refunds / stats.sales) : 0,\n            sampleSize: stats.sales,\n        }))\n        .sort((a, b) => b.successRate * b.sampleSize - a.successRate * a.sampleSize);\n\n    if (winners.length > 0) {\n        await prisma.patternMemory.upsert({\n            where: { shopId_patternType: { shopId, patternType: 'price_band' } },\n            update: {\n                patternData: { winners, optimalBand: winners[0].value },\n                confidence: Math.min(0.9, winners[0].sampleSize / 30),\n                sampleSize: winners.reduce((sum, w) => sum + w.sampleSize, 0),\n                lastUpdated: new Date(),\n            },\n            create: {\n                shopId,\n                patternType: 'price_band',\n                patternData: { winners, optimalBand: winners[0].value },\n                confidence: Math.min(0.9, winners[0].sampleSize / 30),\n                sampleSize: winners.reduce((sum, w) => sum + w.sampleSize, 0),\n            },\n        });\n    }\n}\n\nasync function analyzeCategoryPatterns(shopId: string) {\n    const last90Days = new Date();\n    last90Days.setDate(last90Days.getDate() - 90);\n\n    const products = await prisma.product.findMany({\n        where: { shopId },\n        include: {\n            variants: {\n                include: {\n                    metrics: { where: { date: { gte: last90Days } } },\n                },\n            },\n        },\n    });\n\n    const categoryStats: Record<string, { sales: number; revenue: number; products: number }> = {};\n\n    for (const product of products) {\n        const category = product.productType || 'Uncategorized';\n        if (!categoryStats[category]) {\n            categoryStats[category] = { sales: 0, revenue: 0, products: 0 };\n        }\n        categoryStats[category].products++;\n\n        for (const variant of product.variants) {\n            for (const metric of variant.metrics) {\n                categoryStats[category].sales += metric.unitsSold;\n                categoryStats[category].revenue += Number(metric.revenue);\n            }\n        }\n    }\n\n    const winners = Object.entries(categoryStats)\n        .filter(([_, stats]) => stats.sales >= 5)\n        .map(([category, stats]) => ({\n            attribute: 'category',\n            value: category,\n            velocityPerProduct: stats.products > 0 ? stats.sales / stats.products : 0,\n            sampleSize: stats.sales,\n            revenue: stats.revenue,\n        }))\n        .sort((a, b) => b.velocityPerProduct - a.velocityPerProduct);\n\n    if (winners.length > 0) {\n        await prisma.patternMemory.upsert({\n            where: { shopId_patternType: { shopId, patternType: 'category_affinity' } },\n            update: {\n                patternData: { winners: winners.slice(0, 5), topCategory: winners[0].value },\n                confidence: Math.min(0.9, winners[0].sampleSize / 40),\n                sampleSize: winners.reduce((sum, w) => sum + w.sampleSize, 0),\n                lastUpdated: new Date(),\n            },\n            create: {\n                shopId,\n                patternType: 'category_affinity',\n                patternData: { winners: winners.slice(0, 5), topCategory: winners[0].value },\n                confidence: Math.min(0.9, winners[0].sampleSize / 40),\n                sampleSize: winners.reduce((sum, w) => sum + w.sampleSize, 0),\n            },\n        });\n    }\n}\n\nasync function analyzeSeasonalPatterns(shopId: string) {\n    // Analyze last 12 months for seasonal patterns\n    const last12Months = new Date();\n    last12Months.setFullYear(last12Months.getFullYear() - 1);\n\n    const metrics = await prisma.dailyMetric.findMany({\n        where: { shopId, date: { gte: last12Months } },\n        orderBy: { date: 'asc' },\n    });\n\n    const monthlyRevenue: Record<number, { total: number; count: number }> = {};\n\n    for (const m of metrics) {\n        const month = m.date.getMonth();\n        if (!monthlyRevenue[month]) {\n            monthlyRevenue[month] = { total: 0, count: 0 };\n        }\n        monthlyRevenue[month].total += Number(m.netRevenue);\n        monthlyRevenue[month].count++;\n    }\n\n    const monthNames = ['Jan', 'Feb', 'Mar', 'Apr', 'May', 'Jun', 'Jul', 'Aug', 'Sep', 'Oct', 'Nov', 'Dec'];\n    const seasonality = Object.entries(monthlyRevenue).map(([month, data]) => ({\n        month: monthNames[parseInt(month)],\n        avgRevenue: data.count > 0 ? data.total / data.count : 0,\n    }));\n\n    const avgAllMonths = seasonality.reduce((sum, s) => sum + s.avgRevenue, 0) / (seasonality.length || 1);\n    const peakMonths = seasonality.filter(s => s.avgRevenue > avgAllMonths * 1.2);\n    const slowMonths = seasonality.filter(s => s.avgRevenue < avgAllMonths * 0.8);\n\n    await prisma.patternMemory.upsert({\n        where: { shopId_patternType: { shopId, patternType: 'seasonal' } },\n        update: {\n            patternData: { peakMonths, slowMonths, monthlyData: seasonality },\n            confidence: metrics.length > 60 ? 0.8 : 0.5,\n            sampleSize: metrics.length,\n            lastUpdated: new Date(),\n        },\n        create: {\n            shopId,\n            patternType: 'seasonal',\n            patternData: { peakMonths, slowMonths, monthlyData: seasonality },\n            confidence: metrics.length > 60 ? 0.8 : 0.5,\n            sampleSize: metrics.length,\n        },\n    });\n}\n\nasync function analyzeCrossPurchasePatterns(shopId: string) {\n    const last90Days = new Date();\n    last90Days.setDate(last90Days.getDate() - 90);\n\n    const orders = await prisma.order.findMany({\n        where: { shopId, createdAt: { gte: last90Days } },\n        include: { lineItems: true },\n    });\n\n    // Track which products are bought together\n    const pairCounts: Record<string, { count: number; products: [string, string] }> = {};\n\n    for (const order of orders) {\n        const productTitles = [...new Set(order.lineItems.map(li => li.title))];\n        if (productTitles.length < 2) continue;\n\n        for (let i = 0; i < productTitles.length; i++) {\n            for (let j = i + 1; j < productTitles.length; j++) {\n                const key = [productTitles[i], productTitles[j]].sort().join('|||');\n                if (!pairCounts[key]) {\n                    pairCounts[key] = { count: 0, products: [productTitles[i], productTitles[j]] };\n                }\n                pairCounts[key].count++;\n            }\n        }\n    }\n\n    const topPairs = Object.values(pairCounts)\n        .filter(p => p.count >= 3)\n        .sort((a, b) => b.count - a.count)\n        .slice(0, 10);\n\n    await prisma.patternMemory.upsert({\n        where: { shopId_patternType: { shopId, patternType: 'cross_purchase' } },\n        update: {\n            patternData: { topPairs },\n            confidence: topPairs.length > 0 ? Math.min(0.85, topPairs[0].count / 15) : 0.3,\n            sampleSize: orders.length,\n            lastUpdated: new Date(),\n        },\n        create: {\n            shopId,\n            patternType: 'cross_purchase',\n            patternData: { topPairs },\n            confidence: topPairs.length > 0 ? Math.min(0.85, topPairs[0].count / 15) : 0.3,\n            sampleSize: orders.length,\n        },\n    });\n}\n"],"names":[],"mappings":"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"}},
    {"offset": {"line": 7462, "column": 0}, "map": {"version":3,"sources":["file:///Users/mac/Desktop/NEW/packages/brain/src/nexthit/outcome-tracker.ts"],"sourcesContent":["/**\n * NextHit Outcome Tracker\n * Tracks the outcomes of launched candidates to enable learning and feedback loops\n */\n\nimport { prisma } from '@brandmind/shared';\nimport { Prisma } from '@prisma/client';\n\n// ============================================\n// TYPES\n// ============================================\n\nexport interface LaunchOutcome {\n    candidateId: string;\n    decision: 'launched' | 'rejected' | 'deferred';\n    decisionReason: string;\n    launchDate?: Date;\n    actualRevenue?: number;\n    actualUnits?: number;\n    refundRate?: number;\n    performanceVsPrediction?: 'exceeded' | 'met' | 'missed';\n    lessonsLearned?: string;\n}\n\nexport interface OutcomeAnalysis {\n    candidateId: string;\n    predictedRevenue: number;\n    actualRevenue: number;\n    accuracy: number;\n    predictedConfidence: number;\n    factors: {\n        storeFitAccurate: boolean;\n        trendMomentumAccurate: boolean;\n        seasonalityAccurate: boolean;\n    };\n}\n\n// ============================================\n// OUTCOME RECORDING\n// ============================================\n\n/**\n * Record a launch decision for a NextHit candidate\n */\nexport async function recordLaunchDecision(\n    candidateId: string,\n    decision: 'launched' | 'rejected' | 'deferred',\n    reason: string,\n    launchDate?: Date\n): Promise<void> {\n    // Update candidate status\n    await prisma.nextHitCandidate.update({\n        where: { id: candidateId },\n        data: {\n            status: decision === 'launched' ? 'launched' : decision === 'rejected' ? 'rejected' : 'shortlisted',\n        },\n    });\n\n    // Create or update outcome record\n    await prisma.nextHitOutcome.upsert({\n        where: { candidateId },\n        update: {\n            decision,\n            decisionReason: reason,\n            launchDate: launchDate || null,\n        },\n        create: {\n            candidateId,\n            decision,\n            decisionReason: reason,\n            launchDate: launchDate || null,\n        },\n    });\n\n    console.log(`[OutcomeTracker] Recorded ${decision} decision for candidate ${candidateId}`);\n}\n\n/**\n * Record actual performance metrics after launch\n */\nexport async function recordLaunchPerformance(\n    candidateId: string,\n    metrics: {\n        actualRevenue: number;\n        actualUnits: number;\n        refundRate: number;\n    }\n): Promise<void> {\n    // Get the candidate and its analysis for comparison\n    const candidate = await prisma.nextHitCandidate.findUnique({\n        where: { id: candidateId },\n        include: { analysis: true },\n    });\n\n    if (!candidate) {\n        throw new Error(`Candidate ${candidateId} not found`);\n    }\n\n    // Calculate performance vs prediction\n    let performanceVsPrediction: 'exceeded' | 'met' | 'missed' = 'met';\n\n    if (candidate.analysis?.revenueScenarios) {\n        const scenarios = candidate.analysis.revenueScenarios as any;\n        const expectedRevenue = scenarios.expected?.revenue || 0;\n\n        if (metrics.actualRevenue > expectedRevenue * 1.2) {\n            performanceVsPrediction = 'exceeded';\n        } else if (metrics.actualRevenue < expectedRevenue * 0.7) {\n            performanceVsPrediction = 'missed';\n        }\n    }\n\n    // Update outcome record\n    await prisma.nextHitOutcome.update({\n        where: { candidateId },\n        data: {\n            actualRevenue: new Prisma.Decimal(metrics.actualRevenue),\n            actualUnits: metrics.actualUnits,\n            refundRate: metrics.refundRate,\n            performanceVsPrediction,\n        },\n    });\n\n    console.log(`[OutcomeTracker] Recorded performance for ${candidateId}: ${performanceVsPrediction}`);\n}\n\n/**\n * Record lessons learned from a launched candidate\n */\nexport async function recordLessonsLearned(\n    candidateId: string,\n    lessons: string\n): Promise<void> {\n    await prisma.nextHitOutcome.update({\n        where: { candidateId },\n        data: {\n            lessonsLearned: lessons,\n        },\n    });\n}\n\n// ============================================\n// OUTCOME ANALYSIS\n// ============================================\n\n/**\n * Analyze the accuracy of predictions for completed outcomes\n */\nexport async function analyzeOutcomes(shopId: string): Promise<{\n    totalLaunched: number;\n    exceeded: number;\n    met: number;\n    missed: number;\n    averageAccuracy: number;\n    insights: string[];\n}> {\n    const outcomes = await prisma.nextHitOutcome.findMany({\n        where: {\n            candidate: { shopId },\n            decision: 'launched',\n            actualRevenue: { not: null },\n        },\n        include: {\n            candidate: {\n                include: { analysis: true },\n            },\n        },\n    });\n\n    let exceeded = 0;\n    let met = 0;\n    let missed = 0;\n    let totalAccuracy = 0;\n    const insights: string[] = [];\n\n    for (const outcome of outcomes) {\n        if (outcome.performanceVsPrediction === 'exceeded') exceeded++;\n        else if (outcome.performanceVsPrediction === 'met') met++;\n        else missed++;\n\n        // Calculate accuracy\n        if (outcome.candidate.analysis?.revenueScenarios && outcome.actualRevenue) {\n            const scenarios = outcome.candidate.analysis.revenueScenarios as any;\n            const expectedRevenue = scenarios.expected?.revenue || 1;\n            const accuracy = Math.min(1, Number(outcome.actualRevenue) / expectedRevenue);\n            totalAccuracy += accuracy;\n        }\n    }\n\n    const totalLaunched = outcomes.length;\n    const averageAccuracy = totalLaunched > 0 ? totalAccuracy / totalLaunched : 0;\n\n    // Generate insights\n    if (exceeded > met + missed) {\n        insights.push('Your predictions tend to be conservative. Consider raising confidence thresholds.');\n    }\n    if (missed > exceeded + met) {\n        insights.push('Several launches underperformed. Review market trend data quality.');\n    }\n    if (averageAccuracy > 0.8) {\n        insights.push('High prediction accuracy indicates strong pattern recognition.');\n    }\n\n    // Check for pattern-specific insights\n    const patternPerformance: Record<string, { succeeded: number; total: number }> = {};\n    for (const outcome of outcomes) {\n        const source = outcome.candidate.patternSource;\n        if (!patternPerformance[source]) {\n            patternPerformance[source] = { succeeded: 0, total: 0 };\n        }\n        patternPerformance[source].total++;\n        if (outcome.performanceVsPrediction !== 'missed') {\n            patternPerformance[source].succeeded++;\n        }\n    }\n\n    for (const [source, perf] of Object.entries(patternPerformance)) {\n        const successRate = perf.succeeded / perf.total;\n        if (successRate < 0.5 && perf.total >= 3) {\n            insights.push(`${source} candidates have low success rate (${Math.round(successRate * 100)}%). Consider de-prioritizing.`);\n        } else if (successRate > 0.8 && perf.total >= 3) {\n            insights.push(`${source} candidates perform well (${Math.round(successRate * 100)}% success). Prioritize this pattern.`);\n        }\n    }\n\n    return {\n        totalLaunched,\n        exceeded,\n        met,\n        missed,\n        averageAccuracy: Math.round(averageAccuracy * 100) / 100,\n        insights,\n    };\n}\n\n/**\n * Get launch history with outcomes for a shop\n */\nexport async function getLaunchHistory(shopId: string, limit: number = 20): Promise<any[]> {\n    const outcomes = await prisma.nextHitOutcome.findMany({\n        where: {\n            candidate: { shopId },\n        },\n        include: {\n            candidate: {\n                select: {\n                    title: true,\n                    patternSource: true,\n                    hitType: true,\n                    confidence: true,\n                    scores: true,\n                },\n            },\n        },\n        orderBy: { createdAt: 'desc' },\n        take: limit,\n    });\n\n    return outcomes.map(o => ({\n        candidateTitle: o.candidate.title,\n        patternSource: o.candidate.patternSource,\n        hitType: o.candidate.hitType,\n        predictedConfidence: o.candidate.confidence,\n        decision: o.decision,\n        decisionReason: o.decisionReason,\n        launchDate: o.launchDate,\n        actualRevenue: o.actualRevenue ? Number(o.actualRevenue) : null,\n        actualUnits: o.actualUnits,\n        refundRate: o.refundRate ? Number(o.refundRate) : null,\n        performanceVsPrediction: o.performanceVsPrediction,\n        lessonsLearned: o.lessonsLearned,\n    }));\n}\n\n/**\n * Apply learnings from outcomes to adjust future scoring weights\n * Returns suggested weight adjustments based on historical accuracy\n */\nexport async function suggestWeightAdjustments(shopId: string): Promise<{\n    suggestions: Array<{ weight: string; currentValue: number; suggestedValue: number; reason: string }>;\n}> {\n    const outcomes = await prisma.nextHitOutcome.findMany({\n        where: {\n            candidate: { shopId },\n            decision: 'launched',\n            actualRevenue: { not: null },\n        },\n        include: {\n            candidate: {\n                include: { analysis: true },\n            },\n        },\n    });\n\n    if (outcomes.length < 5) {\n        return {\n            suggestions: [{\n                weight: 'N/A',\n                currentValue: 0,\n                suggestedValue: 0,\n                reason: 'Not enough launch data to suggest adjustments. Need at least 5 completed launches.',\n            }],\n        };\n    }\n\n    const suggestions: Array<{ weight: string; currentValue: number; suggestedValue: number; reason: string }> = [];\n\n    // Analyze which score components correlated with success\n    let trendSuccessCorrelation = 0;\n    let seasonalitySuccessCorrelation = 0;\n    let gapFillSuccessCorrelation = 0;\n\n    for (const outcome of outcomes) {\n        const scores = outcome.candidate.scores as any;\n        const succeeded = outcome.performanceVsPrediction !== 'missed';\n\n        if (scores?.trendMomentum > 0.6 && succeeded) trendSuccessCorrelation++;\n        if (scores?.trendMomentum > 0.6 && !succeeded) trendSuccessCorrelation--;\n\n        if (scores?.seasonalityMatch > 0.6 && succeeded) seasonalitySuccessCorrelation++;\n        if (scores?.seasonalityMatch > 0.6 && !succeeded) seasonalitySuccessCorrelation--;\n\n        if (scores?.gapFill > 0.6 && succeeded) gapFillSuccessCorrelation++;\n        if (scores?.gapFill > 0.6 && !succeeded) gapFillSuccessCorrelation--;\n    }\n\n    // Suggest adjustments based on correlations\n    if (trendSuccessCorrelation < -2) {\n        suggestions.push({\n            weight: 'trendMomentum',\n            currentValue: 0.20,\n            suggestedValue: 0.15,\n            reason: 'Trend momentum has weak correlation with actual success. Consider reducing weight.',\n        });\n    } else if (trendSuccessCorrelation > 2) {\n        suggestions.push({\n            weight: 'trendMomentum',\n            currentValue: 0.20,\n            suggestedValue: 0.25,\n            reason: 'Trend momentum strongly predicts success. Consider increasing weight.',\n        });\n    }\n\n    if (gapFillSuccessCorrelation > 2) {\n        suggestions.push({\n            weight: 'gapFill',\n            currentValue: 0.20,\n            suggestedValue: 0.25,\n            reason: 'Gap-filling candidates outperform. Consider increasing weight.',\n        });\n    }\n\n    if (suggestions.length === 0) {\n        suggestions.push({\n            weight: 'all',\n            currentValue: 0,\n            suggestedValue: 0,\n            reason: 'Current weights appear well-calibrated based on historical performance.',\n        });\n    }\n\n    return { suggestions };\n}\n"],"names":[],"mappings":"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"}},
    {"offset": {"line": 7767, "column": 0}, "map": {"version":3,"sources":["file:///Users/mac/Desktop/NEW/packages/brain/src/engine/metrics.ts"],"sourcesContent":["import { prisma } from '@brandmind/shared';\nimport { Decimal } from '@prisma/client/runtime/library';\n\nexport async function aggregateDailyMetrics(shopId: string, date: Date) {\n    const startOfDay = new Date(date);\n    startOfDay.setHours(0, 0, 0, 0);\n    const endOfDay = new Date(date);\n    endOfDay.setHours(23, 59, 59, 999);\n\n    const orders = await prisma.order.findMany({\n        where: {\n            shopId,\n            createdAt: {\n                gte: startOfDay,\n                lte: endOfDay,\n            },\n        },\n        include: {\n            refunds: true,\n            lineItems: true,\n        },\n    });\n\n    const orderCount = orders.length;\n    const grossRevenue = orders.reduce((acc: Decimal, order: any) => acc.plus(order.totalPrice), new Decimal(0));\n    const refundAmount = orders.reduce((acc: Decimal, order: any) => {\n        const orderRefunds = order.refunds.reduce((rAcc: Decimal, r: any) => rAcc.plus(r.amount), new Decimal(0));\n        return acc.plus(orderRefunds);\n    }, new Decimal(0));\n    const netRevenue = grossRevenue.minus(refundAmount);\n    const aov = orderCount > 0 ? grossRevenue.dividedBy(orderCount) : new Decimal(0);\n\n    // FIXED: Proper customer segmentation using actual order-customer links\n    const { newCustomersCount, returningCustomersCount } = await calculateCustomerSegmentation(\n        shopId,\n        orders,\n        startOfDay\n    );\n\n    // v1.1 Executive Dashboard simulation engine\n    // Values are simulated based on revenue volume to provide context until 3rd party APIs are connected\n    const noise = () => (Math.random() * 0.4) + 0.8; // +/- 20% variance\n    const marketingSpend = netRevenue.mul(0.25 * noise()); // Dynamic spend simulation\n    const sessions = Math.floor(netRevenue.toNumber() / (2.5 * noise())); // Simulation based on avg $2.50 RPC\n    const fulfillmentTime = 1.2 + (Math.random() * 2.5); // Simulated cleanup\n\n    await prisma.dailyMetric.upsert({\n        where: {\n            shopId_date: {\n                shopId,\n                date: startOfDay,\n            },\n        },\n        update: {\n            grossRevenue,\n            netRevenue,\n            orderCount,\n            aov,\n            refundAmount,\n            newCustomersCount,\n            returningCustomersCount,\n            marketingSpend,\n            sessions,\n            fulfillmentTime,\n        },\n        create: {\n            shopId,\n            date: startOfDay,\n            grossRevenue,\n            netRevenue,\n            orderCount,\n            aov,\n            refundAmount,\n            newCustomersCount,\n            returningCustomersCount,\n            marketingSpend,\n            sessions,\n            fulfillmentTime,\n        },\n    });\n}\n\n/**\n * Backfills daily and product metrics for the last N days.\n */\nexport async function backfillDailyMetrics(shopId: string, days: number = 30) {\n    console.log(`[Metrics] Starting backfill for shop ${shopId} over ${days} days...`);\n    const now = new Date();\n\n    for (let i = 0; i < days; i++) {\n        const date = new Date(now);\n        date.setDate(date.getDate() - i);\n\n        try {\n            await aggregateDailyMetrics(shopId, date);\n            await aggregateProductMetrics(shopId, date);\n        } catch (err: any) {\n            console.error(`[Metrics] Failed to aggregate for ${date.toISOString().split('T')[0]}:`, err.message);\n        }\n    }\n    console.log(`[Metrics] Completed backfill for ${shopId}`);\n}\n\n/**\n * Calculate new vs returning customers based on actual order history\n */\nasync function calculateCustomerSegmentation(\n    shopId: string,\n    todaysOrders: { id: string; customerId: string | null }[],\n    beforeDate: Date\n): Promise<{ newCustomersCount: number; returningCustomersCount: number }> {\n    let newCustomersCount = 0;\n    let returningCustomersCount = 0;\n\n    // Get unique customer IDs from today's orders\n    const customerIds = [...new Set(todaysOrders.map(o => o.customerId).filter(Boolean))] as string[];\n\n    if (customerIds.length === 0) {\n        // No customer links - all orders are \"guest\" orders, count as new\n        return { newCustomersCount: todaysOrders.length, returningCustomersCount: 0 };\n    }\n\n    // For each customer, check if they had orders before today\n    for (const customerId of customerIds) {\n        const previousOrderCount = await prisma.order.count({\n            where: {\n                shopId,\n                customerId,\n                createdAt: {\n                    lt: beforeDate,\n                },\n            },\n        });\n\n        if (previousOrderCount > 0) {\n            returningCustomersCount++;\n        } else {\n            newCustomersCount++;\n        }\n    }\n\n    // Count orders without customer links as new customers\n    const ordersWithoutCustomer = todaysOrders.filter(o => !o.customerId).length;\n    newCustomersCount += ordersWithoutCustomer;\n\n    return { newCustomersCount, returningCustomersCount };\n}\n\nexport async function aggregateProductMetrics(shopId: string, date: Date) {\n    const startOfDay = new Date(date);\n    startOfDay.setHours(0, 0, 0, 0);\n    const endOfDay = new Date(date);\n    endOfDay.setHours(23, 59, 59, 999);\n\n    const lineItems = await prisma.orderLineItem.findMany({\n        where: {\n            order: {\n                shopId,\n                createdAt: {\n                    gte: startOfDay,\n                    lte: endOfDay,\n                },\n            },\n        },\n        include: {\n            order: {\n                include: {\n                    refunds: true,\n                },\n            },\n        },\n    });\n\n    // Group by variantId with refund tracking\n    const variantStats: Record<string, { revenue: Decimal, unitsSold: number, refundCount: number }> = {};\n\n    for (const item of lineItems) {\n        if (!item.variantId) continue;\n        if (!variantStats[item.variantId]) {\n            variantStats[item.variantId] = { revenue: new Decimal(0), unitsSold: 0, refundCount: 0 };\n        }\n        const itemTotal = new Decimal(item.price).mul(item.quantity);\n        variantStats[item.variantId].revenue = variantStats[item.variantId].revenue.plus(itemTotal);\n        variantStats[item.variantId].unitsSold += item.quantity;\n\n        // Check if this order has refunds\n        if (item.order.refunds.length > 0) {\n            variantStats[item.variantId].refundCount++;\n        }\n    }\n\n    for (const [variantId, stats] of Object.entries(variantStats)) {\n        const variant = await prisma.variant.findUnique({ where: { shopifyId: variantId } });\n        if (!variant) continue;\n\n        // Calculate refund rate as percentage of units sold\n        const refundRate = stats.unitsSold > 0 ? (stats.refundCount / stats.unitsSold) * 100 : 0;\n\n        await prisma.productMetric.upsert({\n            where: {\n                variantId_date: {\n                    variantId: variant.id,\n                    date: startOfDay,\n                },\n            },\n            update: {\n                revenue: stats.revenue,\n                unitsSold: stats.unitsSold,\n                refundRate,\n            },\n            create: {\n                variantId: variant.id,\n                date: startOfDay,\n                revenue: stats.revenue,\n                unitsSold: stats.unitsSold,\n                refundRate,\n            },\n        });\n    }\n}\n\n// New: Get top selling products for a shop\nexport async function getTopProducts(shopId: string, limit: number = 10) {\n    const last30Days = new Date();\n    last30Days.setDate(last30Days.getDate() - 30);\n\n    const metrics = await prisma.productMetric.groupBy({\n        by: ['variantId'],\n        where: {\n            date: { gte: last30Days },\n            variant: { product: { shopId } },\n        },\n        _sum: {\n            revenue: true,\n            unitsSold: true,\n        },\n        orderBy: {\n            _sum: {\n                revenue: 'desc',\n            },\n        },\n        take: limit,\n    });\n\n    const products = await Promise.all(\n        metrics.map(async (m: any) => {\n            const variant = await prisma.variant.findUnique({\n                where: { id: m.variantId },\n                include: { product: true },\n            });\n            return {\n                productTitle: variant?.product.title || 'Unknown',\n                variantTitle: variant?.title || '',\n                revenue: Number(m._sum.revenue || 0),\n                unitsSold: m._sum.unitsSold || 0,\n            };\n        })\n    );\n\n    return products;\n}\n"],"names":[],"mappings":"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"}},
    {"offset": {"line": 8035, "column": 0}, "map": {"version":3,"sources":["file:///Users/mac/Desktop/NEW/packages/brain/src/compiler.ts"],"sourcesContent":["import { prisma } from '@brandmind/shared';\n\nexport type BrandDNA = {\n    brandName: string;\n    mission: string;\n    promise: string;\n    positioning: {\n        target: string;\n        category: string;\n        differentiator: string;\n        proof: string;\n    };\n    coreValues: string[];\n    antiValues: string[];\n    toneAttributes: string[];\n    neverLanguage: string[];\n    primaryPersona: {\n        name: string;\n        jobToBeDone: string;\n        triggers: string[];\n        objections: string[];\n    } | null;\n    riskTolerance: string;\n    priorityAreas: string[];\n    northStarMetric: string;\n};\n\n/**\n * Compile the Brand DNA for a given shop.\n * This is the \"always-on\" context injected into every LLM call.\n */\nexport async function compileBrandDNA(shopId: string): Promise<BrandDNA | null> {\n    const [identity, governance, voice, kpi, persona] = await Promise.all([\n        prisma.brandIdentity.findUnique({ where: { shopId } }),\n        prisma.decisionGovernance.findUnique({ where: { shopId } }),\n        prisma.brandVoice.findUnique({ where: { shopId } }),\n        prisma.kPIModel.findUnique({ where: { shopId } }),\n        prisma.customerPersona.findFirst({ where: { shopId, isPrimary: true } }),\n    ]);\n\n    if (!identity) {\n        return null; // Onboarding not complete\n    }\n\n    return {\n        brandName: identity.brandName,\n        mission: identity.mission,\n        promise: identity.promise,\n        positioning: identity.positioning as BrandDNA['positioning'],\n        coreValues: identity.coreValues,\n        antiValues: identity.antiValues,\n        toneAttributes: voice?.toneAttributes || [],\n        neverLanguage: voice?.neverLanguage || [],\n        primaryPersona: persona ? {\n            name: persona.name,\n            jobToBeDone: persona.jobToBeDone,\n            triggers: persona.triggers,\n            objections: persona.objections,\n        } : null,\n        riskTolerance: governance?.riskTolerance || 'medium',\n        priorityAreas: governance?.priorityAreas || [],\n        northStarMetric: kpi?.northStarMetric || 'Revenue',\n    };\n}\n\n/**\n * Generate the system prompt for LLM calls based on Brand DNA.\n */\nexport function generateBrandSystemPrompt(dna: BrandDNA): string {\n    const personaSection = dna.primaryPersona\n        ? `\nPRIMARY PERSONA: ${dna.primaryPersona.name}\n- Job to be Done: ${dna.primaryPersona.jobToBeDone}\n- Purchase Triggers: ${dna.primaryPersona.triggers.join(', ')}\n- Common Objections: ${dna.primaryPersona.objections.join(', ')}`\n        : '';\n\n    return `You are the strategic brain for ${dna.brandName}.\n\nBRAND IDENTITY:\n- Mission: ${dna.mission}\n- Promise: ${dna.promise}\n- Core Values: ${dna.coreValues.join(', ')}\n- We are NOT: ${dna.antiValues.join(', ')}\n\nPOSITIONING:\nFor ${dna.positioning.target} who need ${dna.positioning.category},\nwe are the only ${dna.positioning.differentiator} because ${dna.positioning.proof}.\n\nVOICE & TONE:\n- Tone: ${dna.toneAttributes.join(', ')}\n- NEVER use these words: ${dna.neverLanguage.join(', ')}\n${personaSection}\n\nDECISION CONTEXT:\n- Risk Tolerance: ${dna.riskTolerance}\n- Priority Areas: ${dna.priorityAreas.join(', ')}\n- North Star Metric: ${dna.northStarMetric}\n\nINSTRUCTIONS:\nAlways reason like the brand's CEO. Protect brand identity above short-term gains.\nEvery recommendation must align with the brand's values and speak to the primary persona.\nWhen in doubt, default to the brand's stated positioning and voice guidelines.`;\n}\n"],"names":[],"mappings":";;;;;;AAAA;AAAA;;AA+BO,eAAe,gBAAgB,MAAc;IAChD,MAAM,CAAC,UAAU,YAAY,OAAO,KAAK,QAAQ,GAAG,MAAM,QAAQ,GAAG,CAAC;QAClE,6IAAM,CAAC,aAAa,CAAC,UAAU,CAAC;YAAE,OAAO;gBAAE;YAAO;QAAE;QACpD,6IAAM,CAAC,kBAAkB,CAAC,UAAU,CAAC;YAAE,OAAO;gBAAE;YAAO;QAAE;QACzD,6IAAM,CAAC,UAAU,CAAC,UAAU,CAAC;YAAE,OAAO;gBAAE;YAAO;QAAE;QACjD,6IAAM,CAAC,QAAQ,CAAC,UAAU,CAAC;YAAE,OAAO;gBAAE;YAAO;QAAE;QAC/C,6IAAM,CAAC,eAAe,CAAC,SAAS,CAAC;YAAE,OAAO;gBAAE;gBAAQ,WAAW;YAAK;QAAE;KACzE;IAED,IAAI,CAAC,UAAU;QACX,OAAO,MAAM,0BAA0B;IAC3C;IAEA,OAAO;QACH,WAAW,SAAS,SAAS;QAC7B,SAAS,SAAS,OAAO;QACzB,SAAS,SAAS,OAAO;QACzB,aAAa,SAAS,WAAW;QACjC,YAAY,SAAS,UAAU;QAC/B,YAAY,SAAS,UAAU;QAC/B,gBAAgB,OAAO,kBAAkB,EAAE;QAC3C,eAAe,OAAO,iBAAiB,EAAE;QACzC,gBAAgB,UAAU;YACtB,MAAM,QAAQ,IAAI;YAClB,aAAa,QAAQ,WAAW;YAChC,UAAU,QAAQ,QAAQ;YAC1B,YAAY,QAAQ,UAAU;QAClC,IAAI;QACJ,eAAe,YAAY,iBAAiB;QAC5C,eAAe,YAAY,iBAAiB,EAAE;QAC9C,iBAAiB,KAAK,mBAAmB;IAC7C;AACJ;AAKO,SAAS,0BAA0B,GAAa;IACnD,MAAM,iBAAiB,IAAI,cAAc,GACnC,CAAC;iBACM,EAAE,IAAI,cAAc,CAAC,IAAI,CAAC;kBACzB,EAAE,IAAI,cAAc,CAAC,WAAW,CAAC;qBAC9B,EAAE,IAAI,cAAc,CAAC,QAAQ,CAAC,IAAI,CAAC,MAAM;qBACzC,EAAE,IAAI,cAAc,CAAC,UAAU,CAAC,IAAI,CAAC,OAAO,GACvD;IAEN,OAAO,CAAC,gCAAgC,EAAE,IAAI,SAAS,CAAC;;;WAGjD,EAAE,IAAI,OAAO,CAAC;WACd,EAAE,IAAI,OAAO,CAAC;eACV,EAAE,IAAI,UAAU,CAAC,IAAI,CAAC,MAAM;cAC7B,EAAE,IAAI,UAAU,CAAC,IAAI,CAAC,MAAM;;;IAGtC,EAAE,IAAI,WAAW,CAAC,MAAM,CAAC,UAAU,EAAE,IAAI,WAAW,CAAC,QAAQ,CAAC;gBAClD,EAAE,IAAI,WAAW,CAAC,cAAc,CAAC,SAAS,EAAE,IAAI,WAAW,CAAC,KAAK,CAAC;;;QAG1E,EAAE,IAAI,cAAc,CAAC,IAAI,CAAC,MAAM;yBACf,EAAE,IAAI,aAAa,CAAC,IAAI,CAAC,MAAM;AACxD,EAAE,eAAe;;;kBAGC,EAAE,IAAI,aAAa,CAAC;kBACpB,EAAE,IAAI,aAAa,CAAC,IAAI,CAAC,MAAM;qBAC5B,EAAE,IAAI,eAAe,CAAC;;;;;8EAKmC,CAAC;AAC/E"}},
    {"offset": {"line": 8135, "column": 0}, "map": {"version":3,"sources":["file:///Users/mac/Desktop/NEW/packages/brain/src/engine/orchestrator.ts"],"sourcesContent":["import OpenAI from 'openai';\nimport { prisma } from '@brandmind/shared';\nimport { Candidate } from './decision';\nimport { getTopProducts } from './metrics';\nimport { compileBrandDNA, generateBrandSystemPrompt } from '../compiler';\n\n// OpenAI client is initialized lazily within functions to ensure \n// environment variables (OPENAI_API_KEY) are loaded before usage.\n\n\nexport async function explainRecommendation(shopId: string, candidate: Candidate) {\n    const openai = new OpenAI();\n\n    const memory = await prisma.businessMemorySnapshot.findFirst({\n        where: { shopId },\n        orderBy: { date: 'desc' },\n    });\n\n    const activeGoal = await prisma.goal.findFirst({\n        where: { shopId },\n        orderBy: { createdAt: 'desc' },\n    });\n\n    const prompt = `\n    You are BrandMindAI, a business decision OS. \n    Explain this ${candidate.type} to a merchant.\n    \n    Candidate Data:\n    ${JSON.stringify(candidate, null, 2)}\n    \n    Business Profile:\n    ${JSON.stringify(memory?.snapshot || {}, null, 2)}\n    \n    Current Goal:\n    ${JSON.stringify(activeGoal || {}, null, 2)}\n    \n    Response format:\n    - Why this matters (1-2 sentences)\n    - Evidence highlights (bullet points)\n    - Recommended test/next step\n    - Assumptions made\n  `;\n\n    const response = await openai.chat.completions.create({\n        model: 'gpt-4o',\n        messages: [{ role: 'system', content: prompt }],\n        temperature: 0.7,\n    });\n\n    return response.choices[0].message.content;\n}\n\nexport async function askTheBusiness(shopId: string, question: string) {\n    const openai = new OpenAI();\n\n    // Get Brand DNA for system prompt\n    const brandDNA = await compileBrandDNA(shopId);\n    const brandSystemPrompt = brandDNA ? generateBrandSystemPrompt(brandDNA) : 'You are BrandMindAI, an AI assistant for Shopify merchants.';\n\n    // Enhanced RAG: pull latest metrics, memory, top products, and recent alerts\n    const memory = await prisma.businessMemorySnapshot.findFirst({\n        where: { shopId },\n        orderBy: { date: 'desc' },\n    });\n\n    const metrics = await prisma.dailyMetric.findMany({\n        where: { shopId },\n        orderBy: { date: 'desc' },\n        take: 7,\n    });\n\n    // Get top-selling products for product-specific questions\n    const topProducts = await getTopProducts(shopId, 10);\n\n    // Get recent refunds for quality-related questions\n    const last7Days = new Date();\n    last7Days.setDate(last7Days.getDate() - 7);\n\n    const recentRefunds = await prisma.refund.findMany({\n        where: {\n            order: { shopId },\n            createdAt: { gte: last7Days },\n        },\n        include: {\n            order: {\n                include: { lineItems: true },\n            },\n        },\n        take: 20,\n    });\n\n    const refundSummary = recentRefunds.map((r: any) => ({\n        amount: Number(r.amount),\n        date: r.createdAt.toISOString().split('T')[0],\n        products: r.order.lineItems.map((li: any) => li.title).join(', '),\n    }));\n\n    // Get active goal for context\n    const activeGoal = await prisma.goal.findFirst({\n        where: { shopId },\n        orderBy: { createdAt: 'desc' },\n    });\n\n    const userPrompt = `\n=== RECENT DAILY METRICS (Last 7 Days) ===\n${metrics.map((m: any) => `${m.date.toISOString().split('T')[0]}: Revenue $${Number(m.netRevenue).toFixed(2)}, Orders: ${m.orderCount}, AOV: $${Number(m.aov).toFixed(2)}, Refunds: $${Number(m.refundAmount).toFixed(2)}`).join('\\n')}\n\n=== TOP SELLING PRODUCTS (Last 30 Days) ===\n${topProducts.map((p: any, i: number) => `${i + 1}. ${p.productTitle} ${p.variantTitle ? `(${p.variantTitle})` : ''}: $${p.revenue.toFixed(2)} revenue, ${p.unitsSold} units`).join('\\n')}\n\n=== RECENT REFUNDS (Last 7 Days) ===\n${refundSummary.length > 0 ? refundSummary.map(r => `${r.date}: $${r.amount.toFixed(2)} - Products: ${r.products}`).join('\\n') : 'No refunds in the last 7 days'}\n\n=== CURRENT BUSINESS GOAL ===\n${activeGoal ? `${activeGoal.type} - Priority: ${activeGoal.priority}` : 'No goal set'}\n\n=== MERCHANT QUESTION ===\n${question}\n\n=== RULES ===\n- Only use the data provided above.\n- If you don't have the data to answer, say so clearly.\n- Cite specific numbers when possible.\n- Keep responses concise and actionable.\n- Align your response with the brand's identity and voice.\n  `;\n\n    const response = await openai.chat.completions.create({\n        model: 'gpt-4o',\n        messages: [\n            { role: 'system', content: brandSystemPrompt },\n            { role: 'user', content: userPrompt },\n        ],\n        temperature: 0.7,\n    });\n\n    return response.choices[0].message.content;\n}\n"],"names":[],"mappings":"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"}},
    {"offset": {"line": 8308, "column": 0}, "map": {"version":3,"sources":["file:///Users/mac/Desktop/NEW/packages/brain/src/engine/goals.ts"],"sourcesContent":["import { prisma } from '@brandmind/shared';\n\nexport enum GoalType {\n    REVENUE_GROWTH = 'REVENUE_GROWTH',\n    REFUND_REDUCTION = 'REFUND_REDUCTION',\n    AOV_GROWTH = 'AOV_GROWTH',\n    ACQUISITION = 'ACQUISITION',\n}\n\nexport interface GoalWeights {\n    revenueWeight: number;\n    refundWeight: number;\n    aovWeight: number;\n    riskWeight: number;\n}\n\nexport async function getGoalWeights(shopId: string): Promise<GoalWeights> {\n    const activeGoal = await prisma.goal.findFirst({\n        where: { shopId },\n        orderBy: { createdAt: 'desc' },\n    });\n\n    if (!activeGoal) {\n        return { revenueWeight: 1, refundWeight: 1, aovWeight: 1, riskWeight: 1 };\n    }\n\n    switch (activeGoal.type as GoalType) {\n        case GoalType.REVENUE_GROWTH:\n            return { revenueWeight: 2.0, refundWeight: 0.8, aovWeight: 1.5, riskWeight: 1.0 };\n        case GoalType.REFUND_REDUCTION:\n            return { revenueWeight: 0.8, refundWeight: 2.5, aovWeight: 1.0, riskWeight: 1.5 };\n        case GoalType.AOV_GROWTH:\n            return { revenueWeight: 1.2, refundWeight: 1.0, aovWeight: 2.5, riskWeight: 1.0 };\n        default:\n            return { revenueWeight: 1, refundWeight: 1, aovWeight: 1, riskWeight: 1 };\n    }\n}\n\nexport async function setGoal(shopId: string, type: GoalType, params: any) {\n    return await prisma.goal.create({\n        data: {\n            shopId,\n            type,\n            targetValue: params.targetValue,\n            timeHorizonDays: params.timeHorizonDays,\n            constraints: params.constraints || {},\n            priority: params.priority || 3,\n        },\n    });\n}\n"],"names":[],"mappings":";;;;;;;;AAAA;AAAA;;AAEO,IAAA,AAAK,kCAAA;;;;;WAAA;;AAcL,eAAe,eAAe,MAAc;IAC/C,MAAM,aAAa,MAAM,6IAAM,CAAC,IAAI,CAAC,SAAS,CAAC;QAC3C,OAAO;YAAE;QAAO;QAChB,SAAS;YAAE,WAAW;QAAO;IACjC;IAEA,IAAI,CAAC,YAAY;QACb,OAAO;YAAE,eAAe;YAAG,cAAc;YAAG,WAAW;YAAG,YAAY;QAAE;IAC5E;IAEA,OAAQ,WAAW,IAAI;QACnB;YACI,OAAO;gBAAE,eAAe;gBAAK,cAAc;gBAAK,WAAW;gBAAK,YAAY;YAAI;QACpF;YACI,OAAO;gBAAE,eAAe;gBAAK,cAAc;gBAAK,WAAW;gBAAK,YAAY;YAAI;QACpF;YACI,OAAO;gBAAE,eAAe;gBAAK,cAAc;gBAAK,WAAW;gBAAK,YAAY;YAAI;QACpF;YACI,OAAO;gBAAE,eAAe;gBAAG,cAAc;gBAAG,WAAW;gBAAG,YAAY;YAAE;IAChF;AACJ;AAEO,eAAe,QAAQ,MAAc,EAAE,IAAc,EAAE,MAAW;IACrE,OAAO,MAAM,6IAAM,CAAC,IAAI,CAAC,MAAM,CAAC;QAC5B,MAAM;YACF;YACA;YACA,aAAa,OAAO,WAAW;YAC/B,iBAAiB,OAAO,eAAe;YACvC,aAAa,OAAO,WAAW,IAAI,CAAC;YACpC,UAAU,OAAO,QAAQ,IAAI;QACjC;IACJ;AACJ"}},
    {"offset": {"line": 8390, "column": 0}, "map": {"version":3,"sources":["file:///Users/mac/Desktop/NEW/packages/brain/src/engine/decision.ts"],"sourcesContent":["import { prisma } from '@brandmind/shared';\nimport { getGoalWeights, GoalType } from './goals';\n\nexport type CandidateType = 'opportunity' | 'danger';\n\nexport interface Candidate {\n    type: CandidateType;\n    title: string;\n    recommended_action: string;\n    impact_estimate: string;\n    confidence: number;\n    effort: 'low' | 'medium' | 'high';\n    risk: 'low' | 'medium' | 'high';\n    evidence: any;\n    assumptions: string[];\n    goal_alignment: number;\n    category?: 'revenue' | 'refund' | 'aov' | 'risk' | 'general';\n}\n\nexport interface RankedCandidate extends Candidate {\n    score: number;\n    priorityBoost: number;\n}\n\nexport abstract class EngineModule {\n    abstract run(shopId: string): Promise<Candidate[]>;\n}\n\nexport class DecisionEngine {\n    private modules: EngineModule[] = [];\n\n    registerModule(module: EngineModule) {\n        this.modules.push(module);\n    }\n\n    async run(shopId: string): Promise<RankedCandidate[]> {\n        const candidates: Candidate[] = [];\n\n        for (const module of this.modules) {\n            try {\n                const results = await module.run(shopId);\n                candidates.push(...results);\n            } catch (error) {\n                console.error(`Module ${module.constructor.name} failed:`, error);\n            }\n        }\n\n        return await this.rankCandidates(shopId, candidates);\n    }\n\n    private async rankCandidates(shopId: string, candidates: Candidate[]): Promise<RankedCandidate[]> {\n        const weights = await getGoalWeights(shopId);\n\n        return candidates\n            .map(c => {\n                // Determine category weight based on candidate type and title\n                let categoryWeight = 1.0;\n                const category = this.inferCategory(c);\n\n                switch (category) {\n                    case 'revenue':\n                        categoryWeight = weights.revenueWeight;\n                        break;\n                    case 'refund':\n                        categoryWeight = weights.refundWeight;\n                        break;\n                    case 'aov':\n                        categoryWeight = weights.aovWeight;\n                        break;\n                    case 'risk':\n                        categoryWeight = weights.riskWeight;\n                        break;\n                }\n\n                // Priority boost for dangers\n                const priorityBoost = c.type === 'danger' ? 1.2 : 1.0;\n\n                // Final score: (Alignment * Category Weight * Priority Boost) * Confidence\n                const score = (c.goal_alignment * categoryWeight * priorityBoost) * c.confidence;\n\n                return {\n                    ...c,\n                    category,\n                    score: Math.round(score * 100) / 100,\n                    priorityBoost,\n                };\n            })\n            .sort((a, b) => {\n                // Dangers always come first, then sort by score\n                if (a.type === 'danger' && b.type !== 'danger') return -1;\n                if (a.type !== 'danger' && b.type === 'danger') return 1;\n                return b.score - a.score;\n            });\n    }\n\n    private inferCategory(candidate: Candidate): 'revenue' | 'refund' | 'aov' | 'risk' | 'general' {\n        const title = candidate.title.toLowerCase();\n\n        if (title.includes('refund') || title.includes('return')) return 'refund';\n        if (title.includes('revenue') || title.includes('sales') || title.includes('restock')) return 'revenue';\n        if (title.includes('bundle') || title.includes('aov') || title.includes('upsell')) return 'aov';\n        if (title.includes('stock') || title.includes('risk') || title.includes('drop')) return 'risk';\n\n        return 'general';\n    }\n}\n"],"names":[],"mappings":";;;;;;AACA;;AAuBO,MAAe;AAEtB;AAEO,MAAM;IACD,UAA0B,EAAE,CAAC;IAErC,eAAe,MAAoB,EAAE;QACjC,IAAI,CAAC,OAAO,CAAC,IAAI,CAAC;IACtB;IAEA,MAAM,IAAI,MAAc,EAA8B;QAClD,MAAM,aAA0B,EAAE;QAElC,KAAK,MAAM,UAAU,IAAI,CAAC,OAAO,CAAE;YAC/B,IAAI;gBACA,MAAM,UAAU,MAAM,OAAO,GAAG,CAAC;gBACjC,WAAW,IAAI,IAAI;YACvB,EAAE,OAAO,OAAO;gBACZ,QAAQ,KAAK,CAAC,CAAC,OAAO,EAAE,OAAO,WAAW,CAAC,IAAI,CAAC,QAAQ,CAAC,EAAE;YAC/D;QACJ;QAEA,OAAO,MAAM,IAAI,CAAC,cAAc,CAAC,QAAQ;IAC7C;IAEA,MAAc,eAAe,MAAc,EAAE,UAAuB,EAA8B;QAC9F,MAAM,UAAU,MAAM,IAAA,6JAAc,EAAC;QAErC,OAAO,WACF,GAAG,CAAC,CAAA;YACD,8DAA8D;YAC9D,IAAI,iBAAiB;YACrB,MAAM,WAAW,IAAI,CAAC,aAAa,CAAC;YAEpC,OAAQ;gBACJ,KAAK;oBACD,iBAAiB,QAAQ,aAAa;oBACtC;gBACJ,KAAK;oBACD,iBAAiB,QAAQ,YAAY;oBACrC;gBACJ,KAAK;oBACD,iBAAiB,QAAQ,SAAS;oBAClC;gBACJ,KAAK;oBACD,iBAAiB,QAAQ,UAAU;oBACnC;YACR;YAEA,6BAA6B;YAC7B,MAAM,gBAAgB,EAAE,IAAI,KAAK,WAAW,MAAM;YAElD,2EAA2E;YAC3E,MAAM,QAAQ,AAAC,EAAE,cAAc,GAAG,iBAAiB,gBAAiB,EAAE,UAAU;YAEhF,OAAO;gBACH,GAAG,CAAC;gBACJ;gBACA,OAAO,KAAK,KAAK,CAAC,QAAQ,OAAO;gBACjC;YACJ;QACJ,GACC,IAAI,CAAC,CAAC,GAAG;YACN,gDAAgD;YAChD,IAAI,EAAE,IAAI,KAAK,YAAY,EAAE,IAAI,KAAK,UAAU,OAAO,CAAC;YACxD,IAAI,EAAE,IAAI,KAAK,YAAY,EAAE,IAAI,KAAK,UAAU,OAAO;YACvD,OAAO,EAAE,KAAK,GAAG,EAAE,KAAK;QAC5B;IACR;IAEQ,cAAc,SAAoB,EAAqD;QAC3F,MAAM,QAAQ,UAAU,KAAK,CAAC,WAAW;QAEzC,IAAI,MAAM,QAAQ,CAAC,aAAa,MAAM,QAAQ,CAAC,WAAW,OAAO;QACjE,IAAI,MAAM,QAAQ,CAAC,cAAc,MAAM,QAAQ,CAAC,YAAY,MAAM,QAAQ,CAAC,YAAY,OAAO;QAC9F,IAAI,MAAM,QAAQ,CAAC,aAAa,MAAM,QAAQ,CAAC,UAAU,MAAM,QAAQ,CAAC,WAAW,OAAO;QAC1F,IAAI,MAAM,QAAQ,CAAC,YAAY,MAAM,QAAQ,CAAC,WAAW,MAAM,QAAQ,CAAC,SAAS,OAAO;QAExF,OAAO;IACX;AACJ"}},
    {"offset": {"line": 8469, "column": 0}, "map": {"version":3,"sources":["file:///Users/mac/Desktop/NEW/packages/brain/src/engine/executive-dashboard.ts"],"sourcesContent":["import { prisma } from '@brandmind/shared';\nimport { Decimal } from '@prisma/client/runtime/library';\n\nexport interface ExecutiveKPIs {\n    revenueMomentum: {\n        value: number; // percentage\n        trend: 'up' | 'down' | 'flat';\n        comparison: 'WoW' | 'MoM';\n    };\n    profitabilityHealth: {\n        score: number; // 0-100\n        status: 'healthy' | 'fragile' | 'critical';\n    };\n    growthQuality: {\n        score: number; // 0-100\n    };\n    customerHealth: {\n        score: number; // 0-100\n    };\n    discountPressure: {\n        value: number; // percentage\n        trend: 'rising' | 'declining' | 'stable';\n    };\n    operationalRisk: {\n        level: 'LOW' | 'MEDIUM' | 'HIGH';\n        signal: string;\n    };\n}\n\nexport async function calculateExecutiveKPIs(shopId: string): Promise<ExecutiveKPIs> {\n    const now = new Date();\n    // Align to midnight to ensure clean windows\n    const todayMidnight = new Date(now);\n    todayMidnight.setHours(0, 0, 0, 0);\n\n    const last7Days = new Date(todayMidnight.getTime() - 7 * 24 * 60 * 60 * 1000);\n    const prev7Days = new Date(todayMidnight.getTime() - 14 * 24 * 60 * 60 * 1000);\n\n    // Fetch current and previous period metrics\n    const currentMetrics = await prisma.dailyMetric.findMany({\n        where: { shopId, date: { gte: last7Days } },\n        orderBy: { date: 'desc' }\n    });\n\n    const previousMetrics = await prisma.dailyMetric.findMany({\n        where: { shopId, date: { gte: prev7Days, lt: last7Days } },\n        orderBy: { date: 'desc' }\n    });\n\n    const currentRevenue = currentMetrics.reduce((sum: Decimal, m: any) => sum.plus(m.netRevenue), new Decimal(0));\n    const previousRevenue = previousMetrics.reduce((sum: Decimal, m: any) => sum.plus(m.netRevenue), new Decimal(0));\n\n    const currentMarketing = currentMetrics.reduce((sum: Decimal, m: any) => sum.plus(m.marketingSpend || 0), new Decimal(0));\n    const currentSessions = currentMetrics.reduce((sum: number, m: any) => sum + (m.sessions || 0), 0);\n    const currentRefunds = currentMetrics.reduce((sum: Decimal, m: any) => sum.plus(m.refundAmount), new Decimal(0));\n\n    // 1. Revenue Momentum\n    let momentum = 0;\n    if (previousRevenue.gt(0)) {\n        momentum = (currentRevenue.minus(previousRevenue)).dividedBy(previousRevenue).toNumber() * 100;\n    } else if (currentRevenue.gt(0)) {\n        momentum = 100; // 100% growth if starting from zero\n    }\n\n    const revenueMomentum: ExecutiveKPIs['revenueMomentum'] = {\n        value: Math.round(momentum * 10) / 10,\n        trend: momentum > 2 ? 'up' : momentum < -2 ? 'down' : 'flat',\n        comparison: 'WoW'\n    };\n\n    // 2. Profitability Health Score (0-100)\n    // formula: 0.45 * Gross Margin + 0.35 * Marketing Efficiency + 0.20 * Discount Pressure (inv)\n\n    // Attempt to calculate real Gross Margin if variants have cost data\n    const variantsWithCost = await prisma.variant.findMany({\n        where: { cost: { not: null } },\n        select: { shopifyId: true, cost: true, price: true }\n    });\n\n    let grossMetric = 0.6; // Baseline 60%\n    if (variantsWithCost.length > 0) {\n        // Simple aggregate margin for now\n        const avgMargin = variantsWithCost.reduce((sum, v) => {\n            const price = v.price.toNumber();\n            const cost = v.cost?.toNumber() || 0;\n            return sum + (price > 0 ? (price - cost) / price : 0);\n        }, 0) / variantsWithCost.length;\n        grossMetric = Math.max(0.1, Math.min(0.9, avgMargin));\n    }\n\n    const roas = currentMarketing.gt(0) ? currentRevenue.dividedBy(currentMarketing).toNumber() : 5; // Default 5x if no spend\n    const marketingEfficiency = Math.min(1, roas / 10); // Normalize to 10x ROAS\n    const discountPressureVal = currentRevenue.gt(0) ? currentRefunds.dividedBy(currentRevenue).toNumber() : 0;\n    const invDiscountPressure = 1 - discountPressureVal;\n\n    const profitabilityScoreRaw = (0.45 * grossMetric + 0.35 * marketingEfficiency + 0.20 * invDiscountPressure) * 100;\n    const profitabilityScore = Math.min(100, Math.max(0, Math.round(profitabilityScoreRaw)));\n\n    const profitabilityHealth: ExecutiveKPIs['profitabilityHealth'] = {\n        score: profitabilityScore,\n        status: profitabilityScore >= 75 ? 'healthy' : profitabilityScore >= 55 ? 'fragile' : 'critical'\n    };\n\n    // 3. Growth Quality Score (0-100)\n    // Sustainable growth index: combines momentum (volume) and efficiency (profitability)\n    const momentumBonus = momentum > 10 ? 20 : momentum > 0 ? 10 : -10;\n    const growthQualityScoreRaw = (marketingEfficiency * 70) + (momentumBonus) + 10;\n    const growthQualityScore = Math.min(100, Math.max(0, Math.round(growthQualityScoreRaw)));\n\n    // 4. Customer Health Indicator (0-100)\n    const newCustomers = currentMetrics.reduce((sum: number, m: any) => sum + m.newCustomersCount, 0);\n    const returningCustomers = currentMetrics.reduce((sum: number, m: any) => sum + m.returningCustomersCount, 0);\n    const totalCustomers = newCustomers + returningCustomers;\n    const repeatRate = totalCustomers > 0 ? returningCustomers / totalCustomers : 0;\n\n    // Logic: NEW stores shouldn't be penalized for 0 repeats. \n    // If we have high new customer acquisition, we start healthy.\n    const acquisitionStrength = Math.min(1, newCustomers / 10); // 10 new customers/week is decent for simulation\n    const customerHealthScoreRaw = (repeatRate * 60) + (acquisitionStrength * 40);\n    const customerHealthScore = Math.min(100, Math.max(20, Math.round(customerHealthScoreRaw)));\n\n    // 5. Pricing & Discount Pressure Index\n    const discountPressure: ExecutiveKPIs['discountPressure'] = {\n        value: Math.round(discountPressureVal * 100),\n        trend: discountPressureVal > 0.15 ? 'rising' : 'stable'\n    };\n\n    // 6. Operational Risk Signal\n    const currentFulfillmentTime = currentMetrics.length > 0\n        ? currentMetrics.reduce((sum: number, m: any) => sum + (m.fulfillmentTime || 0), 0) / currentMetrics.length\n        : 0;\n\n    const refundRate = currentRevenue.gt(0) ? currentRefunds.dividedBy(currentRevenue).toNumber() : 0;\n\n    let riskLevel: 'LOW' | 'MEDIUM' | 'HIGH' = 'LOW';\n    let riskSignal = 'Operational metrics are stable across all departments.';\n\n    if (refundRate > 0.2 || discountPressureVal > 0.3) {\n        riskLevel = 'HIGH';\n        riskSignal = refundRate > 0.2\n            ? 'Critical refund spike detected. Audit product quality and fulfillment accuracy immediately.'\n            : 'Extreme discounting is destroying margin profile.';\n    } else if (currentFulfillmentTime > 4 || momentum < -15) {\n        riskLevel = 'MEDIUM';\n        riskSignal = currentFulfillmentTime > 4\n            ? 'Fulfillment latency detected. Scale up logistics capacity.'\n            : 'Significant revenue contraction. Investigate demand drop-off.';\n    }\n\n    return {\n        revenueMomentum,\n        profitabilityHealth,\n        growthQuality: { score: growthQualityScore },\n        customerHealth: { score: customerHealthScore },\n        discountPressure,\n        operationalRisk: { level: riskLevel, signal: riskSignal }\n    };\n}\n\n\nexport async function generateExecutiveBrief(shopId: string, kpis: ExecutiveKPIs): Promise<string> {\n    // FALLBACK GENERATOR: If API key is missing or AI fails, we use a deterministic rule-based brief\n    const getFallbackBrief = () => {\n        const health = kpis.profitabilityHealth.status;\n        const trend = kpis.revenueMomentum.trend === 'up' ? 'positive' : 'concerning';\n        const risk = kpis.operationalRisk.level === 'HIGH' ? 'Critical' : 'Moderate';\n\n        return `Current performance is ${health} with a ${trend} revenue trajectory. ${kpis.operationalRisk.signal} ${risk} operational risks detected in the supply chain. Prioritize margin protection in the next 72 hours.`;\n    };\n\n    if (!process.env.OPENAI_API_KEY) {\n        console.warn('OPENAI_API_KEY missing - using rule-based fallback for Executive Brief');\n        return getFallbackBrief();\n    }\n\n    try {\n        const { OpenAI } = await import('openai');\n        const openai = new OpenAI({ apiKey: process.env.OPENAI_API_KEY });\n\n        const prompt = `\n        You are BrandMindAI, an AI Executive Business Partner for a Shopify brand.\n        Analyze the following 6 Executive KPIs and provide a concise \"Executive Brief\" (3-4 sentences).\n        \n        KPIs:\n        1. Revenue Momentum: ${kpis.revenueMomentum.value}% (${kpis.revenueMomentum.trend})\n        2. Profitability Health: ${kpis.profitabilityHealth.score}/100 (${kpis.profitabilityHealth.status})\n        3. Growth Quality: ${kpis.growthQuality.score}/100\n        4. Customer Health: ${kpis.customerHealth.score}/100\n        5. Discount Pressure: ${kpis.discountPressure.value}% (${kpis.discountPressure.trend})\n        6. Operational Risk: ${kpis.operationalRisk.level} - ${kpis.operationalRisk.signal}\n\n        Rules:\n        - Answer: Is the business healthy? Where is risk? Where is opportunity?\n        - Keep it under 100 words.\n        - Be direct, executive, and non-generic.\n        - Format as a single paragraph or clean bullet points.\n      `;\n\n        const response = await openai.chat.completions.create({\n            model: 'gpt-4o',\n            messages: [{ role: 'system', content: prompt }],\n            temperature: 0.7,\n            max_tokens: 200,\n        });\n\n        return response.choices[0].message.content || getFallbackBrief();\n    } catch (error) {\n        console.error('LLM Brief generation failed:', error);\n        return getFallbackBrief();\n    }\n}\n"],"names":[],"mappings":"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"}},
    {"offset": {"line": 8672, "column": 0}, "map": {"version":3,"sources":["file:///Users/mac/Desktop/NEW/packages/brain/src/rag/context.ts"],"sourcesContent":["import { prisma } from '@brandmind/shared';\n\ninterface StoreContext {\n    summary: string;\n    products: string;\n    orderPatterns: string;\n    topSellers: string;\n    recentActivity: string;\n}\n\nexport async function buildStoreContext(shopId: string): Promise<StoreContext> {\n    // Get product stats\n    const productCount = await prisma.product.count({ where: { shopId } });\n    const products = await prisma.product.findMany({\n        where: { shopId },\n        include: { variants: true },\n        take: 50, // Top 50 products\n        orderBy: { createdAt: 'desc' }\n    });\n\n    // Get order stats\n    const orderCount = await prisma.order.count({ where: { shopId } });\n    const orderStats = await prisma.order.aggregate({\n        where: { shopId },\n        _sum: { totalPrice: true },\n        _avg: { totalPrice: true },\n    });\n\n    const customerCount = await prisma.customer.count({ where: { shopId } });\n    const refundCount = await prisma.refund.count({ where: { order: { shopId } } });\n\n    // Get recent orders for activity\n    const recentOrders = await prisma.order.findMany({\n        where: { shopId },\n        orderBy: { createdAt: 'desc' },\n        take: 10,\n        include: { lineItems: true }\n    });\n\n    // Build context strings\n    const summary = `\nStore Overview:\n- Total Products: ${productCount}\n- Total Variants: ${products.reduce((sum, p) => sum + p.variants.length, 0)}\n- Total Orders: ${orderCount}\n- Total Revenue: $${orderStats._sum.totalPrice?.toFixed(2) || '0'}\n- Average Order Value: $${orderStats._avg.totalPrice?.toFixed(2) || '0'}\n- Total Customers: ${customerCount}\n- Total Refunds: ${refundCount}\n- Refund Rate: ${orderCount > 0 ? ((refundCount / orderCount) * 100).toFixed(1) : 0}%\n    `.trim();\n\n    const productList = products.slice(0, 20).map(p => {\n        const variantInfo = p.variants.map(v =>\n            `${v.title}: $${v.price}, ${v.inventoryQuantity || 0} in stock`\n        ).join('; ');\n        return `- ${p.title} (${p.productType || 'No category'}): ${variantInfo}`;\n    }).join('\\n');\n\n    const productContext = `\nTop Products (${Math.min(20, products.length)} of ${productCount}):\n${productList}\n    `.trim();\n\n    // Calculate top sellers from order line items\n    const lineItems = await prisma.orderLineItem.groupBy({\n        by: ['title'],\n        where: { order: { shopId } },\n        _count: { id: true },\n        _sum: { quantity: true },\n        orderBy: { _sum: { quantity: 'desc' } },\n        take: 10\n    });\n\n    const topSellers = `\nTop 10 Best-Selling Products:\n${lineItems.map((item, i) =>\n        `${i + 1}. ${item.title}: ${item._sum.quantity || 0} units sold`\n    ).join('\\n')}\n    `.trim();\n\n    // Recent activity\n    const recentActivityText = `\nRecent Orders (Last 10):\n${recentOrders.map(o => {\n        const items = o.lineItems.map(li => li.title).join(', ');\n        return `- Order #${o.orderNumber}: $${o.totalPrice} (${items.substring(0, 50)}${items.length > 50 ? '...' : ''})`;\n    }).join('\\n')}\n    `.trim();\n\n    // Aggregate order patterns by month\n    const orderPatterns = `\nOrder Trends:\n- Currency: ${recentOrders[0]?.currency || 'USD'}\n- Most recent order: ${recentOrders[0]?.createdAt?.toISOString().split('T')[0] || 'N/A'}\n- Oldest order in sample: ${recentOrders[recentOrders.length - 1]?.createdAt?.toISOString().split('T')[0] || 'N/A'}\n    `.trim();\n\n    return {\n        summary,\n        products: productContext,\n        orderPatterns,\n        topSellers,\n        recentActivity: recentActivityText\n    };\n}\n\nexport function formatContextForPrompt(context: StoreContext): string {\n    return `\n=== STORE DATA CONTEXT ===\n\n${context.summary}\n\n${context.topSellers}\n\n${context.products}\n\n${context.orderPatterns}\n\n${context.recentActivity}\n\n=== END CONTEXT ===\n    `.trim();\n}\n"],"names":[],"mappings":"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"}},
    {"offset": {"line": 8835, "column": 0}, "map": {"version":3,"sources":["file:///Users/mac/Desktop/NEW/packages/brain/src/index.ts"],"sourcesContent":["// BrandMindAI Brain - Core Intelligence Layer\n// This package contains all AI/ML logic, analysis engines, and agents\n\n// Intelligence modules\nexport * from './intelligence/store-dna';\nexport * from './intelligence/gap-detector';\nexport * from './intelligence/trends';\nexport * from './intelligence/evidence';\nexport * from './intelligence/public-analyzer';\nexport * from './intelligence/product-research';\nexport * from './intelligence/data-sufficiency';\nexport * from './intelligence/dna-completeness';\nexport * from './intelligence/strategy-router';\nexport * from './intelligence/dna-seeder';\nexport * from './intelligence/insights-engine';\n\n// Agents\nexport * from './agents/launch-kit-agent';\nexport * from './agents/retention-agent';\n\n// NextHit Engine\nexport * from './nexthit/deterministic-scorer';\nexport * from './nexthit/candidate-generator';\nexport * from './nexthit/candidate-scorer';\nexport * from './nexthit/deep-analyzer';\nexport * from './nexthit/background-analyzer';\nexport * from './nexthit/outcome-tracker';\n\n// Engine modules\nexport * from './engine/metrics';\nexport * from './engine/orchestrator';\nexport * from './engine/decision';\nexport * from './engine/executive-dashboard';\n\n// RAG\nexport * from './rag/context';\n\n// Compiler\nexport * from './compiler';\n"],"names":[],"mappings":";AAAA,8CAA8C;AAC9C,sEAAsE;AAEtE,uBAAuB;AACvB;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AAEA,SAAS;AACT;AACA;AAEA,iBAAiB;AACjB;AACA;AACA;AACA;AACA;AACA;AAEA,iBAAiB;AACjB;AACA;AACA;AACA;AAEA,MAAM;AACN;AAEA,WAAW;AACX"}},
    {"offset": {"line": 8907, "column": 0}, "map": {"version":3,"sources":["file:///Users/mac/Desktop/NEW/packages/frontend/src/app/actions/insights.ts"],"sourcesContent":["'use server';\n\nimport { getCurrentShop } from '@brandmind/backend/auth/session';\nimport {\n    calculateCatalogHealth,\n    getPatternInsights,\n    gradeProducts,\n    suggestBundles,\n    getPriceAlerts,\n    getSeasonalCalendar,\n    detectCannibalization,\n    analyzeCustomerCohorts,\n    predictRestocks,\n    findMarketingMoments,\n    CatalogHealth,\n    PatternInsight,\n    ProductGrade,\n    BundleSuggestion,\n    PriceAlert,\n    SeasonalMonth,\n    CannibalizationPair,\n    CustomerCohort,\n    RestockAlert,\n    MarketingMoment\n} from '@brandmind/brain';\n\nexport interface InsightsDashboardData {\n    catalogHealth: CatalogHealth;\n    patternInsights: PatternInsight[];\n    topProducts: ProductGrade[];\n    bundles: BundleSuggestion[];\n    priceAlerts: PriceAlert[];\n    seasonalCalendar: SeasonalMonth[];\n    cannibalization: CannibalizationPair[];\n    customerCohorts: CustomerCohort[];\n    restockAlerts: RestockAlert[];\n    marketingMoments: MarketingMoment[];\n}\n\nexport async function getInsightsDashboard(): Promise<InsightsDashboardData | null> {\n    const shop = await getCurrentShop();\n    if (!shop) return null;\n\n    try {\n        const [\n            catalogHealth,\n            patternInsights,\n            allProducts,\n            bundles,\n            priceAlerts,\n            seasonalCalendar,\n            cannibalization,\n            customerCohorts,\n            restockAlerts,\n            marketingMoments\n        ] = await Promise.all([\n            calculateCatalogHealth(shop.id),\n            getPatternInsights(shop.id),\n            gradeProducts(shop.id),\n            suggestBundles(shop.id),\n            getPriceAlerts(shop.id),\n            getSeasonalCalendar(shop.id),\n            detectCannibalization(shop.id),\n            analyzeCustomerCohorts(shop.id),\n            predictRestocks(shop.id),\n            findMarketingMoments(shop.id)\n        ]);\n\n        return {\n            catalogHealth,\n            patternInsights,\n            topProducts: allProducts.slice(0, 10),\n            bundles,\n            priceAlerts,\n            seasonalCalendar,\n            cannibalization,\n            customerCohorts,\n            restockAlerts,\n            marketingMoments\n        };\n    } catch (error) {\n        console.error('[Insights] Error fetching dashboard data:', error);\n        return null;\n    }\n}\n\nexport async function getCatalogHealth(): Promise<CatalogHealth | null> {\n    const shop = await getCurrentShop();\n    if (!shop) return null;\n    return calculateCatalogHealth(shop.id);\n}\n\nexport async function getPatterns(): Promise<PatternInsight[]> {\n    const shop = await getCurrentShop();\n    if (!shop) return [];\n    return getPatternInsights(shop.id);\n}\n\nexport async function getProductGrades(): Promise<ProductGrade[]> {\n    const shop = await getCurrentShop();\n    if (!shop) return [];\n    return gradeProducts(shop.id);\n}\n\nexport async function getBundleSuggestions(): Promise<BundleSuggestion[]> {\n    const shop = await getCurrentShop();\n    if (!shop) return [];\n    return suggestBundles(shop.id);\n}\n\nexport async function getCustomerSegments(): Promise<CustomerCohort[]> {\n    const shop = await getCurrentShop();\n    if (!shop) return [];\n    return analyzeCustomerCohorts(shop.id);\n}\n\nexport async function getRestockPredictions(): Promise<RestockAlert[]> {\n    const shop = await getCurrentShop();\n    if (!shop) return [];\n    return predictRestocks(shop.id);\n}\n\nexport async function getMarketingOpportunities(): Promise<MarketingMoment[]> {\n    const shop = await getCurrentShop();\n    if (!shop) return [];\n    return findMarketingMoments(shop.id);\n}\n"],"names":[],"mappings":";;;;;;;;;;;;;;;;;;;AAEA;AACA;AAAA;;;;;;;;;AAoCO,eAAe;IAClB,MAAM,OAAO,MAAM,IAAA,+JAAc;IACjC,IAAI,CAAC,MAAM,OAAO;IAElB,IAAI;QACA,MAAM,CACF,eACA,iBACA,aACA,SACA,aACA,kBACA,iBACA,iBACA,eACA,iBACH,GAAG,MAAM,QAAQ,GAAG,CAAC;YAClB,IAAA,wLAAsB,EAAC,KAAK,EAAE;YAC9B,IAAA,oLAAkB,EAAC,KAAK,EAAE;YAC1B,IAAA,+KAAa,EAAC,KAAK,EAAE;YACrB,IAAA,gLAAc,EAAC,KAAK,EAAE;YACtB,IAAA,gLAAc,EAAC,KAAK,EAAE;YACtB,IAAA,qLAAmB,EAAC,KAAK,EAAE;YAC3B,IAAA,uLAAqB,EAAC,KAAK,EAAE;YAC7B,IAAA,wLAAsB,EAAC,KAAK,EAAE;YAC9B,IAAA,iLAAe,EAAC,KAAK,EAAE;YACvB,IAAA,sLAAoB,EAAC,KAAK,EAAE;SAC/B;QAED,OAAO;YACH;YACA;YACA,aAAa,YAAY,KAAK,CAAC,GAAG;YAClC;YACA;YACA;YACA;YACA;YACA;YACA;QACJ;IACJ,EAAE,OAAO,OAAO;QACZ,QAAQ,KAAK,CAAC,6CAA6C;QAC3D,OAAO;IACX;AACJ;AAEO,eAAe;IAClB,MAAM,OAAO,MAAM,IAAA,+JAAc;IACjC,IAAI,CAAC,MAAM,OAAO;IAClB,OAAO,IAAA,wLAAsB,EAAC,KAAK,EAAE;AACzC;AAEO,eAAe;IAClB,MAAM,OAAO,MAAM,IAAA,+JAAc;IACjC,IAAI,CAAC,MAAM,OAAO,EAAE;IACpB,OAAO,IAAA,oLAAkB,EAAC,KAAK,EAAE;AACrC;AAEO,eAAe;IAClB,MAAM,OAAO,MAAM,IAAA,+JAAc;IACjC,IAAI,CAAC,MAAM,OAAO,EAAE;IACpB,OAAO,IAAA,+KAAa,EAAC,KAAK,EAAE;AAChC;AAEO,eAAe;IAClB,MAAM,OAAO,MAAM,IAAA,+JAAc;IACjC,IAAI,CAAC,MAAM,OAAO,EAAE;IACpB,OAAO,IAAA,gLAAc,EAAC,KAAK,EAAE;AACjC;AAEO,eAAe;IAClB,MAAM,OAAO,MAAM,IAAA,+JAAc;IACjC,IAAI,CAAC,MAAM,OAAO,EAAE;IACpB,OAAO,IAAA,wLAAsB,EAAC,KAAK,EAAE;AACzC;AAEO,eAAe;IAClB,MAAM,OAAO,MAAM,IAAA,+JAAc;IACjC,IAAI,CAAC,MAAM,OAAO,EAAE;IACpB,OAAO,IAAA,iLAAe,EAAC,KAAK,EAAE;AAClC;AAEO,eAAe;IAClB,MAAM,OAAO,MAAM,IAAA,+JAAc;IACjC,IAAI,CAAC,MAAM,OAAO,EAAE;IACpB,OAAO,IAAA,sLAAoB,EAAC,KAAK,EAAE;AACvC;;;IAvFsB;IA+CA;IAMA;IAMA;IAMA;IAMA;IAMA;IAMA;;AAnFA,+OAAA;AA+CA,+OAAA;AAMA,+OAAA;AAMA,+OAAA;AAMA,+OAAA;AAMA,+OAAA;AAMA,+OAAA;AAMA,+OAAA"}},
    {"offset": {"line": 9031, "column": 0}, "map": {"version":3,"sources":["file:///Users/mac/Desktop/NEW/packages/frontend/.next-internal/server/app/%28app%29/command-center/page/actions.js%20%28server%20actions%20loader%29"],"sourcesContent":["export {getInsightsDashboard as '003511f44a37ebd242f1e43c61f001933c23c3bb17'} from 'ACTIONS_MODULE0'\nexport {getCustomerSegments as '00410d5e7d4d77051d007e1f1751d734b2af67b434'} from 'ACTIONS_MODULE0'\nexport {getMarketingOpportunities as '00638c5a6a08dbaf30597ce6a19dfea9b987d7aa90'} from 'ACTIONS_MODULE0'\nexport {getCatalogHealth as '0074cfaab28a516c833588c82fa49562a2285018a6'} from 'ACTIONS_MODULE0'\nexport {getPatterns as '007b0b3bdcb2b49100f67b862d7ddd6d4d522d7539'} from 'ACTIONS_MODULE0'\nexport {getRestockPredictions as '00a4108298534662364f91d524deed02838093cc8a'} from 'ACTIONS_MODULE0'\nexport {getProductGrades as '00d95144b7abf4de556bd60d1e058895ac0fc19045'} from 'ACTIONS_MODULE0'\nexport {getBundleSuggestions as '00f3b58f8fd85093c6a395bb24ecea057514c332ea'} from 'ACTIONS_MODULE0'\n"],"names":[],"mappings":";AAAA"}}]
}