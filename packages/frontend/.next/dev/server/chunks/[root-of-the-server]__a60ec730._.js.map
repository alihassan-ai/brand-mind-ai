{
  "version": 3,
  "sources": [],
  "sections": [
    {"offset": {"line": 64, "column": 0}, "map": {"version":3,"sources":["file:///Users/mac/Desktop/NEW/packages/shared/src/prisma.ts"],"sourcesContent":["import { PrismaClient } from '@prisma/client';\n\nconst globalForPrisma = global as unknown as { prisma: PrismaClient };\n\nexport const prisma =\n  globalForPrisma.prisma ||\n  new PrismaClient({\n    log: ['query', 'error', 'warn'],\n  });\n\nif (process.env.NODE_ENV !== 'production') globalForPrisma.prisma = prisma;\n"],"names":[],"mappings":";;;;AAAA;;AAEA,MAAM;AAEC,MAAM,SACX,gBAAgB,MAAM,IACtB,IAAI,sMAAY,CAAC;IACf,KAAK;QAAC;QAAS;QAAS;KAAO;AACjC;AAEF,wCAA2C,gBAAgB,MAAM,GAAG"}},
    {"offset": {"line": 83, "column": 0}, "map": {"version":3,"sources":["file:///Users/mac/Desktop/NEW/packages/shared/src/types/index.ts"],"sourcesContent":["// Common types used across packages\n\nexport interface ShopContext {\n  shopId: string;\n  shopDomain: string;\n  accessToken: string;\n}\n\nexport interface DateRange {\n  from: Date;\n  to: Date;\n}\n\nexport interface PaginationOptions {\n  limit?: number;\n  cursor?: string;\n}\n\nexport interface ApiResponse<T> {\n  success: boolean;\n  data?: T;\n  error?: string;\n}\n\nexport interface ScoringWeights {\n  storeFit: number;\n  gapFill: number;\n  trendScore: number;\n  marginPotential: number;\n  competitionLevel: number;\n  seasonalAlignment: number;\n}\n\nexport const DEFAULT_SCORING_WEIGHTS: ScoringWeights = {\n  storeFit: 0.25,\n  gapFill: 0.20,\n  trendScore: 0.15,\n  marginPotential: 0.15,\n  competitionLevel: 0.10,\n  seasonalAlignment: 0.15,\n};\n"],"names":[],"mappings":"AAAA,oCAAoC;;;;;AAiC7B,MAAM,0BAA0C;IACrD,UAAU;IACV,SAAS;IACT,YAAY;IACZ,iBAAiB;IACjB,kBAAkB;IAClB,mBAAmB;AACrB"}},
    {"offset": {"line": 100, "column": 0}, "map": {"version":3,"sources":["file:///Users/mac/Desktop/NEW/packages/shared/src/index.ts"],"sourcesContent":["// Shared exports for BrandMind AI\nexport { prisma } from './prisma';\nexport * from './types';\n"],"names":[],"mappings":";AAAA,kCAAkC;AAClC;AACA"}},
    {"offset": {"line": 110, "column": 0}, "map": {"version":3,"sources":["file:///Users/mac/Desktop/NEW/packages/backend/src/shopify/client.ts"],"sourcesContent":["import { shopifyApi, ApiVersion, LogSeverity, Shopify } from '@shopify/shopify-api';\nimport '@shopify/shopify-api/adapters/web-api';\nimport { prisma } from '@brandmind/shared';\nimport { PrismaSessionStorage } from '@shopify/shopify-app-session-storage-prisma';\n\nlet shopifyInstance: Shopify | null = null;\n\nexport function getShopify(): Shopify {\n    if (shopifyInstance) return shopifyInstance;\n\n    const apiKey = (process.env.SHOPIFY_API_KEY || '').trim();\n    const apiSecretKey = (process.env.SHOPIFY_API_SECRET || '').trim();\n    const appUrl = (process.env.SHOPIFY_APP_URL || '').trim();\n\n    if (!apiKey || apiKey === 'MISSING') {\n        console.error('[Shopify Client] CRITICAL: SHOPIFY_API_KEY is missing or invalid.');\n    }\n\n    shopifyInstance = shopifyApi({\n        apiKey: apiKey || 'MISSING',\n        apiSecretKey: apiSecretKey || 'MISSING',\n        scopes: process.env.SCOPES?.split(',') || ['read_products', 'read_orders', 'read_customers'],\n        hostName: appUrl.replace(/https?:\\/\\//, '') || 'localhost',\n        apiVersion: ApiVersion.October24,\n        isEmbeddedApp: false,\n        logger: {\n            level: LogSeverity.Info,\n        },\n    });\n\n    return shopifyInstance;\n}\n\n// Export a proxy as default for backward compatibility\nconst shopify = new Proxy({} as Shopify, {\n    get(_, prop) {\n        return (getShopify() as any)[prop];\n    }\n});\n\nexport const sessionStorage = new PrismaSessionStorage(prisma);\n\nexport default shopify;\n"],"names":[],"mappings":";;;;;;;;AAAA;AAAA;AACA;AACA;AAAA;AACA;;;;;AAEA,IAAI,kBAAkC;AAE/B,SAAS;IACZ,IAAI,iBAAiB,OAAO;IAE5B,MAAM,SAAS,CAAC,QAAQ,GAAG,CAAC,eAAe,IAAI,EAAE,EAAE,IAAI;IACvD,MAAM,eAAe,CAAC,QAAQ,GAAG,CAAC,kBAAkB,IAAI,EAAE,EAAE,IAAI;IAChE,MAAM,SAAS,CAAC,QAAQ,GAAG,CAAC,eAAe,IAAI,EAAE,EAAE,IAAI;IAEvD,IAAI,CAAC,UAAU,WAAW,WAAW;QACjC,QAAQ,KAAK,CAAC;IAClB;IAEA,kBAAkB,IAAA,2MAAU,EAAC;QACzB,QAAQ,UAAU;QAClB,cAAc,gBAAgB;QAC9B,QAAQ,QAAQ,GAAG,CAAC,MAAM,EAAE,MAAM,QAAQ;YAAC;YAAiB;YAAe;SAAiB;QAC5F,UAAU,OAAO,OAAO,CAAC,eAAe,OAAO;QAC/C,YAAY,2LAAU,CAAC,SAAS;QAChC,eAAe;QACf,QAAQ;YACJ,OAAO,4LAAW,CAAC,IAAI;QAC3B;IACJ;IAEA,OAAO;AACX;AAEA,uDAAuD;AACvD,MAAM,UAAU,IAAI,MAAM,CAAC,GAAc;IACrC,KAAI,CAAC,EAAE,IAAI;QACP,OAAO,AAAC,YAAoB,CAAC,KAAK;IACtC;AACJ;AAEO,MAAM,iBAAiB,IAAI,+NAAoB,CAAC,+IAAM;uCAE9C"}},
    {"offset": {"line": 166, "column": 0}, "map": {"version":3,"sources":["file:///Users/mac/Desktop/NEW/packages/backend/src/shopify/index.ts"],"sourcesContent":["export * from './client';\nexport { default } from './client';\n"],"names":[],"mappings":";AAAA"}},
    {"offset": {"line": 174, "column": 0}, "map": {"version":3,"sources":["file:///Users/mac/Desktop/NEW/packages/backend/src/auth/session.ts"],"sourcesContent":["import { cookies } from 'next/headers';\nimport { prisma } from '@brandmind/shared';\n\nexport async function getConnectedShop(): Promise<string | null> {\n    const cookieStore = await cookies();\n    const cookieDomain = cookieStore.get('shopify_connected_shop')?.value;\n    if (cookieDomain) return cookieDomain;\n\n    // Fallback to user session\n    const shop = await getCurrentShop();\n    return shop?.shopDomain || null;\n}\n\nexport async function getCurrentUser() {\n    const cookieStore = await cookies();\n    const userId = cookieStore.get('user_session')?.value;\n\n    if (!userId) return null;\n\n    const user = await prisma.user.findUnique({\n        where: { id: userId },\n        include: { shops: true },\n    });\n\n    return user;\n}\n\nexport async function getCurrentShop() {\n    const user = await getCurrentUser();\n    if (!user || user.shops.length === 0) return null;\n\n    // Return the first shop (for now, single shop per user)\n    return user.shops[0];\n}\n\nexport async function isOnboardingComplete(): Promise<boolean> {\n    const shop = await getCurrentShop();\n    return shop?.onboardingComplete ?? false;\n}\n"],"names":[],"mappings":";;;;;;;;;;AAAA;AACA;AAAA;;;AAEO,eAAe;IAClB,MAAM,cAAc,MAAM,IAAA,4IAAO;IACjC,MAAM,eAAe,YAAY,GAAG,CAAC,2BAA2B;IAChE,IAAI,cAAc,OAAO;IAEzB,2BAA2B;IAC3B,MAAM,OAAO,MAAM;IACnB,OAAO,MAAM,cAAc;AAC/B;AAEO,eAAe;IAClB,MAAM,cAAc,MAAM,IAAA,4IAAO;IACjC,MAAM,SAAS,YAAY,GAAG,CAAC,iBAAiB;IAEhD,IAAI,CAAC,QAAQ,OAAO;IAEpB,MAAM,OAAO,MAAM,+IAAM,CAAC,IAAI,CAAC,UAAU,CAAC;QACtC,OAAO;YAAE,IAAI;QAAO;QACpB,SAAS;YAAE,OAAO;QAAK;IAC3B;IAEA,OAAO;AACX;AAEO,eAAe;IAClB,MAAM,OAAO,MAAM;IACnB,IAAI,CAAC,QAAQ,KAAK,KAAK,CAAC,MAAM,KAAK,GAAG,OAAO;IAE7C,wDAAwD;IACxD,OAAO,KAAK,KAAK,CAAC,EAAE;AACxB;AAEO,eAAe;IAClB,MAAM,OAAO,MAAM;IACnB,OAAO,MAAM,sBAAsB;AACvC"}},
    {"offset": {"line": 231, "column": 0}, "map": {"version":3,"sources":["file:///Users/mac/Desktop/NEW/packages/backend/src/auth/crypto.ts"],"sourcesContent":["import crypto from 'crypto';\n\nconst ALGORITHM = 'aes-256-cbc';\nconst ENCRYPTION_KEY = process.env.ENCRYPTION_KEY || 'default_key_at_least_32_chars_long!!'; // Use env in prod\nconst IV_LENGTH = 16;\n\nexport function encrypt(text: string): string {\n    const iv = crypto.randomBytes(IV_LENGTH);\n    const cipher = crypto.createCipheriv(ALGORITHM, Buffer.from(ENCRYPTION_KEY.slice(0, 32)), iv);\n    let encrypted = cipher.update(text);\n    encrypted = Buffer.concat([encrypted, cipher.final()]);\n    return iv.toString('hex') + ':' + encrypted.toString('hex');\n}\n\nexport function decrypt(text: string): string {\n    const textParts = text.split(':');\n    const iv = Buffer.from(textParts.shift()!, 'hex');\n    const encryptedText = Buffer.from(textParts.join(':'), 'hex');\n    const decipher = crypto.createDecipheriv(ALGORITHM, Buffer.from(ENCRYPTION_KEY.slice(0, 32)), iv);\n    let decrypted = decipher.update(encryptedText);\n    decrypted = Buffer.concat([decrypted, decipher.final()]);\n    return decrypted.toString();\n}\n"],"names":[],"mappings":";;;;;;AAAA;;AAEA,MAAM,YAAY;AAClB,MAAM,iBAAiB,QAAQ,GAAG,CAAC,cAAc,IAAI,wCAAwC,kBAAkB;AAC/G,MAAM,YAAY;AAEX,SAAS,QAAQ,IAAY;IAChC,MAAM,KAAK,gHAAM,CAAC,WAAW,CAAC;IAC9B,MAAM,SAAS,gHAAM,CAAC,cAAc,CAAC,WAAW,OAAO,IAAI,CAAC,eAAe,KAAK,CAAC,GAAG,MAAM;IAC1F,IAAI,YAAY,OAAO,MAAM,CAAC;IAC9B,YAAY,OAAO,MAAM,CAAC;QAAC;QAAW,OAAO,KAAK;KAAG;IACrD,OAAO,GAAG,QAAQ,CAAC,SAAS,MAAM,UAAU,QAAQ,CAAC;AACzD;AAEO,SAAS,QAAQ,IAAY;IAChC,MAAM,YAAY,KAAK,KAAK,CAAC;IAC7B,MAAM,KAAK,OAAO,IAAI,CAAC,UAAU,KAAK,IAAK;IAC3C,MAAM,gBAAgB,OAAO,IAAI,CAAC,UAAU,IAAI,CAAC,MAAM;IACvD,MAAM,WAAW,gHAAM,CAAC,gBAAgB,CAAC,WAAW,OAAO,IAAI,CAAC,eAAe,KAAK,CAAC,GAAG,MAAM;IAC9F,IAAI,YAAY,SAAS,MAAM,CAAC;IAChC,YAAY,OAAO,MAAM,CAAC;QAAC;QAAW,SAAS,KAAK;KAAG;IACvD,OAAO,UAAU,QAAQ;AAC7B"}},
    {"offset": {"line": 268, "column": 0}, "map": {"version":3,"sources":["file:///Users/mac/Desktop/NEW/packages/backend/src/sync/sync-audit.ts"],"sourcesContent":["import { prisma } from '@brandmind/shared';\n\nexport async function createSyncLog(shopId: string, resource: string) {\n    return await prisma.syncEvent.create({\n        data: {\n            shopId,\n            resource,\n            status: 'running',\n            startedAt: new Date(),\n        }\n    });\n}\n\nexport async function updateSyncLog(logId: string, data: { status: 'success' | 'failed', stats?: any, error?: string }) {\n    return await prisma.syncEvent.update({\n        where: { id: logId },\n        data: {\n            ...data,\n            completedAt: new Date(),\n        }\n    });\n}\n"],"names":[],"mappings":";;;;;;AAAA;AAAA;;AAEO,eAAe,cAAc,MAAc,EAAE,QAAgB;IAChE,OAAO,MAAM,+IAAM,CAAC,SAAS,CAAC,MAAM,CAAC;QACjC,MAAM;YACF;YACA;YACA,QAAQ;YACR,WAAW,IAAI;QACnB;IACJ;AACJ;AAEO,eAAe,cAAc,KAAa,EAAE,IAAmE;IAClH,OAAO,MAAM,+IAAM,CAAC,SAAS,CAAC,MAAM,CAAC;QACjC,OAAO;YAAE,IAAI;QAAM;QACnB,MAAM;YACF,GAAG,IAAI;YACP,aAAa,IAAI;QACrB;IACJ;AACJ"}},
    {"offset": {"line": 302, "column": 0}, "map": {"version":3,"sources":["file:///Users/mac/Desktop/NEW/packages/backend/src/sync/shopify-sync.ts"],"sourcesContent":["import { prisma } from '@brandmind/shared';\nimport { decrypt } from '../auth/crypto';\nimport { createSyncLog, updateSyncLog } from './sync-audit';\n\ninterface ShopifyProduct {\n    id: number;\n    title: string;\n    handle: string;\n    vendor: string;\n    product_type: string;\n    created_at: string;\n    updated_at: string;\n    variants: ShopifyVariant[];\n}\n\ninterface ShopifyVariant {\n    id: number;\n    title: string;\n    sku: string;\n    price: string;\n    inventory_quantity: number;\n}\n\ninterface ShopifyOrder {\n    id: number;\n    order_number: number;\n    total_price: string;\n    subtotal_price: string;\n    total_tax: string;\n    total_discounts: string;\n    currency: string;\n    financial_status: string;\n    fulfillment_status: string | null;\n    created_at: string;\n    updated_at: string;\n    customer?: { id: number };\n    line_items: ShopifyLineItem[];\n    refunds: ShopifyRefund[];\n}\n\ninterface ShopifyLineItem {\n    id: number;\n    product_id: number;\n    variant_id: number;\n    title: string;\n    quantity: number;\n    price: string;\n    total_discount: string;\n}\n\ninterface ShopifyRefund {\n    id: number;\n    created_at: string;\n    transactions: { amount: string }[];\n}\n\ninterface ShopifyCustomer {\n    id: number;\n    email: string;\n    first_name: string;\n    last_name: string;\n    created_at: string;\n}\n\nasync function shopifyRequest(shop: string, accessToken: string, endpoint: string, params: Record<string, string> = {}) {\n    const url = new URL(`https://${shop}/admin/api/2024-10/${endpoint}`);\n    Object.entries(params).forEach(([k, v]) => url.searchParams.set(k, v));\n\n    const response = await fetch(url.toString(), {\n        headers: {\n            'X-Shopify-Access-Token': accessToken,\n            'Content-Type': 'application/json',\n        },\n    });\n\n    if (!response.ok) {\n        const text = await response.text();\n        throw new Error(`Shopify API error (${response.status}): ${text}`);\n    }\n\n    return response.json();\n}\n\nasync function getOrInitSyncState(shopId: string, resource: string) {\n    let state = await prisma.syncState.findUnique({\n        where: {\n            shopId_resource: {\n                shopId,\n                resource,\n            },\n        },\n    });\n\n    if (!state) {\n        state = await prisma.syncState.create({\n            data: {\n                shopId,\n                resource,\n                lastId: '0',\n            },\n        });\n    }\n\n    return state;\n}\n\nasync function updateSyncState(shopId: string, resource: string, lastId: string) {\n    await prisma.syncState.update({\n        where: {\n            shopId_resource: {\n                shopId,\n                resource,\n            },\n        },\n        data: {\n            lastId,\n            lastSyncedAt: new Date(),\n        },\n    });\n}\n\nexport async function syncProducts(shopId: string, shopDomain: string, accessToken: string) {\n    console.log(`[Sync] Fetching products for ${shopDomain}`);\n\n    // incremental sync logic\n    const syncState = await getOrInitSyncState(shopId, 'products');\n    let sinceId = parseInt(syncState.lastId);\n    console.log(`[Sync] Resuming products from ID: ${sinceId}`);\n\n    let totalProducts = 0;\n    let maxId = sinceId;\n\n    while (true) {\n        const data = await shopifyRequest(shopDomain, accessToken, 'products.json', {\n            limit: '250',\n            since_id: sinceId.toString(),\n        }) as { products: ShopifyProduct[] };\n\n        const products: ShopifyProduct[] = data.products || [];\n        if (products.length === 0) break;\n\n        for (const product of products) {\n            // Upsert product\n            const dbProduct = await prisma.product.upsert({\n                where: { shopifyId: product.id.toString() },\n                update: {\n                    title: product.title,\n                    handle: product.handle,\n                    vendor: product.vendor,\n                    productType: product.product_type,\n                    updatedAt: new Date(product.updated_at),\n                },\n                create: {\n                    shopId,\n                    shopifyId: product.id.toString(),\n                    title: product.title,\n                    handle: product.handle,\n                    vendor: product.vendor,\n                    productType: product.product_type,\n                    createdAt: new Date(product.created_at),\n                    updatedAt: new Date(product.updated_at),\n                },\n            });\n\n            // Upsert variants\n            for (const variant of product.variants) {\n                await prisma.variant.upsert({\n                    where: { shopifyId: variant.id.toString() },\n                    update: {\n                        title: variant.title,\n                        sku: variant.sku,\n                        price: parseFloat(variant.price),\n                        inventoryQuantity: variant.inventory_quantity,\n                    },\n                    create: {\n                        productId: dbProduct.id,\n                        shopifyId: variant.id.toString(),\n                        title: variant.title,\n                        sku: variant.sku,\n                        price: parseFloat(variant.price),\n                        inventoryQuantity: variant.inventory_quantity,\n                    },\n                });\n            }\n\n            if (product.id > maxId) maxId = product.id;\n            sinceId = product.id;\n            totalProducts++;\n        }\n\n        // Update state after each batch to be safe\n        await updateSyncState(shopId, 'products', maxId.toString());\n        console.log(`[Sync] Processed ${totalProducts} products...`);\n    }\n\n    console.log(`[Sync] Finished syncing ${totalProducts} products`);\n    return totalProducts;\n}\n\nexport async function syncOrders(shopId: string, shopDomain: string, accessToken: string) {\n    console.log(`[Sync] Fetching orders for ${shopDomain}`);\n\n    const syncState = await getOrInitSyncState(shopId, 'orders');\n    let sinceId = parseInt(syncState.lastId);\n    console.log(`[Sync] Resuming orders from ID: ${sinceId}`);\n\n    let totalOrders = 0;\n    let maxId = sinceId;\n\n    while (true) {\n        const params: Record<string, string> = {\n            limit: '250',\n            since_id: sinceId.toString(),\n            status: 'any',\n        };\n\n        // If a start date is provided, we use it to filter\n        if (params.created_at_min) {\n            // Wait, shopify API for orders using since_id and created_at_min together can be tricky\n            // Better to use created_at_min for the initial high-priority sync\n        }\n\n        const data = await shopifyRequest(shopDomain, accessToken, 'orders.json', params) as { orders: ShopifyOrder[] };\n\n        const orders: ShopifyOrder[] = data.orders || [];\n        if (orders.length === 0) break;\n\n        for (const order of orders) {\n            // Get customer ID if exists\n            let customerId: string | null = null;\n            if (order.customer?.id) {\n                const customer = await prisma.customer.findUnique({\n                    where: { shopifyId: order.customer.id.toString() },\n                });\n                customerId = customer?.id || null;\n            }\n\n            // Upsert order with customer linking\n            const dbOrder = await prisma.order.upsert({\n                where: { shopifyId: order.id.toString() },\n                update: {\n                    customerId,\n                    totalPrice: parseFloat(order.total_price),\n                    subtotalPrice: parseFloat(order.subtotal_price),\n                    totalTax: parseFloat(order.total_tax),\n                    totalDiscounts: parseFloat(order.total_discounts),\n                    financialStatus: order.financial_status || null,\n                    fulfillmentStatus: order.fulfillment_status || null,\n                    updatedAt: new Date(order.updated_at),\n                },\n                create: {\n                    shopId,\n                    shopifyId: order.id.toString(),\n                    customerId,\n                    orderNumber: order.order_number.toString(),\n                    totalPrice: parseFloat(order.total_price),\n                    subtotalPrice: parseFloat(order.subtotal_price),\n                    totalTax: parseFloat(order.total_tax),\n                    totalDiscounts: parseFloat(order.total_discounts),\n                    financialStatus: order.financial_status || null,\n                    fulfillmentStatus: order.fulfillment_status || null,\n                    currency: order.currency,\n                    createdAt: new Date(order.created_at),\n                    updatedAt: new Date(order.updated_at),\n                },\n            });\n\n            // Update shop currency if not set or different\n            if (order.currency) {\n                await prisma.shop.update({\n                    where: { id: shopId },\n                    data: { currencyCode: order.currency }\n                }).catch(() => { }); // ignore errors during catch-all sync\n            }\n\n            // Upsert line items\n            for (const item of order.line_items) {\n                await prisma.orderLineItem.upsert({\n                    where: { shopifyId: item.id.toString() },\n                    update: {\n                        quantity: item.quantity,\n                        price: parseFloat(item.price),\n                        totalDiscount: parseFloat(item.total_discount),\n                    },\n                    create: {\n                        orderId: dbOrder.id,\n                        shopifyId: item.id.toString(),\n                        productId: item.product_id?.toString() || null,\n                        variantId: item.variant_id?.toString() || null,\n                        title: item.title,\n                        quantity: item.quantity,\n                        price: parseFloat(item.price),\n                        totalDiscount: parseFloat(item.total_discount),\n                    },\n                });\n            }\n\n            // Upsert refunds\n            for (const refund of order.refunds || []) {\n                const refundAmount = refund.transactions?.reduce((sum, t) => sum + parseFloat(t.amount || '0'), 0) || 0;\n                await prisma.refund.upsert({\n                    where: { shopifyId: refund.id.toString() },\n                    update: {\n                        amount: refundAmount,\n                    },\n                    create: {\n                        orderId: dbOrder.id,\n                        shopifyId: refund.id.toString(),\n                        amount: refundAmount,\n                        createdAt: new Date(refund.created_at),\n                    },\n                });\n            }\n\n            if (order.id > maxId) maxId = order.id;\n            sinceId = order.id;\n            totalOrders++;\n        }\n\n        await updateSyncState(shopId, 'orders', maxId.toString());\n        console.log(`[Sync] Processed ${totalOrders} orders...`);\n    }\n\n    console.log(`[Sync] Finished syncing ${totalOrders} orders`);\n    return totalOrders;\n}\n\n/**\n * Prioritized sync for the last 6 months\n */\nexport async function syncRecentData(shopId: string, shopDomain: string, accessToken: string) {\n    console.log(`[Sync] Running prioritized sync (last 6 months) for ${shopDomain}`);\n\n    const sixMonthsAgo = new Date();\n    sixMonthsAgo.setMonth(sixMonthsAgo.getMonth() - 6);\n    const dateStr = sixMonthsAgo.toISOString();\n\n    // 1. Sync Products (always sync all products as they are typically few)\n    await syncProducts(shopId, shopDomain, accessToken);\n\n    // 2. Sync Recent Orders\n    console.log(`[Sync] Fetching orders since ${dateStr}`);\n    let totalOrders = 0;\n    let nextPageInfo = \"\";\n\n    // For recent sync, we might want to use created_at_min\n    // However, shopifyRequest doesn't support Link header pagination yet in this simple implementation\n    // For the beta, we'll keep it simple but add the date filter if supported by the endpoint\n\n    // Actually, let's refine syncOrders to accept an optional startDate\n    return await syncOrdersWithFilter(shopId, shopDomain, accessToken, dateStr);\n}\n\nasync function syncOrdersWithFilter(shopId: string, shopDomain: string, accessToken: string, startDate?: string) {\n    let totalOrders = 0;\n    let sinceId = 0;\n\n    while (true) {\n        const params: Record<string, string> = {\n            limit: '250',\n            since_id: sinceId.toString(),\n            status: 'any',\n        };\n        if (startDate) params.created_at_min = startDate;\n\n        const data = await shopifyRequest(shopDomain, accessToken, 'orders.json', params) as { orders: ShopifyOrder[] };\n        const orders: ShopifyOrder[] = data.orders || [];\n        if (orders.length === 0) break;\n\n        for (const order of orders) {\n            // ... (Same order processing logic as in syncOrders)\n            // To avoid duplication, I should have refactored syncOrders\n            // I'll do that in a follow-up if needed, but for now I'll just reuse the core logic\n            await processOrder(shopId, order);\n            if (order.id > sinceId) sinceId = order.id;\n            totalOrders++;\n        }\n        console.log(`[Sync] Processed ${totalOrders} recent orders...`);\n    }\n    return totalOrders;\n}\n\n// Extract order processing to a reusable function\nasync function processOrder(shopId: string, order: ShopifyOrder) {\n    // Get customer ID if exists\n    let customerId: string | null = null;\n    if (order.customer?.id) {\n        const customer = await prisma.customer.findUnique({\n            where: { shopifyId: order.customer.id.toString() },\n        });\n        customerId = customer?.id || null;\n    }\n\n    // Upsert order\n    const dbOrder = await prisma.order.upsert({\n        where: { shopifyId: order.id.toString() },\n        update: {\n            customerId,\n            totalPrice: parseFloat(order.total_price),\n            subtotalPrice: parseFloat(order.subtotal_price),\n            totalTax: parseFloat(order.total_tax),\n            totalDiscounts: parseFloat(order.total_discounts),\n            financialStatus: order.financial_status || null,\n            fulfillmentStatus: order.fulfillment_status || null,\n            updatedAt: new Date(order.updated_at),\n        },\n        create: {\n            shopId,\n            shopifyId: order.id.toString(),\n            customerId,\n            orderNumber: order.order_number.toString(),\n            totalPrice: parseFloat(order.total_price),\n            subtotalPrice: parseFloat(order.subtotal_price),\n            totalTax: parseFloat(order.total_tax),\n            totalDiscounts: parseFloat(order.total_discounts),\n            financialStatus: order.financial_status || null,\n            fulfillmentStatus: order.fulfillment_status || null,\n            currency: order.currency,\n            createdAt: new Date(order.created_at),\n            updatedAt: new Date(order.updated_at),\n        },\n    });\n\n    // Update shop currency\n    if (order.currency) {\n        await prisma.shop.update({\n            where: { id: shopId },\n            data: { currencyCode: order.currency }\n        }).catch(() => { });\n    }\n\n    // Upsert line items\n    for (const item of order.line_items) {\n        await prisma.orderLineItem.upsert({\n            where: { shopifyId: item.id.toString() },\n            update: {\n                quantity: item.quantity,\n                price: parseFloat(item.price),\n                totalDiscount: parseFloat(item.total_discount),\n            },\n            create: {\n                orderId: dbOrder.id,\n                shopifyId: item.id.toString(),\n                productId: item.product_id?.toString() || null,\n                variantId: item.variant_id?.toString() || null,\n                title: item.title,\n                quantity: item.quantity,\n                price: parseFloat(item.price),\n                totalDiscount: parseFloat(item.total_discount),\n            },\n        });\n    }\n\n    // Upsert refunds\n    for (const refund of order.refunds || []) {\n        const refundAmount = refund.transactions?.reduce((sum, t) => sum + parseFloat(t.amount || '0'), 0) || 0;\n        await prisma.refund.upsert({\n            where: { shopifyId: refund.id.toString() },\n            update: { amount: refundAmount },\n            create: {\n                orderId: dbOrder.id,\n                shopifyId: refund.id.toString(),\n                amount: refundAmount,\n                createdAt: new Date(refund.created_at),\n            },\n        });\n    }\n}\n\nexport async function syncCustomers(shopId: string, shopDomain: string, accessToken: string) {\n    console.log(`[Sync] Fetching customers for ${shopDomain}`);\n\n    const syncState = await getOrInitSyncState(shopId, 'customers');\n    let sinceId = parseInt(syncState.lastId);\n    console.log(`[Sync] Resuming customers from ID: ${sinceId}`);\n\n    let totalCustomers = 0;\n    let maxId = sinceId;\n\n    while (true) {\n        const data = await shopifyRequest(shopDomain, accessToken, 'customers.json', {\n            limit: '250',\n            since_id: sinceId.toString(),\n        }) as { customers: ShopifyCustomer[] };\n\n        const customers: ShopifyCustomer[] = data.customers || [];\n        if (customers.length === 0) break;\n\n        for (const customer of customers) {\n            await prisma.customer.upsert({\n                where: { shopifyId: customer.id.toString() },\n                update: {\n                    email: customer.email,\n                    firstName: customer.first_name,\n                    lastName: customer.last_name,\n                },\n                create: {\n                    shopId,\n                    shopifyId: customer.id.toString(),\n                    email: customer.email,\n                    firstName: customer.first_name,\n                    lastName: customer.last_name,\n                    createdAt: new Date(customer.created_at),\n                },\n            });\n\n            if (customer.id > maxId) maxId = customer.id;\n            sinceId = customer.id;\n            totalCustomers++;\n        }\n\n        await updateSyncState(shopId, 'customers', maxId.toString());\n        console.log(`[Sync] Processed ${totalCustomers} customers...`);\n    }\n\n    console.log(`[Sync] Finished syncing ${totalCustomers} customers`);\n    return totalCustomers;\n}\n\nexport async function runFullSync(shopId: string) {\n    const shop = await prisma.shop.findUnique({ where: { id: shopId } });\n    if (!shop) throw new Error('Shop not found');\n\n    const accessToken = decrypt(shop.accessToken);\n    const shopDomain = shop.shopDomain;\n\n    console.log(`[Sync] Starting Smart Sync for ${shopDomain}`);\n\n    const results = {\n        products: 0,\n        orders: 0,\n        customers: 0,\n    };\n\n    let logId = '';\n    try {\n        const log = await createSyncLog(shopId, 'full');\n        logId = log.id;\n\n        // PHASE 1: Prioritized Sync (Last 6 Months)\n        console.log(`[Sync] Phase 1: Prioritized Sync (6 Months)`);\n        results.products = await syncProducts(shopId, shopDomain, accessToken);\n        results.orders = await syncRecentData(shopId, shopDomain, accessToken);\n        results.customers = await syncCustomers(shopId, shopDomain, accessToken);\n\n        console.log(`[Sync] Phase 1 Complete. Triggering Phase 2 (Historical) in background...`);\n\n        await updateSyncLog(logId, {\n            status: 'success',\n            stats: results\n        });\n\n        // PHASE 2: Historical Sync (Background)\n        (async () => {\n            let histLogId = '';\n            try {\n                const histLog = await createSyncLog(shopId, 'historical');\n                histLogId = histLog.id;\n\n                console.log(`[Sync] Phase 2: Starting historical sync for ${shopDomain}`);\n                // syncOrders without startDate will fetch all remaining history using since_id\n                const orders = await syncOrders(shopId, shopDomain, accessToken);\n\n                await updateSyncLog(histLogId, {\n                    status: 'success',\n                    stats: { orders }\n                });\n\n                console.log(`[Sync] Phase 2 Complete for ${shopDomain}`);\n            } catch (err: any) {\n                console.error('[Sync] Historical sync failed:', err.message);\n                if (histLogId) {\n                    await updateSyncLog(histLogId, {\n                        status: 'failed',\n                        error: err.message\n                    });\n                }\n            }\n        })();\n\n    } catch (err: any) {\n        console.error('[Sync] Smart Sync failed:', err.message);\n    }\n\n    console.log(`[Sync] Prioritized sync results:`, results);\n    return results;\n}\n"],"names":[],"mappings":"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"}},
    {"offset": {"line": 813, "column": 0}, "map": {"version":3,"sources":["file:///Users/mac/Desktop/NEW/packages/frontend/src/app/api/auth/shopify/callback/route.ts"],"sourcesContent":["import { NextRequest, NextResponse } from 'next/server';\nimport shopify, { sessionStorage } from '@brandmind/backend/shopify';\nimport { prisma } from '@brandmind/shared';\nimport { getCurrentUser } from '@brandmind/backend/auth/session';\nimport { encrypt } from '@brandmind/backend/auth/crypto';\nimport { cookies } from 'next/headers';\nimport { runFullSync } from '@brandmind/backend/sync/shopify-sync';\n\nexport async function GET(req: NextRequest) {\n    try {\n        console.log('[Shopify Callback] Incoming URL:', req.url);\n        console.log('[Shopify Callback] Headers Host:', req.headers.get('host'));\n        console.log('[Shopify Callback] Headers X-Forwarded-Proto:', req.headers.get('x-forwarded-proto'));\n\n        const user = await getCurrentUser();\n        console.log('[Shopify Callback] User found:', user ? user.id : 'NONE');\n\n        if (!user) {\n            console.error('[Shopify Callback] No user session found. Redirecting to login.');\n            return NextResponse.redirect(new URL('/auth/login', req.url));\n        }\n\n        // Validate the callback\n        const callbackResponse = await shopify.auth.callback({\n            rawRequest: req,\n            rawResponse: new Response(),\n        });\n\n        const { session } = callbackResponse;\n        if (!session || !session.accessToken) {\n            throw new Error('Failed to retrieve session from Shopify');\n        }\n\n        // Save session to storage (optional but good practice for Shopify API)\n        await sessionStorage.storeSession(session);\n\n        const shopDomain = session.shop;\n        const accessToken = session.accessToken;\n\n        // Check if shop is already connected to ANOTHER user\n        const existingShop = await prisma.shop.findUnique({ where: { shopDomain } });\n        if (existingShop && existingShop.userId && existingShop.userId !== user.id) {\n            console.error(`[Shopify OAuth Callback] Shop ${shopDomain} already connected to another user ${existingShop.userId}`);\n            return NextResponse.redirect(new URL('/onboarding?error=shop_already_connected', req.url));\n        }\n\n        // Save or update shop in our DB\n        const shop = await prisma.shop.upsert({\n            where: { shopDomain },\n            update: {\n                accessToken: encrypt(accessToken),\n                userId: user.id,\n            },\n            create: {\n                shopDomain,\n                accessToken: encrypt(accessToken),\n                userId: user.id,\n            },\n        });\n\n        // Set cookie for reference\n        const cookieStore = await cookies();\n        cookieStore.set(\"shopify_connected_shop\", shopDomain, {\n            httpOnly: true,\n            secure: process.env.NODE_ENV === \"production\",\n            sameSite: \"lax\",\n            maxAge: 30 * 24 * 60 * 60, // 30 days\n            path: \"/\",\n        });\n\n        // Trigger background sync (Phase 1: 6 months, Phase 2: everything else)\n        runFullSync(shop.id).catch(err => {\n            console.error('[Shopify OAuth Callback] Sync failed to start:', err);\n        });\n\n        // Redirect to a page that starts the sync and shows progress\n        // Use SHOPIFY_APP_URL if available to ensure we stay on the correct domain (ngrok)\n        const baseUrl = process.env.SHOPIFY_APP_URL || '';\n        const redirectUrl = new URL(`${baseUrl}/onboarding`);\n        redirectUrl.searchParams.set('shop', shopDomain);\n        redirectUrl.searchParams.set('mode', 'oauth_complete');\n\n        return NextResponse.redirect(redirectUrl);\n    } catch (error: any) {\n        console.error('[Shopify OAuth Callback] Error:', error);\n        // Redirect to onboarding with error\n        return NextResponse.redirect(new URL('/onboarding?error=oauth_failed', req.url));\n    }\n}\n"],"names":[],"mappings":";;;;AAAA;AACA;AAAA;AACA;AAAA;AACA;AACA;AACA;AACA;;;;;;;;AAEO,eAAe,IAAI,GAAgB;IACtC,IAAI;QACA,QAAQ,GAAG,CAAC,oCAAoC,IAAI,GAAG;QACvD,QAAQ,GAAG,CAAC,oCAAoC,IAAI,OAAO,CAAC,GAAG,CAAC;QAChE,QAAQ,GAAG,CAAC,iDAAiD,IAAI,OAAO,CAAC,GAAG,CAAC;QAE7E,MAAM,OAAO,MAAM,IAAA,iKAAc;QACjC,QAAQ,GAAG,CAAC,kCAAkC,OAAO,KAAK,EAAE,GAAG;QAE/D,IAAI,CAAC,MAAM;YACP,QAAQ,KAAK,CAAC;YACd,OAAO,gJAAY,CAAC,QAAQ,CAAC,IAAI,IAAI,eAAe,IAAI,GAAG;QAC/D;QAEA,wBAAwB;QACxB,MAAM,mBAAmB,MAAM,4JAAO,CAAC,IAAI,CAAC,QAAQ,CAAC;YACjD,YAAY;YACZ,aAAa,IAAI;QACrB;QAEA,MAAM,EAAE,OAAO,EAAE,GAAG;QACpB,IAAI,CAAC,WAAW,CAAC,QAAQ,WAAW,EAAE;YAClC,MAAM,IAAI,MAAM;QACpB;QAEA,uEAAuE;QACvE,MAAM,mKAAc,CAAC,YAAY,CAAC;QAElC,MAAM,aAAa,QAAQ,IAAI;QAC/B,MAAM,cAAc,QAAQ,WAAW;QAEvC,qDAAqD;QACrD,MAAM,eAAe,MAAM,+IAAM,CAAC,IAAI,CAAC,UAAU,CAAC;YAAE,OAAO;gBAAE;YAAW;QAAE;QAC1E,IAAI,gBAAgB,aAAa,MAAM,IAAI,aAAa,MAAM,KAAK,KAAK,EAAE,EAAE;YACxE,QAAQ,KAAK,CAAC,CAAC,8BAA8B,EAAE,WAAW,mCAAmC,EAAE,aAAa,MAAM,EAAE;YACpH,OAAO,gJAAY,CAAC,QAAQ,CAAC,IAAI,IAAI,4CAA4C,IAAI,GAAG;QAC5F;QAEA,gCAAgC;QAChC,MAAM,OAAO,MAAM,+IAAM,CAAC,IAAI,CAAC,MAAM,CAAC;YAClC,OAAO;gBAAE;YAAW;YACpB,QAAQ;gBACJ,aAAa,IAAA,yJAAO,EAAC;gBACrB,QAAQ,KAAK,EAAE;YACnB;YACA,QAAQ;gBACJ;gBACA,aAAa,IAAA,yJAAO,EAAC;gBACrB,QAAQ,KAAK,EAAE;YACnB;QACJ;QAEA,2BAA2B;QAC3B,MAAM,cAAc,MAAM,IAAA,4IAAO;QACjC,YAAY,GAAG,CAAC,0BAA0B,YAAY;YAClD,UAAU;YACV,QAAQ,oDAAyB;YACjC,UAAU;YACV,QAAQ,KAAK,KAAK,KAAK;YACvB,MAAM;QACV;QAEA,wEAAwE;QACxE,IAAA,sKAAW,EAAC,KAAK,EAAE,EAAE,KAAK,CAAC,CAAA;YACvB,QAAQ,KAAK,CAAC,kDAAkD;QACpE;QAEA,6DAA6D;QAC7D,mFAAmF;QACnF,MAAM,UAAU,QAAQ,GAAG,CAAC,eAAe,IAAI;QAC/C,MAAM,cAAc,IAAI,IAAI,GAAG,QAAQ,WAAW,CAAC;QACnD,YAAY,YAAY,CAAC,GAAG,CAAC,QAAQ;QACrC,YAAY,YAAY,CAAC,GAAG,CAAC,QAAQ;QAErC,OAAO,gJAAY,CAAC,QAAQ,CAAC;IACjC,EAAE,OAAO,OAAY;QACjB,QAAQ,KAAK,CAAC,mCAAmC;QACjD,oCAAoC;QACpC,OAAO,gJAAY,CAAC,QAAQ,CAAC,IAAI,IAAI,kCAAkC,IAAI,GAAG;IAClF;AACJ"}}]
}